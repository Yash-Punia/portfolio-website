var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/three/build/three.js
var require_three = __commonJS({
  "node_modules/three/build/three.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.THREE = {}));
    })(exports, function(exports2) {
      "use strict";
      const REVISION = "130";
      const MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      };
      const TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      };
      const CullFaceNone = 0;
      const CullFaceBack = 1;
      const CullFaceFront = 2;
      const CullFaceFrontBack = 3;
      const BasicShadowMap = 0;
      const PCFShadowMap = 1;
      const PCFSoftShadowMap = 2;
      const VSMShadowMap = 3;
      const FrontSide = 0;
      const BackSide = 1;
      const DoubleSide2 = 2;
      const FlatShading = 1;
      const SmoothShading = 2;
      const NoBlending = 0;
      const NormalBlending = 1;
      const AdditiveBlending = 2;
      const SubtractiveBlending = 3;
      const MultiplyBlending = 4;
      const CustomBlending = 5;
      const AddEquation = 100;
      const SubtractEquation = 101;
      const ReverseSubtractEquation = 102;
      const MinEquation = 103;
      const MaxEquation = 104;
      const ZeroFactor = 200;
      const OneFactor = 201;
      const SrcColorFactor = 202;
      const OneMinusSrcColorFactor = 203;
      const SrcAlphaFactor = 204;
      const OneMinusSrcAlphaFactor = 205;
      const DstAlphaFactor = 206;
      const OneMinusDstAlphaFactor = 207;
      const DstColorFactor = 208;
      const OneMinusDstColorFactor = 209;
      const SrcAlphaSaturateFactor = 210;
      const NeverDepth = 0;
      const AlwaysDepth = 1;
      const LessDepth = 2;
      const LessEqualDepth = 3;
      const EqualDepth = 4;
      const GreaterEqualDepth = 5;
      const GreaterDepth = 6;
      const NotEqualDepth = 7;
      const MultiplyOperation = 0;
      const MixOperation = 1;
      const AddOperation = 2;
      const NoToneMapping = 0;
      const LinearToneMapping = 1;
      const ReinhardToneMapping = 2;
      const CineonToneMapping = 3;
      const ACESFilmicToneMapping = 4;
      const CustomToneMapping = 5;
      const UVMapping = 300;
      const CubeReflectionMapping = 301;
      const CubeRefractionMapping = 302;
      const EquirectangularReflectionMapping = 303;
      const EquirectangularRefractionMapping = 304;
      const CubeUVReflectionMapping = 306;
      const CubeUVRefractionMapping = 307;
      const RepeatWrapping = 1e3;
      const ClampToEdgeWrapping = 1001;
      const MirroredRepeatWrapping = 1002;
      const NearestFilter = 1003;
      const NearestMipmapNearestFilter = 1004;
      const NearestMipMapNearestFilter = 1004;
      const NearestMipmapLinearFilter = 1005;
      const NearestMipMapLinearFilter = 1005;
      const LinearFilter = 1006;
      const LinearMipmapNearestFilter = 1007;
      const LinearMipMapNearestFilter = 1007;
      const LinearMipmapLinearFilter = 1008;
      const LinearMipMapLinearFilter = 1008;
      const UnsignedByteType = 1009;
      const ByteType = 1010;
      const ShortType = 1011;
      const UnsignedShortType = 1012;
      const IntType = 1013;
      const UnsignedIntType = 1014;
      const FloatType = 1015;
      const HalfFloatType = 1016;
      const UnsignedShort4444Type = 1017;
      const UnsignedShort5551Type = 1018;
      const UnsignedShort565Type = 1019;
      const UnsignedInt248Type = 1020;
      const AlphaFormat = 1021;
      const RGBFormat = 1022;
      const RGBAFormat = 1023;
      const LuminanceFormat = 1024;
      const LuminanceAlphaFormat = 1025;
      const RGBEFormat = RGBAFormat;
      const DepthFormat = 1026;
      const DepthStencilFormat = 1027;
      const RedFormat = 1028;
      const RedIntegerFormat = 1029;
      const RGFormat = 1030;
      const RGIntegerFormat = 1031;
      const RGBIntegerFormat = 1032;
      const RGBAIntegerFormat = 1033;
      const RGB_S3TC_DXT1_Format = 33776;
      const RGBA_S3TC_DXT1_Format = 33777;
      const RGBA_S3TC_DXT3_Format = 33778;
      const RGBA_S3TC_DXT5_Format = 33779;
      const RGB_PVRTC_4BPPV1_Format = 35840;
      const RGB_PVRTC_2BPPV1_Format = 35841;
      const RGBA_PVRTC_4BPPV1_Format = 35842;
      const RGBA_PVRTC_2BPPV1_Format = 35843;
      const RGB_ETC1_Format = 36196;
      const RGB_ETC2_Format = 37492;
      const RGBA_ETC2_EAC_Format = 37496;
      const RGBA_ASTC_4x4_Format = 37808;
      const RGBA_ASTC_5x4_Format = 37809;
      const RGBA_ASTC_5x5_Format = 37810;
      const RGBA_ASTC_6x5_Format = 37811;
      const RGBA_ASTC_6x6_Format = 37812;
      const RGBA_ASTC_8x5_Format = 37813;
      const RGBA_ASTC_8x6_Format = 37814;
      const RGBA_ASTC_8x8_Format = 37815;
      const RGBA_ASTC_10x5_Format = 37816;
      const RGBA_ASTC_10x6_Format = 37817;
      const RGBA_ASTC_10x8_Format = 37818;
      const RGBA_ASTC_10x10_Format = 37819;
      const RGBA_ASTC_12x10_Format = 37820;
      const RGBA_ASTC_12x12_Format = 37821;
      const RGBA_BPTC_Format = 36492;
      const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
      const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
      const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
      const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
      const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
      const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
      const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
      const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
      const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
      const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
      const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
      const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
      const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
      const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
      const LoopOnce = 2200;
      const LoopRepeat = 2201;
      const LoopPingPong = 2202;
      const InterpolateDiscrete = 2300;
      const InterpolateLinear = 2301;
      const InterpolateSmooth = 2302;
      const ZeroCurvatureEnding = 2400;
      const ZeroSlopeEnding = 2401;
      const WrapAroundEnding = 2402;
      const NormalAnimationBlendMode = 2500;
      const AdditiveAnimationBlendMode = 2501;
      const TrianglesDrawMode = 0;
      const TriangleStripDrawMode = 1;
      const TriangleFanDrawMode = 2;
      const LinearEncoding = 3e3;
      const sRGBEncoding = 3001;
      const GammaEncoding = 3007;
      const RGBEEncoding = 3002;
      const LogLuvEncoding = 3003;
      const RGBM7Encoding = 3004;
      const RGBM16Encoding = 3005;
      const RGBDEncoding = 3006;
      const BasicDepthPacking = 3200;
      const RGBADepthPacking = 3201;
      const TangentSpaceNormalMap = 0;
      const ObjectSpaceNormalMap = 1;
      const ZeroStencilOp = 0;
      const KeepStencilOp = 7680;
      const ReplaceStencilOp = 7681;
      const IncrementStencilOp = 7682;
      const DecrementStencilOp = 7683;
      const IncrementWrapStencilOp = 34055;
      const DecrementWrapStencilOp = 34056;
      const InvertStencilOp = 5386;
      const NeverStencilFunc = 512;
      const LessStencilFunc = 513;
      const EqualStencilFunc = 514;
      const LessEqualStencilFunc = 515;
      const GreaterStencilFunc = 516;
      const NotEqualStencilFunc = 517;
      const GreaterEqualStencilFunc = 518;
      const AlwaysStencilFunc = 519;
      const StaticDrawUsage = 35044;
      const DynamicDrawUsage = 35048;
      const StreamDrawUsage = 35040;
      const StaticReadUsage = 35045;
      const DynamicReadUsage = 35049;
      const StreamReadUsage = 35041;
      const StaticCopyUsage = 35046;
      const DynamicCopyUsage = 35050;
      const StreamCopyUsage = 35042;
      const GLSL1 = "100";
      const GLSL3 = "300 es";
      class EventDispatcher {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index2 = listenerArray.indexOf(listener);
            if (index2 !== -1) {
              listenerArray.splice(index2, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i = 0, l = array.length; i < l; i++) {
              array[i].call(this, event);
            }
            event.target = null;
          }
        }
      }
      const _lut = [];
      for (let i = 0; i < 256; i++) {
        _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
      }
      let _seed = 1234567;
      const DEG2RAD = Math.PI / 180;
      const RAD2DEG = 180 / Math.PI;
      function generateUUID() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      }
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function euclideanModulo(n, m) {
        return (n % m + m) % m;
      }
      function mapLinear(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      }
      function inverseLerp(x, y, value) {
        if (x !== y) {
          return (value - x) / (y - x);
        } else {
          return 0;
        }
      }
      function lerp(x, y, t) {
        return (1 - t) * x + t * y;
      }
      function damp(x, y, lambda, dt) {
        return lerp(x, y, 1 - Math.exp(-lambda * dt));
      }
      function pingpong(x, length = 1) {
        return length - Math.abs(euclideanModulo(x, length * 2) - length);
      }
      function smoothstep(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      }
      function smootherstep(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      }
      function randInt(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      }
      function randFloat(low, high) {
        return low + Math.random() * (high - low);
      }
      function randFloatSpread(range) {
        return range * (0.5 - Math.random());
      }
      function seededRandom(s2) {
        if (s2 !== void 0)
          _seed = s2 % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
      }
      function degToRad(degrees) {
        return degrees * DEG2RAD;
      }
      function radToDeg(radians) {
        return radians * RAD2DEG;
      }
      function isPowerOfTwo(value) {
        return (value & value - 1) === 0 && value !== 0;
      }
      function ceilPowerOfTwo(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      }
      function floorPowerOfTwo(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      }
      function setQuaternionFromProperEuler(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch (order) {
          case "XYX":
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
          case "YZY":
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
          case "ZXZ":
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
          case "XZX":
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
          case "YXY":
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
          case "ZYZ":
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
      var MathUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD,
        RAD2DEG,
        generateUUID,
        clamp,
        euclideanModulo,
        mapLinear,
        inverseLerp,
        lerp,
        damp,
        pingpong,
        smoothstep,
        smootherstep,
        randInt,
        randFloat,
        randFloatSpread,
        seededRandom,
        degToRad,
        radToDeg,
        isPowerOfTwo,
        ceilPowerOfTwo,
        floorPowerOfTwo,
        setQuaternionFromProperEuler
      });
      class Vector22 {
        constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setComponent(index2, value) {
          switch (index2) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index2);
          }
          return this;
        }
        getComponent(index2) {
          switch (index2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        }
        addScaledVector(v, s2) {
          this.x += v.x * s2;
          this.y += v.y * s2;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6];
          this.y = e[1] * x + e[4] * y + e[7];
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y;
        }
        cross(v) {
          return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index2, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index2);
          this.y = attribute.getY(index2);
          return this;
        }
        rotateAround(center, angle) {
          const c = Math.cos(angle), s2 = Math.sin(angle);
          const x = this.x - center.x;
          const y = this.y - center.y;
          this.x = x * c - y * s2 + center.x;
          this.y = x * s2 + y * c + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
      }
      Vector22.prototype.isVector2 = true;
      class Matrix3 {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te = this.elements;
          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m) {
          const me = m.elements;
          this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
          return this;
        }
        multiply(m) {
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[3], a13 = ae[6];
          const a21 = ae[1], a22 = ae[4], a23 = ae[7];
          const a31 = ae[2], a32 = ae[5], a33 = ae[8];
          const b11 = be[0], b12 = be[3], b13 = be[6];
          const b21 = be[1], b22 = be[4], b23 = be[7];
          const b31 = be[2], b32 = be[5], b33 = be[8];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s2) {
          const te = this.elements;
          te[0] *= s2;
          te[3] *= s2;
          te[6] *= s2;
          te[1] *= s2;
          te[4] *= s2;
          te[7] *= s2;
          te[2] *= s2;
          te[5] *= s2;
          te[8] *= s2;
          return this;
        }
        determinant() {
          const te = this.elements;
          const a = te[0], b = te[1], c = te[2], d2 = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
          return a * e * i - a * f * h - b * d2 * i + b * f * g + c * d2 * h - c * e * g;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;
          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;
          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp2;
          const m = this.elements;
          tmp2 = m[1];
          m[1] = m[3];
          m[3] = tmp2;
          tmp2 = m[2];
          m[2] = m[6];
          m[6] = tmp2;
          tmp2 = m[5];
          m[5] = m[7];
          m[7] = tmp2;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r) {
          const m = this.elements;
          r[0] = m[0];
          r[1] = m[3];
          r[2] = m[6];
          r[3] = m[1];
          r[4] = m[4];
          r[5] = m[7];
          r[6] = m[2];
          r[7] = m[5];
          r[8] = m[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
          const c = Math.cos(rotation);
          const s2 = Math.sin(rotation);
          this.set(sx * c, sx * s2, -sx * (c * cx + s2 * cy) + cx + tx, -sy * s2, sy * c, -sy * (-s2 * cx + c * cy) + cy + ty, 0, 0, 1);
          return this;
        }
        scale(sx, sy) {
          const te = this.elements;
          te[0] *= sx;
          te[3] *= sx;
          te[6] *= sx;
          te[1] *= sy;
          te[4] *= sy;
          te[7] *= sy;
          return this;
        }
        rotate(theta) {
          const c = Math.cos(theta);
          const s2 = Math.sin(theta);
          const te = this.elements;
          const a11 = te[0], a12 = te[3], a13 = te[6];
          const a21 = te[1], a22 = te[4], a23 = te[7];
          te[0] = c * a11 + s2 * a21;
          te[3] = c * a12 + s2 * a22;
          te[6] = c * a13 + s2 * a23;
          te[1] = -s2 * a11 + c * a21;
          te[4] = -s2 * a12 + c * a22;
          te[7] = -s2 * a13 + c * a23;
          return this;
        }
        translate(tx, ty) {
          const te = this.elements;
          te[0] += tx * te[2];
          te[3] += tx * te[5];
          te[6] += tx * te[8];
          te[1] += ty * te[2];
          te[4] += ty * te[5];
          te[7] += ty * te[8];
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i = 0; i < 9; i++) {
            if (te[i] !== me[i])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i = 0; i < 9; i++) {
            this.elements[i] = array[i + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      Matrix3.prototype.isMatrix3 = true;
      let _canvas;
      class ImageUtils {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas === void 0)
              _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
      }
      let textureId = 0;
      class Texture2 extends EventDispatcher {
        constructor(image = Texture2.DEFAULT_IMAGE, mapping = Texture2.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
          super();
          Object.defineProperty(this, "id", {
            value: textureId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.image = image;
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format2;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector22(0, 0);
          this.repeat = new Vector22(1, 1);
          this.center = new Vector22(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix3();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.version = 0;
          this.onUpdate = null;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.image = source.image;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (this.image !== void 0) {
            const image = this.image;
            if (image.uuid === void 0) {
              image.uuid = generateUUID();
            }
            if (!isRootObject && meta.images[image.uuid] === void 0) {
              let url;
              if (Array.isArray(image)) {
                url = [];
                for (let i = 0, l = image.length; i < l; i++) {
                  if (image[i].isDataTexture) {
                    url.push(serializeImage(image[i].image));
                  } else {
                    url.push(serializeImage(image[i]));
                  }
                }
              } else {
                url = serializeImage(image);
              }
              meta.images[image.uuid] = {
                uuid: image.uuid,
                url
              };
            }
            output.image = image.uuid;
          }
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      }
      Texture2.DEFAULT_IMAGE = void 0;
      Texture2.DEFAULT_MAPPING = UVMapping;
      Texture2.prototype.isTexture = true;
      function serializeImage(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          return ImageUtils.getDataURL(image);
        } else {
          if (image.data) {
            return {
              data: Array.prototype.slice.call(image.data),
              width: image.width,
              height: image.height,
              type: image.data.constructor.name
            };
          } else {
            console.warn("THREE.Texture: Unable to serialize Texture.");
            return {};
          }
        }
      }
      class Vector4 {
        constructor(x = 0, y = 0, z2 = 0, w = 1) {
          this.x = x;
          this.y = y;
          this.z = z2;
          this.w = w;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x, y, z2, w) {
          this.x = x;
          this.y = y;
          this.z = z2;
          this.w = w;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z2) {
          this.z = z2;
          return this;
        }
        setW(w) {
          this.w = w;
          return this;
        }
        setComponent(index2, value) {
          switch (index2) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index2);
          }
          return this;
        }
        getComponent(index2) {
          switch (index2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = v.w !== void 0 ? v.w : 1;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          this.z += s2;
          this.w += s2;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        }
        addScaledVector(v, s2) {
          this.x += v.x * s2;
          this.y += v.y * s2;
          this.z += v.z * s2;
          this.w += v.w * s2;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          this.z -= s2;
          this.w -= s2;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          this.w *= v.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z2 = this.z, w = this.w;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z2 + e[12] * w;
          this.y = e[1] * x + e[5] * y + e[9] * z2 + e[13] * w;
          this.z = e[2] * x + e[6] * y + e[10] * z2 + e[14] * w;
          this.w = e[3] * x + e[7] * y + e[11] * z2 + e[15] * w;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
          this.w = 2 * Math.acos(q.w);
          const s2 = Math.sqrt(1 - q.w * q.w);
          if (s2 < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q.x / s2;
            this.y = q.y / s2;
            this.z = q.z / s2;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m) {
          let angle, x, y, z2;
          const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x = 0;
                y = 0.707106781;
                z2 = 0.707106781;
              } else {
                x = Math.sqrt(xx);
                y = xy / x;
                z2 = xz / x;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x = 0.707106781;
                y = 0;
                z2 = 0.707106781;
              } else {
                y = Math.sqrt(yy);
                x = xy / y;
                z2 = yz / y;
              }
            } else {
              if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z2 = 0;
              } else {
                z2 = Math.sqrt(zz);
                x = xz / z2;
                y = yz / z2;
              }
            }
            this.set(x, y, z2, angle);
            return this;
          }
          let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s2) < 1e-3)
            s2 = 1;
          this.x = (m32 - m23) / s2;
          this.y = (m13 - m31) / s2;
          this.z = (m21 - m12) / s2;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index2, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index2);
          this.y = attribute.getY(index2);
          this.z = attribute.getZ(index2);
          this.w = attribute.getW(index2);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
      }
      Vector4.prototype.isVector4 = true;
      class WebGLRenderTarget extends EventDispatcher {
        constructor(width, height, options2 = {}) {
          super();
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width, height);
          this.texture = new Texture2(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
          this.texture.image = {
            width,
            height,
            depth: 1
          };
          this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
          this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
          this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
          this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
          this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
        }
        setTexture(texture) {
          texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
          };
          this.texture = texture;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.image = {
            ...this.texture.image
          };
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
      class WebGLMultipleRenderTargets extends WebGLRenderTarget {
        constructor(width, height, count) {
          super(width, height);
          const texture = this.texture;
          this.texture = [];
          for (let i = 0; i < count; i++) {
            this.texture[i] = texture.clone();
          }
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for (let i = 0, il = this.texture.length; i < il; i++) {
              this.texture[i].image.width = width;
              this.texture[i].image.height = height;
              this.texture[i].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          this.texture.length = 0;
          for (let i = 0, il = source.texture.length; i < il; i++) {
            this.texture[i] = source.texture[i].clone();
          }
          return this;
        }
      }
      WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
      class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
        constructor(width, height, options2) {
          super(width, height, options2);
          this.samples = 4;
        }
        copy(source) {
          super.copy.call(this, source);
          this.samples = source.samples;
          return this;
        }
      }
      WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
      class Quaternion {
        constructor(x = 0, y = 0, z2 = 0, w = 1) {
          this._x = x;
          this._y = y;
          this._z = z2;
          this._w = w;
        }
        static slerp(qa, qb, qm, t) {
          console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
          return qm.slerpQuaternions(qa, qb, t);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s2 = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s2 = Math.sin(s2 * len) / sin;
              t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s2 + x1 * tDir;
            y0 = y0 * s2 + y1 * tDir;
            z0 = z0 * s2 + z1 * tDir;
            w0 = w0 * s2 + w1 * tDir;
            if (s2 === 1 - t) {
              const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f;
              y0 *= f;
              z0 *= f;
              w0 *= f;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x, y, z2, w) {
          this._x = x;
          this._y = y;
          this._z = z2;
          this._w = w;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          const x = euler._x, y = euler._y, z2 = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z2 / 2);
          const s1 = sin(x / 2);
          const s2 = sin(y / 2);
          const s3 = sin(z2 / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
          this._x = axis.x * s2;
          this._y = axis.y * s2;
          this._z = axis.z * s2;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m) {
          const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s2 = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s2;
            this._x = (m32 - m23) * s2;
            this._y = (m13 - m31) * s2;
            this._z = (m21 - m12) * s2;
          } else if (m11 > m22 && m11 > m33) {
            const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s2;
            this._x = 0.25 * s2;
            this._y = (m12 + m21) / s2;
            this._z = (m13 + m31) / s2;
          } else if (m22 > m33) {
            const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s2;
            this._x = (m12 + m21) / s2;
            this._y = 0.25 * s2;
            this._z = (m23 + m32) / s2;
          } else {
            const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s2;
            this._x = (m13 + m31) / s2;
            this._y = (m23 + m32) / s2;
            this._z = 0.25 * s2;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r = vFrom.dot(vTo) + 1;
          if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
          }
          return this.normalize();
        }
        angleTo(q) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
          const angle = this.angleTo(q);
          if (angle === 0)
            return this;
          const t = Math.min(1, step / angle);
          this.slerp(q, t);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v) {
          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l = this.length();
          if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q, p) {
          if (p !== void 0) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
          }
          return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
          return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
          const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
          const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t) {
          if (t === 0)
            return this;
          if (t === 1)
            return this.copy(qb);
          const x = this._x, y = this._y, z2 = this._z, w = this._w;
          let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z2 * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z2;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s2 = 1 - t;
            this._w = s2 * w + t * this._w;
            this._x = s2 * x + t * this._x;
            this._y = s2 * y + t * this._y;
            this._z = s2 * z2 + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
          this._w = w * ratioA + this._w * ratioB;
          this._x = x * ratioA + this._x * ratioB;
          this._y = y * ratioA + this._y * ratioB;
          this._z = z2 * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa, qb, t) {
          this.copy(qa).slerp(qb, t);
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index2) {
          this._x = attribute.getX(index2);
          this._y = attribute.getY(index2);
          this._z = attribute.getZ(index2);
          this._w = attribute.getW(index2);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      }
      Quaternion.prototype.isQuaternion = true;
      class Vector3 {
        constructor(x = 0, y = 0, z2 = 0) {
          this.x = x;
          this.y = y;
          this.z = z2;
        }
        set(x, y, z2) {
          if (z2 === void 0)
            z2 = this.z;
          this.x = x;
          this.y = y;
          this.z = z2;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z2) {
          this.z = z2;
          return this;
        }
        setComponent(index2, value) {
          switch (index2) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index2);
          }
          return this;
        }
        getComponent(index2) {
          switch (index2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        addScalar(s2) {
          this.x += s2;
          this.y += s2;
          this.z += s2;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        }
        addScaledVector(v, s2) {
          this.x += v.x * s2;
          this.y += v.y * s2;
          this.z += v.z * s2;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        subScalar(s2) {
          this.x -= s2;
          this.y -= s2;
          this.z -= s2;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        }
        multiply(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
          }
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        }
        applyEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y, z2 = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6] * z2;
          this.y = e[1] * x + e[4] * y + e[7] * z2;
          this.z = e[2] * x + e[5] * y + e[8] * z2;
          return this;
        }
        applyNormalMatrix(m) {
          return this.applyMatrix3(m).normalize();
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z2 = this.z;
          const e = m.elements;
          const w = 1 / (e[3] * x + e[7] * y + e[11] * z2 + e[15]);
          this.x = (e[0] * x + e[4] * y + e[8] * z2 + e[12]) * w;
          this.y = (e[1] * x + e[5] * y + e[9] * z2 + e[13]) * w;
          this.z = (e[2] * x + e[6] * y + e[10] * z2 + e[14]) * w;
          return this;
        }
        applyQuaternion(q) {
          const x = this.x, y = this.y, z2 = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x + qy * z2 - qz * y;
          const iy = qw * y + qz * x - qx * z2;
          const iz = qw * z2 + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z2;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m) {
          const x = this.x, y = this.y, z2 = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z2;
          this.y = e[1] * x + e[5] * y + e[9] * z2;
          this.z = e[2] * x + e[6] * y + e[10] * z2;
          return this.normalize();
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
          }
          return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
          const ax = a.x, ay = a.y, az = a.z;
          const bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v) {
          const denominator = v.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v.dot(this) / denominator;
          return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c);
        }
        reflect(normal) {
          return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s2) {
          return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c) {
          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m) {
          const e = m.elements;
          this.x = e[12];
          this.y = e[13];
          this.z = e[14];
          return this;
        }
        setFromMatrixScale(m) {
          const sx = this.setFromMatrixColumn(m, 0).length();
          const sy = this.setFromMatrixColumn(m, 1).length();
          const sz = this.setFromMatrixColumn(m, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m, index2) {
          return this.fromArray(m.elements, index2 * 4);
        }
        setFromMatrix3Column(m, index2) {
          return this.fromArray(m.elements, index2 * 3);
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index2, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index2);
          this.y = attribute.getY(index2);
          this.z = attribute.getZ(index2);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
      }
      Vector3.prototype.isVector3 = true;
      const _vector$c = /* @__PURE__ */ new Vector3();
      const _quaternion$4 = /* @__PURE__ */ new Quaternion();
      class Box3 {
        constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i = 0, l = array.length; i < l; i += 3) {
            const x = array[i];
            const y = array[i + 1];
            const z2 = array[i + 2];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z2 < minZ)
              minZ = z2;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z2 > maxZ)
              maxZ = z2;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i = 0, l = attribute.count; i < l; i++) {
            const x = attribute.getX(i);
            const y = attribute.getY(i);
            const z2 = attribute.getZ(i);
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z2 < minZ)
              minZ = z2;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z2 > maxZ)
              maxZ = z2;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object) {
          this.makeEmpty();
          return this.expandByObject(object);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$3.copy(geometry.boundingBox);
            _box$3.applyMatrix4(object.matrixWorld);
            this.union(_box$3);
          }
          const children = object.children;
          for (let i = 0, l = children.length; i < l; i++) {
            this.expandByObject(children[i]);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b);
          return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$3.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$3, _v1$7);
          _f2.subVectors(_v0$2, _v2$3);
          let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      }
      Box3.prototype.isBox3 = true;
      const _points = [/* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3()];
      const _vector$b = /* @__PURE__ */ new Vector3();
      const _box$3 = /* @__PURE__ */ new Box3();
      const _v0$2 = /* @__PURE__ */ new Vector3();
      const _v1$7 = /* @__PURE__ */ new Vector3();
      const _v2$3 = /* @__PURE__ */ new Vector3();
      const _f0 = /* @__PURE__ */ new Vector3();
      const _f1 = /* @__PURE__ */ new Vector3();
      const _f2 = /* @__PURE__ */ new Vector3();
      const _center = /* @__PURE__ */ new Vector3();
      const _extents = /* @__PURE__ */ new Vector3();
      const _triangleNormal = /* @__PURE__ */ new Vector3();
      const _testAxis = /* @__PURE__ */ new Vector3();
      function satForAxes(axes, v0, v1, v2, extents) {
        for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
          _testAxis.fromArray(axes, i);
          const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
          const p0 = v0.dot(_testAxis);
          const p1 = v1.dot(_testAxis);
          const p2 = v2.dot(_testAxis);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
            return false;
          }
        }
        return true;
      }
      const _box$2 = /* @__PURE__ */ new Box3();
      const _v1$6 = /* @__PURE__ */ new Vector3();
      const _toFarthestPoint = /* @__PURE__ */ new Vector3();
      const _toPoint = /* @__PURE__ */ new Vector3();
      class Sphere {
        constructor(center = new Vector3(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i = 0, il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          _toPoint.subVectors(point, this.center);
          const lengthSq = _toPoint.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
          }
          return this;
        }
        union(sphere) {
          _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
          this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _vector$a = /* @__PURE__ */ new Vector3();
      const _segCenter = /* @__PURE__ */ new Vector3();
      const _segDir = /* @__PURE__ */ new Vector3();
      const _diff = /* @__PURE__ */ new Vector3();
      const _edge1 = /* @__PURE__ */ new Vector3();
      const _edge2 = /* @__PURE__ */ new Vector3();
      const _normal$1 = /* @__PURE__ */ new Vector3();
      class Ray {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t, target) {
          return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(v) {
          this.direction.copy(v).sub(this.origin).normalize();
          return this;
        }
        recast(t) {
          this.origin.copy(this.at(t, _vector$a));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a.subVectors(sphere.center, this.origin);
          const tca = _vector$a.dot(this.direction);
          const d2 = _vector$a.dot(_vector$a) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
          const t = this.distanceToPlane(plane);
          if (t === null) {
            return null;
          }
          return this.at(t, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
          if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
          _edge1.subVectors(b, a);
          _edge2.subVectors(c, a);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign2;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign2 = 1;
          } else if (DdN < 0) {
            sign2 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a);
          const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign2 * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Matrix4 {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te = this.elements;
          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];
          return this;
        }
        copyPosition(m) {
          const te = this.elements, me = m.elements;
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          return this;
        }
        setFromMatrix3(m) {
          const me = m.elements;
          this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(m) {
          const te = this.elements;
          const me = m.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          }
          const te = this.elements;
          const x = euler.x, y = euler.y, z2 = euler.z;
          const a = Math.cos(x), b = Math.sin(x);
          const c = Math.cos(y), d2 = Math.sin(y);
          const e = Math.cos(z2), f = Math.sin(z2);
          if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d2;
            te[1] = af + be * d2;
            te[5] = ae - bf * d2;
            te[9] = -b * c;
            te[2] = bf - ae * d2;
            te[6] = be + af * d2;
            te[10] = a * c;
          } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d2;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
          } else if (euler.order === "ZXY") {
            const ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d2;
            te[6] = b;
            te[10] = a * c;
          } else if (euler.order === "ZYX") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d2 - af;
            te[8] = ae * d2 + bf;
            te[1] = c * f;
            te[5] = bf * d2 + ae;
            te[9] = af * d2 - be;
            te[2] = -d2;
            te[6] = b * c;
            te[10] = a * c;
          } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d2, bc = b * c, bd = b * d2;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d2 * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
          } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d2, bc = b * c, bd = b * d2;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d2 * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
          }
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q) {
          return this.compose(_zero, q, _one);
        }
        lookAt(eye, target, up) {
          const te = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te[0] = _x.x;
          te[4] = _y.x;
          te[8] = _z.x;
          te[1] = _x.y;
          te[5] = _y.y;
          te[9] = _z.y;
          te[2] = _x.z;
          te[6] = _y.z;
          te[10] = _z.z;
          return this;
        }
        multiply(m, n) {
          if (n !== void 0) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
          }
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
          const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
          const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
          const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
          const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
          const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
          const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
          const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s2) {
          const te = this.elements;
          te[0] *= s2;
          te[4] *= s2;
          te[8] *= s2;
          te[12] *= s2;
          te[1] *= s2;
          te[5] *= s2;
          te[9] *= s2;
          te[13] *= s2;
          te[2] *= s2;
          te[6] *= s2;
          te[10] *= s2;
          te[14] *= s2;
          te[3] *= s2;
          te[7] *= s2;
          te[11] *= s2;
          te[15] *= s2;
          return this;
        }
        determinant() {
          const te = this.elements;
          const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
          const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
          const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
          const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te = this.elements;
          let tmp2;
          tmp2 = te[1];
          te[1] = te[4];
          te[4] = tmp2;
          tmp2 = te[2];
          te[2] = te[8];
          te[8] = tmp2;
          tmp2 = te[6];
          te[6] = te[9];
          te[9] = tmp2;
          tmp2 = te[3];
          te[3] = te[12];
          te[12] = tmp2;
          tmp2 = te[7];
          te[7] = te[13];
          te[13] = tmp2;
          tmp2 = te[11];
          te[11] = te[14];
          te[14] = tmp2;
          return this;
        }
        setPosition(x, y, z2) {
          const te = this.elements;
          if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
          } else {
            te[12] = x;
            te[13] = y;
            te[14] = z2;
          }
          return this;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v) {
          const te = this.elements;
          const x = v.x, y = v.y, z2 = v.z;
          te[0] *= x;
          te[4] *= y;
          te[8] *= z2;
          te[1] *= x;
          te[5] *= y;
          te[9] *= z2;
          te[2] *= x;
          te[6] *= y;
          te[10] *= z2;
          te[3] *= x;
          te[7] *= y;
          te[11] *= z2;
          return this;
        }
        getMaxScaleOnAxis() {
          const te = this.elements;
          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z2) {
          this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z2, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(theta) {
          const c = Math.cos(theta), s2 = Math.sin(theta);
          this.set(1, 0, 0, 0, 0, c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(theta) {
          const c = Math.cos(theta), s2 = Math.sin(theta);
          this.set(c, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(theta) {
          const c = Math.cos(theta), s2 = Math.sin(theta);
          this.set(c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c = Math.cos(angle);
          const s2 = Math.sin(angle);
          const t = 1 - c;
          const x = axis.x, y = axis.y, z2 = axis.z;
          const tx = t * x, ty = t * y;
          this.set(tx * x + c, tx * y - s2 * z2, tx * z2 + s2 * y, 0, tx * y + s2 * z2, ty * y + c, ty * z2 - s2 * x, 0, tx * z2 - s2 * y, ty * z2 + s2 * x, t * z2 * z2 + c, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(x, y, z2) {
          this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(position, quaternion, scale) {
          const te = this.elements;
          const x = quaternion._x, y = quaternion._y, z2 = quaternion._z, w = quaternion._w;
          const x2 = x + x, y2 = y + y, z22 = z2 + z2;
          const xx = x * x2, xy = x * y2, xz = x * z22;
          const yy = y * y2, yz = y * z22, zz = z2 * z22;
          const wx = w * x2, wy = w * y2, wz = w * z22;
          const sx = scale.x, sy = scale.y, sz = scale.z;
          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;
          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;
          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;
          te[12] = position.x;
          te[13] = position.y;
          te[14] = position.z;
          te[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale) {
          const te = this.elements;
          let sx = _v1$5.set(te[0], te[1], te[2]).length();
          const sy = _v1$5.set(te[4], te[5], te[6]).length();
          const sz = _v1$5.set(te[8], te[9], te[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          if (far === void 0) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          }
          const te = this.elements;
          const x = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);
          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d2 = -2 * far * near / (far - near);
          te[0] = x;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d2;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te = this.elements;
          const w = 1 / (right - left);
          const h = 1 / (top - bottom);
          const p = 1 / (far - near);
          const x = (right + left) * w;
          const y = (top + bottom) * h;
          const z2 = (far + near) * p;
          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x;
          te[1] = 0;
          te[5] = 2 * h;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p;
          te[14] = -z2;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i = 0; i < 16; i++) {
            if (te[i] !== me[i])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i = 0; i < 16; i++) {
            this.elements[i] = array[i + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];
          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];
          return array;
        }
      }
      Matrix4.prototype.isMatrix4 = true;
      const _v1$5 = /* @__PURE__ */ new Vector3();
      const _m1$2 = /* @__PURE__ */ new Matrix4();
      const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
      const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
      const _x = /* @__PURE__ */ new Vector3();
      const _y = /* @__PURE__ */ new Vector3();
      const _z = /* @__PURE__ */ new Vector3();
      const _matrix$1 = /* @__PURE__ */ new Matrix4();
      const _quaternion$3 = /* @__PURE__ */ new Quaternion();
      class Euler {
        constructor(x = 0, y = 0, z2 = 0, order = Euler.DefaultOrder) {
          this._x = x;
          this._y = y;
          this._z = z2;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x, y, z2, order = this._order) {
          this._x = x;
          this._y = y;
          this._z = z2;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m, order = this._order, update = true) {
          const te = m.elements;
          const m11 = te[0], m12 = te[4], m13 = te[8];
          const m21 = te[1], m22 = te[5], m23 = te[9];
          const m31 = te[2], m32 = te[6], m33 = te[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q, order, update) {
          _matrix$1.makeRotationFromQuaternion(q);
          return this.setFromRotationMatrix(_matrix$1, order, update);
        }
        setFromVector3(v, order = this._order) {
          return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        toVector3(optionalResult) {
          if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
          } else {
            return new Vector3(this._x, this._y, this._z);
          }
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      }
      Euler.prototype.isEuler = true;
      Euler.DefaultOrder = "XYZ";
      Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Layers {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = 1 << channel | 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
      }
      let _object3DId = 0;
      const _v1$4 = /* @__PURE__ */ new Vector3();
      const _q1 = /* @__PURE__ */ new Quaternion();
      const _m1$1 = /* @__PURE__ */ new Matrix4();
      const _target = /* @__PURE__ */ new Vector3();
      const _position$3 = /* @__PURE__ */ new Vector3();
      const _scale$2 = /* @__PURE__ */ new Vector3();
      const _quaternion$2 = /* @__PURE__ */ new Quaternion();
      const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
      const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
      const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
      const _addedEvent = {
        type: "added"
      };
      const _removedEvent = {
        type: "removed"
      };
      class Object3D extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _object3DId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D.DefaultUp.clone();
          const position = new Vector3();
          const rotation = new Euler();
          const quaternion = new Quaternion();
          const scale = new Vector3(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix3()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
          this.quaternion.premultiply(q);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
          this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
          this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x, y, z2) {
          if (x.isVector3) {
            _target.copy(x);
          } else {
            _target.set(x, y, z2);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) {
              this.add(arguments[i]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) {
              this.remove(arguments[i]);
            }
            return this;
          }
          const index2 = this.children.indexOf(object);
          if (index2 !== -1) {
            object.parent = null;
            this.children.splice(index2, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i = 0; i < this.children.length; i++) {
            const object = this.children[i];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id) {
          return this.getObjectByProperty("id", id);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i = 0, l = this.children.length; i < l; i++) {
            const child = this.children[i];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            children[i].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            children[i].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            children[i].updateMatrixWorld(force);
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
              children[i].updateWorldMatrix(false, true);
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== "{}")
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i = 0, l = shapes.length; i < l; i++) {
                  const shape = shapes[i];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i = 0, l = this.material.length; i < l; i++) {
                uuids.push(serialize(meta.materials, this.material[i]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i = 0; i < this.children.length; i++) {
              object.children.push(this.children[i].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i = 0; i < this.animations.length; i++) {
              const animation = this.animations[i];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i = 0; i < source.children.length; i++) {
              const child = source.children[i];
              this.add(child.clone());
            }
          }
          return this;
        }
      }
      Object3D.DefaultUp = new Vector3(0, 1, 0);
      Object3D.DefaultMatrixAutoUpdate = true;
      Object3D.prototype.isObject3D = true;
      const _v0$1 = /* @__PURE__ */ new Vector3();
      const _v1$3 = /* @__PURE__ */ new Vector3();
      const _v2$2 = /* @__PURE__ */ new Vector3();
      const _v3$1 = /* @__PURE__ */ new Vector3();
      const _vab = /* @__PURE__ */ new Vector3();
      const _vac = /* @__PURE__ */ new Vector3();
      const _vbc = /* @__PURE__ */ new Vector3();
      const _vap = /* @__PURE__ */ new Vector3();
      const _vbp = /* @__PURE__ */ new Vector3();
      const _vcp = /* @__PURE__ */ new Vector3();
      class Triangle {
        constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
          this.a = a;
          this.b = b;
          this.c = c;
        }
        static getNormal(a, b, c, target) {
          target.subVectors(c, b);
          _v0$1.subVectors(a, b);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
          _v0$1.subVectors(c, a);
          _v1$3.subVectors(b, a);
          _v2$2.subVectors(point, a);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
          this.getBarycoord(point, a, b, c, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$1);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$1.x);
          target.addScaledVector(uv2, _v3$1.y);
          target.addScaledVector(uv3, _v3$1.z);
          return target;
        }
        static isFrontFacing(a, b, c, direction) {
          _v0$1.subVectors(c, b);
          _v1$3.subVectors(a, b);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p, target) {
          const a = this.a, b = this.b, c = this.c;
          let v, w;
          _vab.subVectors(b, a);
          _vac.subVectors(c, a);
          _vap.subVectors(p, a);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
          }
          _vbp.subVectors(p, b);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
          }
          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab, v);
          }
          _vcp.subVectors(p, c);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac, w);
          }
          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc, w);
          }
          const denom = 1 / (va + vb + vc);
          v = vb * denom;
          w = vc * denom;
          return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      }
      let materialId = 0;
      class Material extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: materialId++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.fog = true;
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaTest = 0;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
        }
        onBuild() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            if (key === "shading") {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
              this.flatShading = newValue === FlatShading ? true : false;
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRoot = meta === void 0 || typeof meta === "string";
          if (isRoot) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen && this.sheen.isColor)
            data.sheen = this.sheen.getHex();
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.morphTargets === true)
            data.morphTargets = true;
          if (this.morphNormals === true)
            data.morphNormals = true;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (JSON.stringify(this.userData) !== "{}")
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.fog = source.fog;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (let i = 0; i !== n; ++i) {
              dstPlanes[i] = srcPlanes[i].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      }
      Material.prototype.isMaterial = true;
      const _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      const _hslA = {
        h: 0,
        s: 0,
        l: 0
      };
      const _hslB = {
        h: 0,
        s: 0,
        l: 0
      };
      function hue2rgb(p, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p + (q - p) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p + (q - p) * 6 * (2 / 3 - t);
        return p;
      }
      function SRGBToLinear(c) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
      }
      function LinearToSRGB(c) {
        return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
      }
      class Color {
        constructor(r, g, b) {
          if (g === void 0 && b === void 0) {
            return this.set(r);
          }
          return this.setRGB(r, g, b);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          return this;
        }
        setRGB(r, g, b) {
          this.r = r;
          this.g = g;
          this.b = b;
          return this;
        }
        setHSL(h, s2, l) {
          h = euclideanModulo(h, 1);
          s2 = clamp(s2, 0, 1);
          l = clamp(l, 0, 1);
          if (s2 === 0) {
            this.r = this.g = this.b = l;
          } else {
            const p = l <= 0.5 ? l * (1 + s2) : l + s2 - l * s2;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
          }
          return this;
        }
        setStyle(style) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m;
          if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m[1];
            const components = m[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h = parseFloat(color[1]) / 360;
                  const s2 = parseInt(color[2], 10) / 100;
                  const l = parseInt(color[3], 10) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h, s2, l);
                }
                break;
            }
          } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style);
          }
          return this;
        }
        setColorName(style) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copyGammaToLinear(color, gammaFactor = 2) {
          this.r = Math.pow(color.r, gammaFactor);
          this.g = Math.pow(color.g, gammaFactor);
          this.b = Math.pow(color.b, gammaFactor);
          return this;
        }
        copyLinearToGamma(color, gammaFactor = 2) {
          const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
          this.r = Math.pow(color.r, safeInverse);
          this.g = Math.pow(color.g, safeInverse);
          this.b = Math.pow(color.b, safeInverse);
          return this;
        }
        convertGammaToLinear(gammaFactor) {
          this.copyGammaToLinear(this, gammaFactor);
          return this;
        }
        convertLinearToGamma(gammaFactor) {
          this.copyLinearToGamma(this, gammaFactor);
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex() {
          return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
          const r = this.r, g = this.g, b = this.b;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                hue = (b - r) / delta + 2;
                break;
              case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getStyle() {
          return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        }
        offsetHSL(h, s2, l) {
          this.getHSL(_hslA);
          _hslA.h += h;
          _hslA.s += s2;
          _hslA.l += l;
          this.setHSL(_hslA.h, _hslA.s, _hslA.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s2) {
          this.r += s2;
          this.g += s2;
          this.b += s2;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s2) {
          this.r *= s2;
          this.g *= s2;
          this.b *= s2;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h = lerp(_hslA.h, _hslB.h, alpha);
          const s2 = lerp(_hslA.s, _hslB.s, alpha);
          const l = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h, s2, l);
          return this;
        }
        equals(c) {
          return c.r === this.r && c.g === this.g && c.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index2) {
          this.r = attribute.getX(index2);
          this.g = attribute.getY(index2);
          this.b = attribute.getZ(index2);
          if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
          }
          return this;
        }
        toJSON() {
          return this.getHex();
        }
      }
      Color.NAMES = _colorKeywords;
      Color.prototype.isColor = true;
      Color.prototype.r = 1;
      Color.prototype.g = 1;
      Color.prototype.b = 1;
      class MeshBasicMaterial2 extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.morphTargets = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.morphTargets = source.morphTargets;
          return this;
        }
      }
      MeshBasicMaterial2.prototype.isMeshBasicMaterial = true;
      const _vector$9 = /* @__PURE__ */ new Vector3();
      const _vector2$1 = /* @__PURE__ */ new Vector22();
      class BufferAttribute {
        constructor(array, itemSize, normalized) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized === true;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i = 0, l = this.itemSize; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        copyColorsArray(colors) {
          const array = this.array;
          let offset = 0;
          for (let i = 0, l = colors.length; i < l; i++) {
            let color = colors[i];
            if (color === void 0) {
              console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
              color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
          }
          return this;
        }
        copyVector2sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i = 0, l = vectors.length; i < l; i++) {
            let vector = vectors[i];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
              vector = new Vector22();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
          }
          return this;
        }
        copyVector3sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i = 0, l = vectors.length; i < l; i++) {
            let vector = vectors[i];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
              vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
          }
          return this;
        }
        copyVector4sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i = 0, l = vectors.length; i < l; i++) {
            let vector = vectors[i];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
              vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
          }
          return this;
        }
        applyMatrix3(m) {
          if (this.itemSize === 2) {
            for (let i = 0, l = this.count; i < l; i++) {
              _vector2$1.fromBufferAttribute(this, i);
              _vector2$1.applyMatrix3(m);
              this.setXY(i, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i = 0, l = this.count; i < l; i++) {
              _vector$9.fromBufferAttribute(this, i);
              _vector$9.applyMatrix3(m);
              this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            }
          }
          return this;
        }
        applyMatrix4(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.x = this.getX(i);
            _vector$9.y = this.getY(i);
            _vector$9.z = this.getZ(i);
            _vector$9.applyMatrix4(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.x = this.getX(i);
            _vector$9.y = this.getY(i);
            _vector$9.z = this.getZ(i);
            _vector$9.applyNormalMatrix(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.x = this.getX(i);
            _vector$9.y = this.getY(i);
            _vector$9.z = this.getZ(i);
            _vector$9.transformDirection(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index2) {
          return this.array[index2 * this.itemSize];
        }
        setX(index2, x) {
          this.array[index2 * this.itemSize] = x;
          return this;
        }
        getY(index2) {
          return this.array[index2 * this.itemSize + 1];
        }
        setY(index2, y) {
          this.array[index2 * this.itemSize + 1] = y;
          return this;
        }
        getZ(index2) {
          return this.array[index2 * this.itemSize + 2];
        }
        setZ(index2, z2) {
          this.array[index2 * this.itemSize + 2] = z2;
          return this;
        }
        getW(index2) {
          return this.array[index2 * this.itemSize + 3];
        }
        setW(index2, w) {
          this.array[index2 * this.itemSize + 3] = w;
          return this;
        }
        setXY(index2, x, y) {
          index2 *= this.itemSize;
          this.array[index2 + 0] = x;
          this.array[index2 + 1] = y;
          return this;
        }
        setXYZ(index2, x, y, z2) {
          index2 *= this.itemSize;
          this.array[index2 + 0] = x;
          this.array[index2 + 1] = y;
          this.array[index2 + 2] = z2;
          return this;
        }
        setXYZW(index2, x, y, z2, w) {
          index2 *= this.itemSize;
          this.array[index2 + 0] = x;
          this.array[index2 + 1] = y;
          this.array[index2 + 2] = z2;
          this.array[index2 + 3] = w;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      }
      BufferAttribute.prototype.isBufferAttribute = true;
      class Int8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int8Array(array), itemSize, normalized);
        }
      }
      class Uint8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8Array(array), itemSize, normalized);
        }
      }
      class Uint8ClampedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8ClampedArray(array), itemSize, normalized);
        }
      }
      class Int16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int16Array(array), itemSize, normalized);
        }
      }
      class Uint16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      }
      class Int32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int32Array(array), itemSize, normalized);
        }
      }
      class Uint32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      }
      class Float16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      }
      Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
      class Float32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      }
      class Float64BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float64Array(array), itemSize, normalized);
        }
      }
      function arrayMax(array) {
        if (array.length === 0)
          return -Infinity;
        let max = array[0];
        for (let i = 1, l = array.length; i < l; ++i) {
          if (array[i] > max)
            max = array[i];
        }
        return max;
      }
      const TYPED_ARRAYS = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      };
      function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
      }
      let _id = 0;
      const _m1 = /* @__PURE__ */ new Matrix4();
      const _obj = /* @__PURE__ */ new Object3D();
      const _offset = /* @__PURE__ */ new Vector3();
      const _box$1 = /* @__PURE__ */ new Box3();
      const _boxMorphTargets = /* @__PURE__ */ new Box3();
      const _vector$8 = /* @__PURE__ */ new Vector3();
      class BufferGeometry extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _id++
          });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = {
            start: 0,
            count: Infinity
          };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index2) {
          if (Array.isArray(index2)) {
            this.index = new (arrayMax(index2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
          } else {
            this.index = index2;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q) {
          _m1.makeRotationFromQuaternion(q);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle) {
          _m1.makeRotationX(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle) {
          _m1.makeRotationY(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle) {
          _m1.makeRotationZ(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x, y, z2) {
          _m1.makeTranslation(x, y, z2);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x, y, z2) {
          _m1.makeScale(x, y, z2);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i = 0, l = points.length; i < l; i++) {
            const point = points[i];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$8);
                  _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$8);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$8);
                  _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$8);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i = 0, il = position.count; i < il; i++) {
              _vector$8.fromBufferAttribute(position, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                  _vector$8.fromBufferAttribute(morphAttribute, j);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position, j);
                    _vector$8.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeFaceNormals() {
        }
        computeTangents() {
          const index2 = this.index;
          const attributes = this.attributes;
          if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index2.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (attributes.tangent === void 0) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = attributes.tangent.array;
          const tan1 = [], tan2 = [];
          for (let i = 0; i < nVertices; i++) {
            tan1[i] = new Vector3();
            tan2[i] = new Vector3();
          }
          const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector22(), uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector3(), tdir = new Vector3();
          function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i = 0, il = groups.length; i < il; ++i) {
            const group = groups[i];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
            }
          }
          const tmp2 = new Vector3(), tmp22 = new Vector3();
          const n = new Vector3(), n2 = new Vector3();
          function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            tmp2.copy(t);
            tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp22.crossVectors(n2, t);
            const test = tmp22.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp2.x;
            tangents[v * 4 + 1] = tmp2.y;
            tangents[v * 4 + 2] = tmp2.z;
            tangents[v * 4 + 3] = w;
          }
          for (let i = 0, il = groups.length; i < il; ++i) {
            const group = groups[i];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleVertex(indices[j + 0]);
              handleVertex(indices[j + 1]);
              handleVertex(indices[j + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index2 = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i = 0, il = normalAttribute.count; i < il; i++) {
                normalAttribute.setXYZ(i, 0, 0, 0);
              }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            if (index2) {
              for (let i = 0, il = index2.count; i < il; i += 3) {
                const vA = index2.getX(i + 0);
                const vB = index2.getX(i + 1);
                const vC = index2.getX(i + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
                pA.fromBufferAttribute(positionAttribute, i + 0);
                pB.fromBufferAttribute(positionAttribute, i + 1);
                pC.fromBufferAttribute(positionAttribute, i + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge(geometry, offset) {
          if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
          }
          if (offset === void 0) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            if (geometry.attributes[key] === void 0)
              continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for (let i = 0, j = attributeOffset; i < length; i++, j++) {
              attributeArray1[j] = attributeArray2[i];
            }
          }
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i = 0, il = normals.count; i < il; i++) {
            _vector$8.fromBufferAttribute(normals, i);
            _vector$8.normalize();
            normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index2 = 0, index22 = 0;
            for (let i = 0, l = indices2.length; i < l; i++) {
              if (attribute.isInterleavedBufferAttribute) {
                index2 = indices2[i] * attribute.data.stride + attribute.offset;
              } else {
                index2 = indices2[i] * itemSize;
              }
              for (let j = 0; j < itemSize; j++) {
                array2[index22++] = array[index2++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i = 0, il = morphAttribute.length; i < il; i++) {
              const attribute = morphAttribute[i];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i = 0, l = groups.length; i < l; i++) {
            const group = groups[i];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = {
            attributes: {}
          };
          const index2 = this.index;
          if (index2 !== null) {
            data.data.index = {
              type: index2.array.constructor.name,
              array: Array.prototype.slice.call(index2.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i = 0, il = attributeArray.length; i < il; i++) {
              const attribute = attributeArray[i];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new BufferGeometry().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index2 = source.index;
          if (index2 !== null) {
            this.setIndex(index2.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i = 0, l = morphAttribute.length; i < l; i++) {
              array.push(morphAttribute[i].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i = 0, l = groups.length; i < l; i++) {
            const group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      BufferGeometry.prototype.isBufferGeometry = true;
      const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      const _ray$2 = /* @__PURE__ */ new Ray();
      const _sphere$3 = /* @__PURE__ */ new Sphere();
      const _vA$1 = /* @__PURE__ */ new Vector3();
      const _vB$1 = /* @__PURE__ */ new Vector3();
      const _vC$1 = /* @__PURE__ */ new Vector3();
      const _tempA = /* @__PURE__ */ new Vector3();
      const _tempB = /* @__PURE__ */ new Vector3();
      const _tempC = /* @__PURE__ */ new Vector3();
      const _morphA = /* @__PURE__ */ new Vector3();
      const _morphB = /* @__PURE__ */ new Vector3();
      const _morphC = /* @__PURE__ */ new Vector3();
      const _uvA$1 = /* @__PURE__ */ new Vector22();
      const _uvB$1 = /* @__PURE__ */ new Vector22();
      const _uvC$1 = /* @__PURE__ */ new Vector22();
      const _intersectionPoint = /* @__PURE__ */ new Vector3();
      const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
      class Mesh2 extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial2()) {
          super();
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$3.copy(geometry.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (geometry.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          let intersection;
          if (geometry.isBufferGeometry) {
            const index2 = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index2 !== null) {
              if (Array.isArray(material)) {
                for (let i = 0, il = groups.length; i < il; i++) {
                  const group = groups[i];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = index2.getX(j);
                    const b = index2.getX(j + 1);
                    const c = index2.getX(j + 2);
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index2.count, drawRange.start + drawRange.count);
                for (let i = start, il = end; i < il; i += 3) {
                  const a = index2.getX(i);
                  const b = index2.getX(i + 1);
                  const c = index2.getX(i + 2);
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            } else if (position !== void 0) {
              if (Array.isArray(material)) {
                for (let i = 0, il = groups.length; i < il; i++) {
                  const group = groups[i];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = j;
                    const b = j + 1;
                    const c = j + 2;
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position.count, drawRange.start + drawRange.count);
                for (let i = start, il = end; i < il; i += 3) {
                  const a = i;
                  const b = i + 1;
                  const c = i + 2;
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      Mesh2.prototype.isMesh = true;
      function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
        let intersect;
        if (material.side === BackSide) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide2, point);
        }
        if (intersect === null)
          return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance,
          point: _intersectionPointWorld.clone(),
          object
        };
      }
      function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
        _vA$1.fromBufferAttribute(position, a);
        _vB$1.fromBufferAttribute(position, b);
        _vC$1.fromBufferAttribute(position, c);
        const morphInfluences = object.morphTargetInfluences;
        if (material.morphTargets && morphPosition && morphInfluences) {
          _morphA.set(0, 0, 0);
          _morphB.set(0, 0, 0);
          _morphC.set(0, 0, 0);
          for (let i = 0, il = morphPosition.length; i < il; i++) {
            const influence = morphInfluences[i];
            const morphAttribute = morphPosition[i];
            if (influence === 0)
              continue;
            _tempA.fromBufferAttribute(morphAttribute, a);
            _tempB.fromBufferAttribute(morphAttribute, b);
            _tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
              _morphA.addScaledVector(_tempA, influence);
              _morphB.addScaledVector(_tempB, influence);
              _morphC.addScaledVector(_tempC, influence);
            } else {
              _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
              _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
              _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
            }
          }
          _vA$1.add(_morphA);
          _vB$1.add(_morphB);
          _vC$1.add(_morphC);
        }
        if (object.isSkinnedMesh) {
          object.boneTransform(a, _vA$1);
          object.boneTransform(b, _vB$1);
          object.boneTransform(c, _vC$1);
        }
        const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
        if (intersection) {
          if (uv) {
            _uvA$1.fromBufferAttribute(uv, a);
            _uvB$1.fromBufferAttribute(uv, b);
            _uvC$1.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
          }
          if (uv2) {
            _uvA$1.fromBufferAttribute(uv2, a);
            _uvB$1.fromBufferAttribute(uv2, b);
            _uvC$1.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
          }
          const face = {
            a,
            b,
            c,
            normal: new Vector3(),
            materialIndex: 0
          };
          Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      class BoxGeometry extends BufferGeometry {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for (let iy = 0; iy < gridY1; iy++) {
              const y = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a = numberOfVertices + ix + gridX1 * iy;
                const b = numberOfVertices + ix + gridX1 * (iy + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d2);
                indices.push(b, c, d2);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      }
      function cloneUniforms(src2) {
        const dst = {};
        for (const u in src2) {
          dst[u] = {};
          for (const p in src2[u]) {
            const property = src2[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
              dst[u][p] = property.clone();
            } else if (Array.isArray(property)) {
              dst[u][p] = property.slice();
            } else {
              dst[u][p] = property;
            }
          }
        }
        return dst;
      }
      function mergeUniforms(uniforms) {
        const merged = {};
        for (let u = 0; u < uniforms.length; u++) {
          const tmp2 = cloneUniforms(uniforms[u]);
          for (const p in tmp2) {
            merged[p] = tmp2[p];
          }
        }
        return merged;
      }
      const UniformsUtils = {
        clone: cloneUniforms,
        merge: mergeUniforms
      };
      var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      class ShaderMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.morphTargets = false;
          this.morphNormals = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            if (parameters.attributes !== void 0) {
              console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            }
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      }
      ShaderMaterial.prototype.isShaderMaterial = true;
      class Camera extends Object3D {
        constructor() {
          super();
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Camera.prototype.isCamera = true;
      class PerspectiveCamera2 extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      }
      PerspectiveCamera2.prototype.isPerspectiveCamera = true;
      const fov = 90, aspect = 1;
      class CubeCamera extends Object3D {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
          }
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(new Vector3(1, 0, 0));
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(new Vector3(-1, 0, 0));
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(new Vector3(0, 1, 0));
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(new Vector3(0, -1, 0));
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera2(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(new Vector3(0, 0, 1));
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera2(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(new Vector3(0, 0, -1));
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.xr.enabled = currentXrEnabled;
        }
      }
      class CubeTexture extends Texture2 {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          format2 = format2 !== void 0 ? format2 : RGBFormat;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this._needsFlipEnvMap = true;
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      }
      CubeTexture.prototype.isCubeTexture = true;
      class WebGLCubeRenderTarget extends WebGLRenderTarget {
        constructor(size, options2, dummy) {
          if (Number.isInteger(options2)) {
            console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
            options2 = dummy;
          }
          super(size, size, options2);
          options2 = options2 || {};
          this.texture = new CubeTexture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
          this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
          this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
          this.texture._needsFlipEnvMap = false;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.format = RGBAFormat;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry = new BoxGeometry(5, 5, 5);
          const material = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh2(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i = 0; i < 6; i++) {
            renderer.setRenderTarget(this, i);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      }
      WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
      const _vector1 = /* @__PURE__ */ new Vector3();
      const _vector2 = /* @__PURE__ */ new Vector3();
      const _normalMatrix = /* @__PURE__ */ new Matrix3();
      class Plane {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x, y, z2, w) {
          this.normal.set(x, y, z2);
          this.constant = w;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a, b, c) {
          const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Plane.prototype.isPlane = true;
      const _sphere$2 = /* @__PURE__ */ new Sphere();
      const _vector$7 = /* @__PURE__ */ new Vector3();
      class Frustum {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
          this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            planes[i].copy(frustum.planes[i]);
          }
          return this;
        }
        setFromProjectionMatrix(m) {
          const planes = this.planes;
          const me = m.elements;
          const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
          const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
          const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
          const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSprite(sprite) {
          _sphere$2.center.set(0, 0, 0);
          _sphere$2.radius = 0.7071067811865476;
          _sphere$2.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i = 0; i < 6; i++) {
            const distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            const plane = planes[i];
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function WebGLAnimation() {
        let context = null;
        let isAnimating = false;
        let animationLoop = null;
        let requestId = null;
        function onAnimationFrame(time, frame) {
          animationLoop(time, frame);
          requestId = context.requestAnimationFrame(onAnimationFrame);
        }
        return {
          start: function() {
            if (isAnimating === true)
              return;
            if (animationLoop === null)
              return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
          },
          stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
          },
          setAnimationLoop: function(callback) {
            animationLoop = callback;
          },
          setContext: function(value) {
            context = value;
          }
        };
      }
      function WebGLAttributes(gl, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        const buffers = new WeakMap();
        function createBuffer(attribute, bufferType) {
          const array = attribute.array;
          const usage = attribute.usage;
          const buffer = gl.createBuffer();
          gl.bindBuffer(bufferType, buffer);
          gl.bufferData(bufferType, array, usage);
          attribute.onUploadCallback();
          let type = gl.FLOAT;
          if (array instanceof Float32Array) {
            type = gl.FLOAT;
          } else if (array instanceof Float64Array) {
            console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
          } else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
              if (isWebGL2) {
                type = gl.HALF_FLOAT;
              } else {
                console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
              }
            } else {
              type = gl.UNSIGNED_SHORT;
            }
          } else if (array instanceof Int16Array) {
            type = gl.SHORT;
          } else if (array instanceof Uint32Array) {
            type = gl.UNSIGNED_INT;
          } else if (array instanceof Int32Array) {
            type = gl.INT;
          } else if (array instanceof Int8Array) {
            type = gl.BYTE;
          } else if (array instanceof Uint8Array) {
            type = gl.UNSIGNED_BYTE;
          } else if (array instanceof Uint8ClampedArray) {
            type = gl.UNSIGNED_BYTE;
          }
          return {
            buffer,
            type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
          };
        }
        function updateBuffer(buffer, attribute, bufferType) {
          const array = attribute.array;
          const updateRange = attribute.updateRange;
          gl.bindBuffer(bufferType, buffer);
          if (updateRange.count === -1) {
            gl.bufferSubData(bufferType, 0, array);
          } else {
            if (isWebGL2) {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            } else {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }
            updateRange.count = -1;
          }
        }
        function get(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          return buffers.get(attribute);
        }
        function remove(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
          }
        }
        function update(attribute, bufferType) {
          if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) {
              buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
              });
            }
            return;
          }
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data === void 0) {
            buffers.set(attribute, createBuffer(attribute, bufferType));
          } else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
          }
        }
        return {
          get,
          remove,
          update
        };
      }
      class PlaneGeometry2 extends BufferGeometry {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segment_width - width_half;
              vertices.push(x, -y, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = ix + 1 + gridX1 * (iy + 1);
              const d2 = ix + 1 + gridX1 * iy;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry2(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      }
      var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
      var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
      var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      var begin_vertex = "vec3 transformed = vec3( position );";
      var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
      var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
      var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
      var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
      var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
      var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
      var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
      var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
      var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
      var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
      var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
      var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
      var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
      var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
      var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
      var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
      var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
      var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
      var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
      var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSNMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";
      var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif";
      var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform vec3 attenuationColor;\n	uniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}";
      var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
      var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      const ShaderChunk = {
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        encodings_fragment,
        encodings_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_vertex,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        uv2_pars_fragment,
        uv2_pars_vertex,
        uv2_vertex,
        worldpos_vertex,
        background_frag,
        background_vert,
        cube_frag,
        cube_vert,
        depth_frag,
        depth_vert,
        distanceRGBA_frag,
        distanceRGBA_vert,
        equirect_frag,
        equirect_vert,
        linedashed_frag,
        linedashed_vert,
        meshbasic_frag,
        meshbasic_vert,
        meshlambert_frag,
        meshlambert_vert,
        meshmatcap_frag,
        meshmatcap_vert,
        meshtoon_frag,
        meshtoon_vert,
        meshphong_frag,
        meshphong_vert,
        meshphysical_frag,
        meshphysical_vert,
        normal_frag,
        normal_vert,
        points_frag,
        points_vert,
        shadow_frag,
        shadow_vert,
        sprite_frag,
        sprite_vert
      };
      const UniformsLib = {
        common: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          uvTransform: {
            value: new Matrix3()
          },
          uv2Transform: {
            value: new Matrix3()
          },
          alphaMap: {
            value: null
          }
        },
        specularmap: {
          specularMap: {
            value: null
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          refractionRatio: {
            value: 0.98
          },
          maxMipLevel: {
            value: 0
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalScale: {
            value: new Vector22(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new Color(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotShadowMap: {
            value: []
          },
          spotShadowMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          uvTransform: {
            value: new Matrix3()
          }
        },
        sprite: {
          diffuse: {
            value: new Color(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Vector22(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          uvTransform: {
            value: new Matrix3()
          }
        }
      };
      const ShaderLib = {
        basic: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            specular: {
              value: new Color(1118481)
            },
            shininess: {
              value: 30
            }
          }]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
              value: new Color(0)
            }
          }]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
              value: null
            }
          }]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.normal_vert,
          fragmentShader: ShaderChunk.normal_frag
        },
        sprite: {
          uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Matrix3()
            },
            t2D: {
              value: null
            }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        cube: {
          uniforms: mergeUniforms([UniformsLib.envmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
              value: new Vector3()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1e3
            }
          }]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
              value: new Color(0)
            },
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new Vector22(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          sheen: {
            value: new Color(0)
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new Vector22()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Color(0)
          }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      function WebGLBackground(renderer, cubemaps, state2, objects, premultipliedAlpha) {
        const clearColor = new Color(0);
        let clearAlpha = 0;
        let planeMesh;
        let boxMesh;
        let currentBackground = null;
        let currentBackgroundVersion = 0;
        let currentTonemapping = null;
        function render2(renderList, scene) {
          let forceClear = false;
          let background = scene.isScene === true ? scene.background : null;
          if (background && background.isTexture) {
            background = cubemaps.get(background);
          }
          const xr = renderer.xr;
          const session = xr.getSession && xr.getSession();
          if (session && session.environmentBlendMode === "additive") {
            background = null;
          }
          if (background === null) {
            setClear(clearColor, clearAlpha);
          } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
          }
          if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          }
          if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === void 0) {
              boxMesh = new Mesh2(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              boxMesh.geometry.deleteAttribute("normal");
              boxMesh.geometry.deleteAttribute("uv");
              boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
              };
              Object.defineProperty(boxMesh.material, "envMap", {
                get: function() {
                  return this.uniforms.envMap.value;
                }
              });
              objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              boxMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
          } else if (background && background.isTexture) {
            if (planeMesh === void 0) {
              planeMesh = new Mesh2(new PlaneGeometry2(2, 2), new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              planeMesh.geometry.deleteAttribute("normal");
              Object.defineProperty(planeMesh.material, "map", {
                get: function() {
                  return this.uniforms.t2D.value;
                }
              });
              objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) {
              background.updateMatrix();
            }
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              planeMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
          }
        }
        function setClear(color, alpha) {
          state2.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
          getClearColor: function() {
            return clearColor;
          },
          setClearColor: function(color, alpha = 1) {
            clearColor.set(color);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
          },
          getClearAlpha: function() {
            return clearAlpha;
          },
          setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
          },
          render: render2
        };
      }
      function WebGLBindingStates(gl, extensions, attributes, capabilities) {
        const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
        const vaoAvailable = capabilities.isWebGL2 || extension !== null;
        const bindingStates = {};
        const defaultState = createBindingState(null);
        let currentState = defaultState;
        function setup(object, material, program, geometry, index2) {
          let updateBuffers = false;
          if (vaoAvailable) {
            const state2 = getBindingState(geometry, program, material);
            if (currentState !== state2) {
              currentState = state2;
              bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index2);
            if (updateBuffers)
              saveCache(geometry, index2);
          } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
              currentState.geometry = geometry.id;
              currentState.program = program.id;
              currentState.wireframe = wireframe;
              updateBuffers = true;
            }
          }
          if (object.isInstancedMesh === true) {
            updateBuffers = true;
          }
          if (index2 !== null) {
            attributes.update(index2, gl.ELEMENT_ARRAY_BUFFER);
          }
          if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index2 !== null) {
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index2).buffer);
            }
          }
        }
        function createVertexArrayObject() {
          if (capabilities.isWebGL2)
            return gl.createVertexArray();
          return extension.createVertexArrayOES();
        }
        function bindVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.bindVertexArray(vao);
          return extension.bindVertexArrayOES(vao);
        }
        function deleteVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.deleteVertexArray(vao);
          return extension.deleteVertexArrayOES(vao);
        }
        function getBindingState(geometry, program, material) {
          const wireframe = material.wireframe === true;
          let programMap = bindingStates[geometry.id];
          if (programMap === void 0) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
          }
          let stateMap = programMap[program.id];
          if (stateMap === void 0) {
            stateMap = {};
            programMap[program.id] = stateMap;
          }
          let state2 = stateMap[wireframe];
          if (state2 === void 0) {
            state2 = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state2;
          }
          return state2;
        }
        function createBindingState(vao) {
          const newAttributes = [];
          const enabledAttributes = [];
          const attributeDivisors = [];
          for (let i = 0; i < maxVertexAttributes; i++) {
            newAttributes[i] = 0;
            enabledAttributes[i] = 0;
            attributeDivisors[i] = 0;
          }
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes,
            enabledAttributes,
            attributeDivisors,
            object: vao,
            attributes: {},
            index: null
          };
        }
        function needsUpdate(geometry, index2) {
          const cachedAttributes = currentState.attributes;
          const geometryAttributes = geometry.attributes;
          let attributesNum = 0;
          for (const key in geometryAttributes) {
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === void 0)
              return true;
            if (cachedAttribute.attribute !== geometryAttribute)
              return true;
            if (cachedAttribute.data !== geometryAttribute.data)
              return true;
            attributesNum++;
          }
          if (currentState.attributesNum !== attributesNum)
            return true;
          if (currentState.index !== index2)
            return true;
          return false;
        }
        function saveCache(geometry, index2) {
          const cache = {};
          const attributes2 = geometry.attributes;
          let attributesNum = 0;
          for (const key in attributes2) {
            const attribute = attributes2[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) {
              data.data = attribute.data;
            }
            cache[key] = data;
            attributesNum++;
          }
          currentState.attributes = cache;
          currentState.attributesNum = attributesNum;
          currentState.index = index2;
        }
        function initAttributes() {
          const newAttributes = currentState.newAttributes;
          for (let i = 0, il = newAttributes.length; i < il; i++) {
            newAttributes[i] = 0;
          }
        }
        function enableAttribute(attribute) {
          enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          const attributeDivisors = currentState.attributeDivisors;
          newAttributes[attribute] = 1;
          if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
          }
          if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
          }
        }
        function disableUnusedAttributes() {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          for (let i = 0, il = enabledAttributes.length; i < il; i++) {
            if (enabledAttributes[i] !== newAttributes[i]) {
              gl.disableVertexAttribArray(i);
              enabledAttributes[i] = 0;
            }
          }
        }
        function vertexAttribPointer(index2, size, type, normalized, stride, offset) {
          if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
            gl.vertexAttribIPointer(index2, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(index2, size, type, normalized, stride, offset);
          }
        }
        function setupVertexAttributes(object, material, program, geometry) {
          if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null)
              return;
          }
          initAttributes();
          const geometryAttributes = geometry.attributes;
          const programAttributes = program.getAttributes();
          const materialDefaultAttributeValues = material.defaultAttributeValues;
          for (const name in programAttributes) {
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
              const geometryAttribute = geometryAttributes[name];
              if (geometryAttribute !== void 0) {
                const normalized = geometryAttribute.normalized;
                const size = geometryAttribute.itemSize;
                const attribute = attributes.get(geometryAttribute);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                const bytesPerElement = attribute.bytesPerElement;
                if (geometryAttribute.isInterleavedBufferAttribute) {
                  const data = geometryAttribute.data;
                  const stride = data.stride;
                  const offset = geometryAttribute.offset;
                  if (data && data.isInstancedInterleavedBuffer) {
                    enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                    if (geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                    }
                  } else {
                    enableAttribute(programAttribute);
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                } else {
                  if (geometryAttribute.isInstancedBufferAttribute) {
                    enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                    if (geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                    }
                  } else {
                    enableAttribute(programAttribute);
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                }
              } else if (name === "instanceMatrix") {
                const attribute = attributes.get(object.instanceMatrix);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                enableAttributeAndDivisor(programAttribute + 0, 1);
                enableAttributeAndDivisor(programAttribute + 1, 1);
                enableAttributeAndDivisor(programAttribute + 2, 1);
                enableAttributeAndDivisor(programAttribute + 3, 1);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
              } else if (name === "instanceColor") {
                const attribute = attributes.get(object.instanceColor);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                enableAttributeAndDivisor(programAttribute, 1);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
              } else if (materialDefaultAttributeValues !== void 0) {
                const value = materialDefaultAttributeValues[name];
                if (value !== void 0) {
                  switch (value.length) {
                    case 2:
                      gl.vertexAttrib2fv(programAttribute, value);
                      break;
                    case 3:
                      gl.vertexAttrib3fv(programAttribute, value);
                      break;
                    case 4:
                      gl.vertexAttrib4fv(programAttribute, value);
                      break;
                    default:
                      gl.vertexAttrib1fv(programAttribute, value);
                  }
                }
              }
            }
          }
          disableUnusedAttributes();
        }
        function dispose() {
          reset();
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            for (const programId in programMap) {
              const stateMap = programMap[programId];
              for (const wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[programId];
            }
            delete bindingStates[geometryId];
          }
        }
        function releaseStatesOfGeometry(geometry) {
          if (bindingStates[geometry.id] === void 0)
            return;
          const programMap = bindingStates[geometry.id];
          for (const programId in programMap) {
            const stateMap = programMap[programId];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometry.id];
        }
        function releaseStatesOfProgram(program) {
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === void 0)
              continue;
            const stateMap = programMap[program.id];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[program.id];
          }
        }
        function reset() {
          resetDefaultState();
          if (currentState === defaultState)
            return;
          currentState = defaultState;
          bindVertexArrayObject(currentState.object);
        }
        function resetDefaultState() {
          defaultState.geometry = null;
          defaultState.program = null;
          defaultState.wireframe = false;
        }
        return {
          setup,
          reset,
          resetDefaultState,
          dispose,
          releaseStatesOfGeometry,
          releaseStatesOfProgram,
          initAttributes,
          enableAttribute,
          disableUnusedAttributes
        };
      }
      function WebGLBufferRenderer(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        function render2(start, count) {
          gl.drawArrays(mode, start, count);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawArraysInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, start, count, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.render = render2;
        this.renderInstances = renderInstances;
      }
      function WebGLCapabilities(gl, extensions, parameters) {
        let maxAnisotropy;
        function getMaxAnisotropy() {
          if (maxAnisotropy !== void 0)
            return maxAnisotropy;
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            maxAnisotropy = 0;
          }
          return maxAnisotropy;
        }
        function getMaxPrecision(precision2) {
          if (precision2 === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
              return "highp";
            }
            precision2 = "mediump";
          }
          if (precision2 === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
              return "mediump";
            }
          }
          return "lowp";
        }
        const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
        let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
        const maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
          console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
          precision = maxPrecision;
        }
        const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
        const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        const vertexTextures = maxVertexTextures > 0;
        const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
        const floatVertexTextures = vertexTextures && floatFragmentTextures;
        const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
        return {
          isWebGL2,
          drawBuffers,
          getMaxAnisotropy,
          getMaxPrecision,
          precision,
          logarithmicDepthBuffer,
          maxTextures,
          maxVertexTextures,
          maxTextureSize,
          maxCubemapSize,
          maxAttributes,
          maxVertexUniforms,
          maxVaryings,
          maxFragmentUniforms,
          vertexTextures,
          floatFragmentTextures,
          floatVertexTextures,
          maxSamples
        };
      }
      function WebGLClipping(properties) {
        const scope = this;
        let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
        const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
          value: null,
          needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
          const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
          localClippingEnabled = enableLocalClipping;
          globalState = projectPlanes(planes, camera, 0);
          numGlobalPlanes = planes.length;
          return enabled;
        };
        this.beginShadows = function() {
          renderingShadows = true;
          projectPlanes(null);
        };
        this.endShadows = function() {
          renderingShadows = false;
          resetGlobalState();
        };
        this.setState = function(material, camera, useCache) {
          const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
          const materialProperties = properties.get(material);
          if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
              projectPlanes(null);
            } else {
              resetGlobalState();
            }
          } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for (let i = 0; i !== lGlobal; ++i) {
              dstArray[i] = globalState[i];
            }
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
          }
        };
        function resetGlobalState() {
          if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
          }
          scope.numPlanes = numGlobalPlanes;
          scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
          const nPlanes = planes !== null ? planes.length : 0;
          let dstArray = null;
          if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
              const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
              viewNormalMatrix.getNormalMatrix(viewMatrix);
              if (dstArray === null || dstArray.length < flatSize) {
                dstArray = new Float32Array(flatSize);
              }
              for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
              }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
          }
          scope.numPlanes = nPlanes;
          scope.numIntersection = 0;
          return dstArray;
        }
      }
      function WebGLCubeMaps(renderer) {
        let cubemaps = new WeakMap();
        function mapTextureMapping(texture, mapping) {
          if (mapping === EquirectangularReflectionMapping) {
            texture.mapping = CubeReflectionMapping;
          } else if (mapping === EquirectangularRefractionMapping) {
            texture.mapping = CubeRefractionMapping;
          }
          return texture;
        }
        function get(texture) {
          if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
              if (cubemaps.has(texture)) {
                const cubemap = cubemaps.get(texture).texture;
                return mapTextureMapping(cubemap, texture.mapping);
              } else {
                const image = texture.image;
                if (image && image.height > 0) {
                  const currentRenderTarget = renderer.getRenderTarget();
                  const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                  renderTarget.fromEquirectangularTexture(renderer, texture);
                  cubemaps.set(texture, renderTarget);
                  renderer.setRenderTarget(currentRenderTarget);
                  texture.addEventListener("dispose", onTextureDispose);
                  return mapTextureMapping(renderTarget.texture, texture.mapping);
                } else {
                  return null;
                }
              }
            }
          }
          return texture;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemap = cubemaps.get(texture);
          if (cubemap !== void 0) {
            cubemaps.delete(texture);
            cubemap.dispose();
          }
        }
        function dispose() {
          cubemaps = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      function WebGLExtensions(gl) {
        const extensions = {};
        function getExtension(name) {
          if (extensions[name] !== void 0) {
            return extensions[name];
          }
          let extension;
          switch (name) {
            case "WEBGL_depth_texture":
              extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              extension = gl.getExtension(name);
          }
          extensions[name] = extension;
          return extension;
        }
        return {
          has: function(name) {
            return getExtension(name) !== null;
          },
          init: function(capabilities) {
            if (capabilities.isWebGL2) {
              getExtension("EXT_color_buffer_float");
            } else {
              getExtension("WEBGL_depth_texture");
              getExtension("OES_texture_float");
              getExtension("OES_texture_half_float");
              getExtension("OES_texture_half_float_linear");
              getExtension("OES_standard_derivatives");
              getExtension("OES_element_index_uint");
              getExtension("OES_vertex_array_object");
              getExtension("ANGLE_instanced_arrays");
            }
            getExtension("OES_texture_float_linear");
            getExtension("EXT_color_buffer_half_float");
          },
          get: function(name) {
            const extension = getExtension(name);
            if (extension === null) {
              console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            }
            return extension;
          }
        };
      }
      function WebGLGeometries(gl, attributes, info, bindingStates) {
        const geometries = {};
        const wireframeAttributes = new WeakMap();
        function onGeometryDispose(event) {
          const geometry = event.target;
          if (geometry.index !== null) {
            attributes.remove(geometry.index);
          }
          for (const name in geometry.attributes) {
            attributes.remove(geometry.attributes[name]);
          }
          geometry.removeEventListener("dispose", onGeometryDispose);
          delete geometries[geometry.id];
          const attribute = wireframeAttributes.get(geometry);
          if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
          }
          bindingStates.releaseStatesOfGeometry(geometry);
          if (geometry.isInstancedBufferGeometry === true) {
            delete geometry._maxInstanceCount;
          }
          info.memory.geometries--;
        }
        function get(object, geometry) {
          if (geometries[geometry.id] === true)
            return geometry;
          geometry.addEventListener("dispose", onGeometryDispose);
          geometries[geometry.id] = true;
          info.memory.geometries++;
          return geometry;
        }
        function update(geometry) {
          const geometryAttributes = geometry.attributes;
          for (const name in geometryAttributes) {
            attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
          }
          const morphAttributes = geometry.morphAttributes;
          for (const name in morphAttributes) {
            const array = morphAttributes[name];
            for (let i = 0, l = array.length; i < l; i++) {
              attributes.update(array[i], gl.ARRAY_BUFFER);
            }
          }
        }
        function updateWireframeAttribute(geometry) {
          const indices = [];
          const geometryIndex = geometry.index;
          const geometryPosition = geometry.attributes.position;
          let version = 0;
          if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for (let i = 0, l = array.length; i < l; i += 3) {
              const a = array[i + 0];
              const b = array[i + 1];
              const c = array[i + 2];
              indices.push(a, b, b, c, c, a);
            }
          } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
              const a = i + 0;
              const b = i + 1;
              const c = i + 2;
              indices.push(a, b, b, c, c, a);
            }
          }
          const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
          attribute.version = version;
          const previousAttribute = wireframeAttributes.get(geometry);
          if (previousAttribute)
            attributes.remove(previousAttribute);
          wireframeAttributes.set(geometry, attribute);
        }
        function getWireframeAttribute(geometry) {
          const currentAttribute = wireframeAttributes.get(geometry);
          if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) {
              if (currentAttribute.version < geometryIndex.version) {
                updateWireframeAttribute(geometry);
              }
            }
          } else {
            updateWireframeAttribute(geometry);
          }
          return wireframeAttributes.get(geometry);
        }
        return {
          get,
          update,
          getWireframeAttribute
        };
      }
      function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        let type, bytesPerElement;
        function setIndex(value) {
          type = value.type;
          bytesPerElement = value.bytesPerElement;
        }
        function render2(start, count) {
          gl.drawElements(mode, count, type, start * bytesPerElement);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawElementsInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, count, type, start * bytesPerElement, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render2;
        this.renderInstances = renderInstances;
      }
      function WebGLInfo(gl) {
        const memory = {
          geometries: 0,
          textures: 0
        };
        const render2 = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function update(count, mode, instanceCount) {
          render2.calls++;
          switch (mode) {
            case gl.TRIANGLES:
              render2.triangles += instanceCount * (count / 3);
              break;
            case gl.LINES:
              render2.lines += instanceCount * (count / 2);
              break;
            case gl.LINE_STRIP:
              render2.lines += instanceCount * (count - 1);
              break;
            case gl.LINE_LOOP:
              render2.lines += instanceCount * count;
              break;
            case gl.POINTS:
              render2.points += instanceCount * count;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
              break;
          }
        }
        function reset() {
          render2.frame++;
          render2.calls = 0;
          render2.triangles = 0;
          render2.points = 0;
          render2.lines = 0;
        }
        return {
          memory,
          render: render2,
          programs: null,
          autoReset: true,
          reset,
          update
        };
      }
      function numericalSort(a, b) {
        return a[0] - b[0];
      }
      function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
      }
      function WebGLMorphtargets(gl) {
        const influencesList = {};
        const morphInfluences = new Float32Array(8);
        const workInfluences = [];
        for (let i = 0; i < 8; i++) {
          workInfluences[i] = [i, 0];
        }
        function update(object, geometry, material, program) {
          const objectInfluences = object.morphTargetInfluences;
          const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
          let influences = influencesList[geometry.id];
          if (influences === void 0 || influences.length !== length) {
            influences = [];
            for (let i = 0; i < length; i++) {
              influences[i] = [i, 0];
            }
            influencesList[geometry.id] = influences;
          }
          for (let i = 0; i < length; i++) {
            const influence = influences[i];
            influence[0] = i;
            influence[1] = objectInfluences[i];
          }
          influences.sort(absNumericalSort);
          for (let i = 0; i < 8; i++) {
            if (i < length && influences[i][1]) {
              workInfluences[i][0] = influences[i][0];
              workInfluences[i][1] = influences[i][1];
            } else {
              workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
              workInfluences[i][1] = 0;
            }
          }
          workInfluences.sort(numericalSort);
          const morphTargets = material.morphTargets && geometry.morphAttributes.position;
          const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
          let morphInfluencesSum = 0;
          for (let i = 0; i < 8; i++) {
            const influence = workInfluences[i];
            const index2 = influence[0];
            const value = influence[1];
            if (index2 !== Number.MAX_SAFE_INTEGER && value) {
              if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index2]) {
                geometry.setAttribute("morphTarget" + i, morphTargets[index2]);
              }
              if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index2]) {
                geometry.setAttribute("morphNormal" + i, morphNormals[index2]);
              }
              morphInfluences[i] = value;
              morphInfluencesSum += value;
            } else {
              if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
                geometry.deleteAttribute("morphTarget" + i);
              }
              if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
                geometry.deleteAttribute("morphNormal" + i);
              }
              morphInfluences[i] = 0;
            }
          }
          const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
          program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
          program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
        }
        return {
          update
        };
      }
      function WebGLObjects(gl, geometries, attributes, info) {
        let updateMap = new WeakMap();
        function update(object) {
          const frame = info.render.frame;
          const geometry = object.geometry;
          const buffergeometry = geometries.get(object, geometry);
          if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
          }
          if (object.isInstancedMesh) {
            if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
              object.addEventListener("dispose", onInstancedMeshDispose);
            }
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) {
              attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
            }
          }
          return buffergeometry;
        }
        function dispose() {
          updateMap = new WeakMap();
        }
        function onInstancedMeshDispose(event) {
          const instancedMesh = event.target;
          instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
          attributes.remove(instancedMesh.instanceMatrix);
          if (instancedMesh.instanceColor !== null)
            attributes.remove(instancedMesh.instanceColor);
        }
        return {
          update,
          dispose
        };
      }
      class DataTexture2DArray extends Texture2 {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture2DArray.prototype.isDataTexture2DArray = true;
      class DataTexture3D extends Texture2 {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture3D.prototype.isDataTexture3D = true;
      const emptyTexture = new Texture2();
      const emptyTexture2dArray = new DataTexture2DArray();
      const emptyTexture3d = new DataTexture3D();
      const emptyCubeTexture = new CubeTexture();
      const arrayCacheF32 = [];
      const arrayCacheI32 = [];
      const mat4array = new Float32Array(16);
      const mat3array = new Float32Array(9);
      const mat2array = new Float32Array(4);
      function flatten(array, nBlocks, blockSize) {
        const firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
          return array;
        const n = nBlocks * blockSize;
        let r = arrayCacheF32[n];
        if (r === void 0) {
          r = new Float32Array(n);
          arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
          firstElem.toArray(r, 0);
          for (let i = 1, offset = 0; i !== nBlocks; ++i) {
            offset += blockSize;
            array[i].toArray(r, offset);
          }
        }
        return r;
      }
      function arraysEqual(a, b) {
        if (a.length !== b.length)
          return false;
        for (let i = 0, l = a.length; i < l; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      function copyArray(a, b) {
        for (let i = 0, l = b.length; i < l; i++) {
          a[i] = b[i];
        }
      }
      function allocTexUnits(textures, n) {
        let r = arrayCacheI32[n];
        if (r === void 0) {
          r = new Int32Array(n);
          arrayCacheI32[n] = r;
        }
        for (let i = 0; i !== n; ++i) {
          r[i] = textures.allocateTextureUnit();
        }
        return r;
      }
      function setValueV1f(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
      }
      function setValueV2f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform2fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueV3f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
          }
        } else if (v.r !== void 0) {
          if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform3fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueV4f(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
          }
        } else {
          if (arraysEqual(cache, v))
            return;
          gl.uniform4fv(this.addr, v);
          copyArray(cache, v);
        }
      }
      function setValueM2(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix2fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat2array.set(elements);
          gl.uniformMatrix2fv(this.addr, false, mat2array);
          copyArray(cache, elements);
        }
      }
      function setValueM3(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix3fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat3array.set(elements);
          gl.uniformMatrix3fv(this.addr, false, mat3array);
          copyArray(cache, elements);
        }
      }
      function setValueM4(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual(cache, v))
            return;
          gl.uniformMatrix4fv(this.addr, false, v);
          copyArray(cache, v);
        } else {
          if (arraysEqual(cache, elements))
            return;
          mat4array.set(elements);
          gl.uniformMatrix4fv(this.addr, false, mat4array);
          copyArray(cache, elements);
        }
      }
      function setValueV1i(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
      }
      function setValueV2i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform2iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV3i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform3iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV4i(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform4iv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV1ui(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1ui(this.addr, v);
        cache[0] = v;
      }
      function setValueV2ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform2uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV3ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform3uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueV4ui(gl, v) {
        const cache = this.cache;
        if (arraysEqual(cache, v))
          return;
        gl.uniform4uiv(this.addr, v);
        copyArray(cache, v);
      }
      function setValueT1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTexture2D(v || emptyTexture, unit);
      }
      function setValueT3D1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture3D(v || emptyTexture3d, unit);
      }
      function setValueT6(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTextureCube(v || emptyCubeTexture, unit);
      }
      function setValueT2DArray1(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture2DArray(v || emptyTexture2dArray, unit);
      }
      function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValueV1f;
          case 35664:
            return setValueV2f;
          case 35665:
            return setValueV3f;
          case 35666:
            return setValueV4f;
          case 35674:
            return setValueM2;
          case 35675:
            return setValueM3;
          case 35676:
            return setValueM4;
          case 5124:
          case 35670:
            return setValueV1i;
          case 35667:
          case 35671:
            return setValueV2i;
          case 35668:
          case 35672:
            return setValueV3i;
          case 35669:
          case 35673:
            return setValueV4i;
          case 5125:
            return setValueV1ui;
          case 36294:
            return setValueV2ui;
          case 36295:
            return setValueV3ui;
          case 36296:
            return setValueV4ui;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3D1;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArray1;
        }
      }
      function setValueV1fArray(gl, v) {
        gl.uniform1fv(this.addr, v);
      }
      function setValueV2fArray(gl, v) {
        const data = flatten(v, this.size, 2);
        gl.uniform2fv(this.addr, data);
      }
      function setValueV3fArray(gl, v) {
        const data = flatten(v, this.size, 3);
        gl.uniform3fv(this.addr, data);
      }
      function setValueV4fArray(gl, v) {
        const data = flatten(v, this.size, 4);
        gl.uniform4fv(this.addr, data);
      }
      function setValueM2Array(gl, v) {
        const data = flatten(v, this.size, 4);
        gl.uniformMatrix2fv(this.addr, false, data);
      }
      function setValueM3Array(gl, v) {
        const data = flatten(v, this.size, 9);
        gl.uniformMatrix3fv(this.addr, false, data);
      }
      function setValueM4Array(gl, v) {
        const data = flatten(v, this.size, 16);
        gl.uniformMatrix4fv(this.addr, false, data);
      }
      function setValueV1iArray(gl, v) {
        gl.uniform1iv(this.addr, v);
      }
      function setValueV2iArray(gl, v) {
        gl.uniform2iv(this.addr, v);
      }
      function setValueV3iArray(gl, v) {
        gl.uniform3iv(this.addr, v);
      }
      function setValueV4iArray(gl, v) {
        gl.uniform4iv(this.addr, v);
      }
      function setValueV1uiArray(gl, v) {
        gl.uniform1uiv(this.addr, v);
      }
      function setValueV2uiArray(gl, v) {
        gl.uniform2uiv(this.addr, v);
      }
      function setValueV3uiArray(gl, v) {
        gl.uniform3uiv(this.addr, v);
      }
      function setValueV4uiArray(gl, v) {
        gl.uniform4uiv(this.addr, v);
      }
      function setValueT1Array(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i = 0; i !== n; ++i) {
          textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
        }
      }
      function setValueT6Array(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i = 0; i !== n; ++i) {
          textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
      }
      function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValueV1fArray;
          case 35664:
            return setValueV2fArray;
          case 35665:
            return setValueV3fArray;
          case 35666:
            return setValueV4fArray;
          case 35674:
            return setValueM2Array;
          case 35675:
            return setValueM3Array;
          case 35676:
            return setValueM4Array;
          case 5124:
          case 35670:
            return setValueV1iArray;
          case 35667:
          case 35671:
            return setValueV2iArray;
          case 35668:
          case 35672:
            return setValueV3iArray;
          case 35669:
          case 35673:
            return setValueV4iArray;
          case 5125:
            return setValueV1uiArray;
          case 36294:
            return setValueV2uiArray;
          case 36295:
            return setValueV3uiArray;
          case 36296:
            return setValueV4uiArray;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1Array;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6Array;
        }
      }
      function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type);
      }
      function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
      }
      PureArrayUniform.prototype.updateCache = function(data) {
        const cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
          this.cache = new Float32Array(data.length);
        }
        copyArray(cache, data);
      };
      function StructuredUniform(id) {
        this.id = id;
        this.seq = [];
        this.map = {};
      }
      StructuredUniform.prototype.setValue = function(gl, value, textures) {
        const seq = this.seq;
        for (let i = 0, n = seq.length; i !== n; ++i) {
          const u = seq[i];
          u.setValue(gl, value[u.id], textures);
        }
      };
      const RePathPart = /(\w+)(\])?(\[|\.)?/g;
      function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
      }
      function parseUniform(activeInfo, addr, container) {
        const path = activeInfo.name, pathLength = path.length;
        RePathPart.lastIndex = 0;
        while (true) {
          const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
          let id = match[1];
          const idIsIndex = match[2] === "]", subscript = match[3];
          if (idIsIndex)
            id = id | 0;
          if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
          } else {
            const map = container.map;
            let next = map[id];
            if (next === void 0) {
              next = new StructuredUniform(id);
              addUniform(container, next);
            }
            container = next;
          }
        }
      }
      function WebGLUniforms(gl, program) {
        this.seq = [];
        this.map = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
          const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
          parseUniform(info, addr, this);
        }
      }
      WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
        const u = this.map[name];
        if (u !== void 0)
          u.setValue(gl, value, textures);
      };
      WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        const v = object[name];
        if (v !== void 0)
          this.setValue(gl, name, v);
      };
      WebGLUniforms.upload = function(gl, seq, values, textures) {
        for (let i = 0, n = seq.length; i !== n; ++i) {
          const u = seq[i], v = values[u.id];
          if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, textures);
          }
        }
      };
      WebGLUniforms.seqWithValue = function(seq, values) {
        const r = [];
        for (let i = 0, n = seq.length; i !== n; ++i) {
          const u = seq[i];
          if (u.id in values)
            r.push(u);
        }
        return r;
      };
      function WebGLShader(gl, type, string) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        return shader;
      }
      let programIdCount = 0;
      function addLineNumbers(string) {
        const lines = string.split("\n");
        for (let i = 0; i < lines.length; i++) {
          lines[i] = i + 1 + ": " + lines[i];
        }
        return lines.join("\n");
      }
      function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return ["Linear", "( value )"];
          case sRGBEncoding:
            return ["sRGB", "( value )"];
          case RGBEEncoding:
            return ["RGBE", "( value )"];
          case RGBM7Encoding:
            return ["RGBM", "( value, 7.0 )"];
          case RGBM16Encoding:
            return ["RGBM", "( value, 16.0 )"];
          case RGBDEncoding:
            return ["RGBD", "( value, 256.0 )"];
          case GammaEncoding:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case LogLuvEncoding:
            return ["LogLuv", "( value )"];
          default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return ["Linear", "( value )"];
        }
      }
      function getShaderErrors(gl, shader, type) {
        const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        const log = gl.getShaderInfoLog(shader).trim();
        if (status && log === "")
          return "";
        const source = gl.getShaderSource(shader);
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
      }
      function getTexelDecodingFunction(functionName, encoding) {
        const components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
      }
      function getTexelEncodingFunction(functionName, encoding) {
        const components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
      }
      function getToneMappingFunction(functionName, toneMapping) {
        let toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;
          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;
          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;
          case ACESFilmicToneMapping:
            toneMappingName = "ACESFilmic";
            break;
          case CustomToneMapping:
            toneMappingName = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
      }
      function generateExtensions(parameters) {
        const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
        return chunks.filter(filterEmptyLine).join("\n");
      }
      function generateDefines(defines) {
        const chunks = [];
        for (const name in defines) {
          const value = defines[name];
          if (value === false)
            continue;
          chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
      }
      function fetchAttributeLocations(gl, program) {
        const attributes = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < n; i++) {
          const info = gl.getActiveAttrib(program, i);
          const name = info.name;
          attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
      }
      function filterEmptyLine(string) {
        return string !== "";
      }
      function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
      }
      function replaceClippingPlaneNums(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
      }
      const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function resolveIncludes(string) {
        return string.replace(includePattern, includeReplacer);
      }
      function includeReplacer(match, include) {
        const string = ShaderChunk[include];
        if (string === void 0) {
          throw new Error("Can not resolve #include <" + include + ">");
        }
        return resolveIncludes(string);
      }
      const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
      const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function unrollLoops(string) {
        return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
      }
      function deprecatedLoopReplacer(match, start, end, snippet) {
        console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
        return loopReplacer(match, start, end, snippet);
      }
      function loopReplacer(match, start, end, snippet) {
        let string = "";
        for (let i = parseInt(start); i < parseInt(end); i++) {
          string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
        }
        return string;
      }
      function generatePrecision(parameters) {
        let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
        if (parameters.precision === "highp") {
          precisionstring += "\n#define HIGH_PRECISION";
        } else if (parameters.precision === "mediump") {
          precisionstring += "\n#define MEDIUM_PRECISION";
        } else if (parameters.precision === "lowp") {
          precisionstring += "\n#define LOW_PRECISION";
        }
        return precisionstring;
      }
      function generateShadowMapTypeDefine(parameters) {
        let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === PCFShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        } else if (parameters.shadowMapType === VSMShadowMap) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
        }
        return shadowMapTypeDefine;
      }
      function generateEnvMapTypeDefine(parameters) {
        let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE";
              break;
            case CubeUVReflectionMapping:
            case CubeUVRefractionMapping:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        }
        return envMapTypeDefine;
      }
      function generateEnvMapModeDefine(parameters) {
        let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeRefractionMapping:
            case CubeUVRefractionMapping:
              envMapModeDefine = "ENVMAP_MODE_REFRACTION";
              break;
          }
        }
        return envMapModeDefine;
      }
      function generateEnvMapBlendingDefine(parameters) {
        let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
        if (parameters.envMap) {
          switch (parameters.combine) {
            case MultiplyOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case MixOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
              break;
            case AddOperation:
              envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
              break;
          }
        }
        return envMapBlendingDefine;
      }
      function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
        const gl = renderer.getContext();
        const defines = parameters.defines;
        let vertexShader = parameters.vertexShader;
        let fragmentShader = parameters.fragmentShader;
        const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
        const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
        const envMapModeDefine = generateEnvMapModeDefine(parameters);
        const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
        const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
        const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
        const customDefines = generateDefines(defines);
        const program = gl.createProgram();
        let prefixVertex, prefixFragment;
        let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
        if (parameters.isRawShaderMaterial) {
          prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
          if (prefixVertex.length > 0) {
            prefixVertex += "\n";
          }
          prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
          if (prefixFragment.length > 0) {
            prefixFragment += "\n";
          }
        } else {
          prefixVertex = [generatePrecision(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
          prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            ShaderChunk["encodings_pars_fragment"],
            parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
            parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
            parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
            parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
            parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
            getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
            parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n"
          ].filter(filterEmptyLine).join("\n");
        }
        vertexShader = resolveIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = resolveIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
          versionString = "#version 300 es\n";
          prefixVertex = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
          prefixFragment = ["#define varying in", parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
        }
        const vertexGlsl = versionString + prefixVertex + vertexShader;
        const fragmentGlsl = versionString + prefixFragment + fragmentShader;
        const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (parameters.index0AttributeName !== void 0) {
          gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl.bindAttribLocation(program, 0, "position");
        }
        gl.linkProgram(program);
        if (renderer.debug.checkShaderErrors) {
          const programLog = gl.getProgramInfoLog(program).trim();
          const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
          const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
          let runnable = true;
          let haveDiagnostics = true;
          if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
          } else if (programLog !== "") {
            console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
          } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
          }
          if (haveDiagnostics) {
            this.diagnostics = {
              runnable,
              programLog,
              vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
              },
              fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
              }
            };
          }
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        let cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === void 0) {
            cachedUniforms = new WebGLUniforms(gl, program);
          }
          return cachedUniforms;
        };
        let cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === void 0) {
            cachedAttributes = fetchAttributeLocations(gl, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          bindingStates.releaseStatesOfProgram(this);
          gl.deleteProgram(program);
          this.program = void 0;
        };
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      }
      function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
        const programs = [];
        const isWebGL2 = capabilities.isWebGL2;
        const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        const floatVertexTextures = capabilities.floatVertexTextures;
        const maxVertexUniforms = capabilities.maxVertexUniforms;
        const vertexTextures = capabilities.vertexTextures;
        let precision = capabilities.precision;
        const shaderIDs = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        const parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];
        function getMaxBones(object) {
          const skeleton = object.skeleton;
          const bones = skeleton.bones;
          if (floatVertexTextures) {
            return 1024;
          } else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
              console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
              return 0;
            }
            return maxBones;
          }
        }
        function getTextureEncodingFromMap(map) {
          let encoding;
          if (map && map.isTexture) {
            encoding = map.encoding;
          } else if (map && map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
          } else {
            encoding = LinearEncoding;
          }
          return encoding;
        }
        function getParameters(material, lights, shadows, scene, object) {
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const envMap = cubemaps.get(material.envMap || environment);
          const shaderID = shaderIDs[material.type];
          const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
          if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
              console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            }
          }
          let vertexShader, fragmentShader;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
          } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
          }
          const currentRenderTarget = renderer.getRenderTarget();
          const parameters = {
            isWebGL2,
            shaderID,
            shaderName: material.type,
            vertexShader,
            fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            transmission: !!material.transmission,
            transmissionMap: !!material.transmissionMap,
            thicknessMap: !!material.thicknessMap,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide2,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material.customProgramCacheKey()
          };
          return parameters;
        }
        function getProgramCacheKey(parameters) {
          const array = [];
          if (parameters.shaderID) {
            array.push(parameters.shaderID);
          } else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
          }
          if (parameters.defines !== void 0) {
            for (const name in parameters.defines) {
              array.push(name);
              array.push(parameters.defines[name]);
            }
          }
          if (parameters.isRawShaderMaterial === false) {
            for (let i = 0; i < parameterNames.length; i++) {
              array.push(parameters[parameterNames[i]]);
            }
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
          }
          array.push(parameters.customProgramCacheKey);
          return array.join();
        }
        function getUniforms(material) {
          const shaderID = shaderIDs[material.type];
          let uniforms;
          if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
          } else {
            uniforms = material.uniforms;
          }
          return uniforms;
        }
        function acquireProgram(parameters, cacheKey) {
          let program;
          for (let p = 0, pl = programs.length; p < pl; p++) {
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
              program = preexistingProgram;
              ++program.usedTimes;
              break;
            }
          }
          if (program === void 0) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
          }
          return program;
        }
        function releaseProgram(program) {
          if (--program.usedTimes === 0) {
            const i = programs.indexOf(program);
            programs[i] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
          }
        }
        return {
          getParameters,
          getProgramCacheKey,
          getUniforms,
          acquireProgram,
          releaseProgram,
          programs
        };
      }
      function WebGLProperties() {
        let properties = new WeakMap();
        function get(object) {
          let map = properties.get(object);
          if (map === void 0) {
            map = {};
            properties.set(object, map);
          }
          return map;
        }
        function remove(object) {
          properties.delete(object);
        }
        function update(object, key, value) {
          properties.get(object)[key] = value;
        }
        function dispose() {
          properties = new WeakMap();
        }
        return {
          get,
          remove,
          update,
          dispose
        };
      }
      function painterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.program !== b.program) {
          return a.program.id - b.program.id;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      function WebGLRenderList(properties) {
        const renderItems = [];
        let renderItemsIndex = 0;
        const opaque = [];
        const transmissive = [];
        const transparent = [];
        const defaultProgram = {
          id: -1
        };
        function init2() {
          renderItemsIndex = 0;
          opaque.length = 0;
          transmissive.length = 0;
          transparent.length = 0;
        }
        function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
          let renderItem = renderItems[renderItemsIndex];
          const materialProperties = properties.get(material);
          if (renderItem === void 0) {
            renderItem = {
              id: object.id,
              object,
              geometry,
              material,
              program: materialProperties.program || defaultProgram,
              groupOrder,
              renderOrder: object.renderOrder,
              z: z2,
              group
            };
            renderItems[renderItemsIndex] = renderItem;
          } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z2;
            renderItem.group = group;
          }
          renderItemsIndex++;
          return renderItem;
        }
        function push(object, geometry, material, groupOrder, z2, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
          if (material.transmission > 0) {
            transmissive.push(renderItem);
          } else if (material.transparent === true) {
            transparent.push(renderItem);
          } else {
            opaque.push(renderItem);
          }
        }
        function unshift(object, geometry, material, groupOrder, z2, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
          if (material.transmission > 0) {
            transmissive.unshift(renderItem);
          } else if (material.transparent === true) {
            transparent.unshift(renderItem);
          } else {
            opaque.unshift(renderItem);
          }
        }
        function sort(customOpaqueSort, customTransparentSort) {
          if (opaque.length > 1)
            opaque.sort(customOpaqueSort || painterSortStable);
          if (transmissive.length > 1)
            transmissive.sort(customTransparentSort || reversePainterSortStable);
          if (transparent.length > 1)
            transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        function finish() {
          for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
            const renderItem = renderItems[i];
            if (renderItem.id === null)
              break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
          }
        }
        return {
          opaque,
          transmissive,
          transparent,
          init: init2,
          push,
          unshift,
          finish,
          sort
        };
      }
      function WebGLRenderLists(properties) {
        let lists = new WeakMap();
        function get(scene, renderCallDepth) {
          let list;
          if (lists.has(scene) === false) {
            list = new WebGLRenderList(properties);
            lists.set(scene, [list]);
          } else {
            if (renderCallDepth >= lists.get(scene).length) {
              list = new WebGLRenderList(properties);
              lists.get(scene).push(list);
            } else {
              list = lists.get(scene)[renderCallDepth];
            }
          }
          return list;
        }
        function dispose() {
          lists = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      function UniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  direction: new Vector3(),
                  color: new Color()
                };
                break;
              case "SpotLight":
                uniforms = {
                  position: new Vector3(),
                  direction: new Vector3(),
                  color: new Color(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                uniforms = {
                  position: new Vector3(),
                  color: new Color(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                uniforms = {
                  direction: new Vector3(),
                  skyColor: new Color(),
                  groundColor: new Color()
                };
                break;
              case "RectAreaLight":
                uniforms = {
                  color: new Color(),
                  position: new Vector3(),
                  halfWidth: new Vector3(),
                  halfHeight: new Vector3()
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      function ShadowUniformsCache() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22()
                };
                break;
              case "SpotLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22()
                };
                break;
              case "PointLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      let nextVersion = 0;
      function shadowCastingLightsFirst(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
      }
      function WebGLLights(extensions, capabilities) {
        const cache = new UniformsCache();
        const shadowCache = ShadowUniformsCache();
        const state2 = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []
        };
        for (let i = 0; i < 9; i++)
          state2.probe.push(new Vector3());
        const vector3 = new Vector3();
        const matrix4 = new Matrix4();
        const matrix42 = new Matrix4();
        function setup(lights) {
          let r = 0, g = 0, b = 0;
          for (let i = 0; i < 9; i++)
            state2.probe[i].set(0, 0, 0);
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          let numDirectionalShadows = 0;
          let numPointShadows = 0;
          let numSpotShadows = 0;
          lights.sort(shadowCastingLightsFirst);
          for (let i = 0, l = lights.length; i < l; i++) {
            const light = lights[i];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
              r += color.r * intensity;
              g += color.g * intensity;
              b += color.b * intensity;
            } else if (light.isLightProbe) {
              for (let j = 0; j < 9; j++) {
                state2.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
              }
            } else if (light.isDirectionalLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity);
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state2.directionalShadow[directionalLength] = shadowUniforms;
                state2.directionalShadowMap[directionalLength] = shadowMap;
                state2.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                numDirectionalShadows++;
              }
              state2.directional[directionalLength] = uniforms;
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = cache.get(light);
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.color.copy(color).multiplyScalar(intensity);
              uniforms.distance = distance;
              uniforms.coneCos = Math.cos(light.angle);
              uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state2.spotShadow[spotLength] = shadowUniforms;
                state2.spotShadowMap[spotLength] = shadowMap;
                state2.spotShadowMatrix[spotLength] = light.shadow.matrix;
                numSpotShadows++;
              }
              state2.spot[spotLength] = uniforms;
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(color).multiplyScalar(intensity);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              state2.rectArea[rectAreaLength] = uniforms;
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity);
              uniforms.distance = light.distance;
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                shadowUniforms.shadowCameraNear = shadow.camera.near;
                shadowUniforms.shadowCameraFar = shadow.camera.far;
                state2.pointShadow[pointLength] = shadowUniforms;
                state2.pointShadowMap[pointLength] = shadowMap;
                state2.pointShadowMatrix[pointLength] = light.shadow.matrix;
                numPointShadows++;
              }
              state2.point[pointLength] = uniforms;
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = cache.get(light);
              uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
              uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
              state2.hemi[hemiLength] = uniforms;
              hemiLength++;
            }
          }
          if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
              state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
              state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else {
              if (extensions.has("OES_texture_float_linear") === true) {
                state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
              } else if (extensions.has("OES_texture_half_float_linear") === true) {
                state2.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                state2.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
              } else {
                console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
              }
            }
          }
          state2.ambient[0] = r;
          state2.ambient[1] = g;
          state2.ambient[2] = b;
          const hash2 = state2.hash;
          if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
            state2.directional.length = directionalLength;
            state2.spot.length = spotLength;
            state2.rectArea.length = rectAreaLength;
            state2.point.length = pointLength;
            state2.hemi.length = hemiLength;
            state2.directionalShadow.length = numDirectionalShadows;
            state2.directionalShadowMap.length = numDirectionalShadows;
            state2.pointShadow.length = numPointShadows;
            state2.pointShadowMap.length = numPointShadows;
            state2.spotShadow.length = numSpotShadows;
            state2.spotShadowMap.length = numSpotShadows;
            state2.directionalShadowMatrix.length = numDirectionalShadows;
            state2.pointShadowMatrix.length = numPointShadows;
            state2.spotShadowMatrix.length = numSpotShadows;
            hash2.directionalLength = directionalLength;
            hash2.pointLength = pointLength;
            hash2.spotLength = spotLength;
            hash2.rectAreaLength = rectAreaLength;
            hash2.hemiLength = hemiLength;
            hash2.numDirectionalShadows = numDirectionalShadows;
            hash2.numPointShadows = numPointShadows;
            hash2.numSpotShadows = numSpotShadows;
            state2.version = nextVersion++;
          }
        }
        function setupView(lights, camera) {
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          const viewMatrix = camera.matrixWorldInverse;
          for (let i = 0, l = lights.length; i < l; i++) {
            const light = lights[i];
            if (light.isDirectionalLight) {
              const uniforms = state2.directional[directionalLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = state2.spot[spotLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = state2.rectArea[rectAreaLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              matrix42.identity();
              matrix4.copy(light.matrixWorld);
              matrix4.premultiply(viewMatrix);
              matrix42.extractRotation(matrix4);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              uniforms.halfWidth.applyMatrix4(matrix42);
              uniforms.halfHeight.applyMatrix4(matrix42);
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = state2.point[pointLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = state2.hemi[hemiLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              uniforms.direction.transformDirection(viewMatrix);
              uniforms.direction.normalize();
              hemiLength++;
            }
          }
        }
        return {
          setup,
          setupView,
          state: state2
        };
      }
      function WebGLRenderState(extensions, capabilities) {
        const lights = new WebGLLights(extensions, capabilities);
        const lightsArray = [];
        const shadowsArray = [];
        function init2() {
          lightsArray.length = 0;
          shadowsArray.length = 0;
        }
        function pushLight(light) {
          lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
          shadowsArray.push(shadowLight);
        }
        function setupLights() {
          lights.setup(lightsArray);
        }
        function setupLightsView(camera) {
          lights.setupView(lightsArray, camera);
        }
        const state2 = {
          lightsArray,
          shadowsArray,
          lights
        };
        return {
          init: init2,
          state: state2,
          setupLights,
          setupLightsView,
          pushLight,
          pushShadow
        };
      }
      function WebGLRenderStates(extensions, capabilities) {
        let renderStates = new WeakMap();
        function get(scene, renderCallDepth = 0) {
          let renderState;
          if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [renderState]);
          } else {
            if (renderCallDepth >= renderStates.get(scene).length) {
              renderState = new WebGLRenderState(extensions, capabilities);
              renderStates.get(scene).push(renderState);
            } else {
              renderState = renderStates.get(scene)[renderCallDepth];
            }
          }
          return renderState;
        }
        function dispose() {
          renderStates = new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      class MeshDepthMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.morphTargets = false;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.morphTargets = source.morphTargets;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      }
      MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
      class MeshDistanceMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector3();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.morphTargets = false;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.morphTargets = source.morphTargets;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      }
      MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
      var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      function WebGLShadowMap(_renderer, _objects, _capabilities) {
        let _frustum = new Frustum();
        const _shadowMapSize = new Vector22(), _viewportSize = new Vector22(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
        const shadowSide = {
          0: BackSide,
          1: FrontSide,
          2: DoubleSide2
        };
        const shadowMaterialVertical = new ShaderMaterial({
          defines: {
            SAMPLE_RATE: 2 / 8,
            HALF_SAMPLE_RATE: 1 / 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Vector22()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: vsm_vert,
          fragmentShader: vsm_frag
        });
        const shadowMaterialHorizontal = shadowMaterialVertical.clone();
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        const fullScreenTri = new BufferGeometry();
        fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const fullScreenMesh = new Mesh2(fullScreenTri, shadowMaterialVertical);
        const scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function(lights, scene, camera) {
          if (scope.enabled === false)
            return;
          if (scope.autoUpdate === false && scope.needsUpdate === false)
            return;
          if (lights.length === 0)
            return;
          const currentRenderTarget = _renderer.getRenderTarget();
          const activeCubeFace = _renderer.getActiveCubeFace();
          const activeMipmapLevel = _renderer.getActiveMipmapLevel();
          const _state = _renderer.state;
          _state.setBlending(NoBlending);
          _state.buffers.color.setClear(1, 1, 1, 1);
          _state.buffers.depth.setTest(true);
          _state.setScissorTest(false);
          for (let i = 0, il = lights.length; i < il; i++) {
            const light = lights[i];
            const shadow = light.shadow;
            if (shadow === void 0) {
              console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
              continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false)
              continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
              if (_shadowMapSize.x > _maxTextureSize) {
                _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                shadow.mapSize.x = _viewportSize.x;
              }
              if (_shadowMapSize.y > _maxTextureSize) {
                _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                shadow.mapSize.y = _viewportSize.y;
              }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
              const pars = {
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
              const pars = {
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat
              };
              shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for (let vp = 0; vp < viewportCount; vp++) {
              const viewport = shadow.getViewport(vp);
              _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
              _state.viewport(_viewport);
              shadow.updateMatrices(light, vp);
              _frustum = shadow.getFrustum();
              renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
              VSMPass(shadow, camera);
            }
            shadow.needsUpdate = false;
          }
          scope.needsUpdate = false;
          _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
          const geometry = _objects.update(fullScreenMesh);
          shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
          shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialVertical.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.mapPass);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
          shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
          shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
        }
        function getDepthMaterialVariant(useMorphing) {
          const index2 = useMorphing << 0;
          let material = _depthMaterials[index2];
          if (material === void 0) {
            material = new MeshDepthMaterial({
              depthPacking: RGBADepthPacking,
              morphTargets: useMorphing
            });
            _depthMaterials[index2] = material;
          }
          return material;
        }
        function getDistanceMaterialVariant(useMorphing) {
          const index2 = useMorphing << 0;
          let material = _distanceMaterials[index2];
          if (material === void 0) {
            material = new MeshDistanceMaterial({
              morphTargets: useMorphing
            });
            _distanceMaterials[index2] = material;
          }
          return material;
        }
        function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
          let result = null;
          let getMaterialVariant = getDepthMaterialVariant;
          let customMaterial = object.customDepthMaterial;
          if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
          }
          if (customMaterial === void 0) {
            let useMorphing = false;
            if (material.morphTargets === true) {
              useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            }
            result = getMaterialVariant(useMorphing);
          } else {
            result = customMaterial;
          }
          if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === void 0) {
              materialsForVariant = {};
              _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === void 0) {
              cachedMaterial = result.clone();
              materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
          }
          result.visible = material.visible;
          result.wireframe = material.wireframe;
          if (type === VSMShadowMap) {
            result.side = material.shadowSide !== null ? material.shadowSide : material.side;
          } else {
            result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
          }
          result.clipShadows = material.clipShadows;
          result.clippingPlanes = material.clippingPlanes;
          result.clipIntersection = material.clipIntersection;
          result.wireframeLinewidth = material.wireframeLinewidth;
          result.linewidth = material.linewidth;
          if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
          }
          return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
              object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              const geometry = _objects.update(object);
              const material = object.material;
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let k = 0, kl = groups.length; k < kl; k++) {
                  const group = groups[k];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                  }
                }
              } else if (material.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
              }
            }
          }
          const children = object.children;
          for (let i = 0, l = children.length; i < l; i++) {
            renderObject(children[i], camera, shadowCamera, light, type);
          }
        }
      }
      function WebGLState(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
          let locked = false;
          const color = new Vector4();
          let currentColorMask = null;
          const currentColorClear = new Vector4(0, 0, 0, 0);
          return {
            setMask: function(colorMask) {
              if (currentColorMask !== colorMask && !locked) {
                gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                currentColorMask = colorMask;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
              if (premultipliedAlpha === true) {
                r *= a;
                g *= a;
                b *= a;
              }
              color.set(r, g, b, a);
              if (currentColorClear.equals(color) === false) {
                gl.clearColor(r, g, b, a);
                currentColorClear.copy(color);
              }
            },
            reset: function() {
              locked = false;
              currentColorMask = null;
              currentColorClear.set(-1, 0, 0, 0);
            }
          };
        }
        function DepthBuffer() {
          let locked = false;
          let currentDepthMask = null;
          let currentDepthFunc = null;
          let currentDepthClear = null;
          return {
            setTest: function(depthTest) {
              if (depthTest) {
                enable(gl.DEPTH_TEST);
              } else {
                disable(gl.DEPTH_TEST);
              }
            },
            setMask: function(depthMask) {
              if (currentDepthMask !== depthMask && !locked) {
                gl.depthMask(depthMask);
                currentDepthMask = depthMask;
              }
            },
            setFunc: function(depthFunc) {
              if (currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth:
                      gl.depthFunc(gl.NEVER);
                      break;
                    case AlwaysDepth:
                      gl.depthFunc(gl.ALWAYS);
                      break;
                    case LessDepth:
                      gl.depthFunc(gl.LESS);
                      break;
                    case LessEqualDepth:
                      gl.depthFunc(gl.LEQUAL);
                      break;
                    case EqualDepth:
                      gl.depthFunc(gl.EQUAL);
                      break;
                    case GreaterEqualDepth:
                      gl.depthFunc(gl.GEQUAL);
                      break;
                    case GreaterDepth:
                      gl.depthFunc(gl.GREATER);
                      break;
                    case NotEqualDepth:
                      gl.depthFunc(gl.NOTEQUAL);
                      break;
                    default:
                      gl.depthFunc(gl.LEQUAL);
                  }
                } else {
                  gl.depthFunc(gl.LEQUAL);
                }
                currentDepthFunc = depthFunc;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(depth) {
              if (currentDepthClear !== depth) {
                gl.clearDepth(depth);
                currentDepthClear = depth;
              }
            },
            reset: function() {
              locked = false;
              currentDepthMask = null;
              currentDepthFunc = null;
              currentDepthClear = null;
            }
          };
        }
        function StencilBuffer() {
          let locked = false;
          let currentStencilMask = null;
          let currentStencilFunc = null;
          let currentStencilRef = null;
          let currentStencilFuncMask = null;
          let currentStencilFail = null;
          let currentStencilZFail = null;
          let currentStencilZPass = null;
          let currentStencilClear = null;
          return {
            setTest: function(stencilTest) {
              if (!locked) {
                if (stencilTest) {
                  enable(gl.STENCIL_TEST);
                } else {
                  disable(gl.STENCIL_TEST);
                }
              }
            },
            setMask: function(stencilMask) {
              if (currentStencilMask !== stencilMask && !locked) {
                gl.stencilMask(stencilMask);
                currentStencilMask = stencilMask;
              }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
              if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                currentStencilFunc = stencilFunc;
                currentStencilRef = stencilRef;
                currentStencilFuncMask = stencilMask;
              }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
              if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                currentStencilFail = stencilFail;
                currentStencilZFail = stencilZFail;
                currentStencilZPass = stencilZPass;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(stencil) {
              if (currentStencilClear !== stencil) {
                gl.clearStencil(stencil);
                currentStencilClear = stencil;
              }
            },
            reset: function() {
              locked = false;
              currentStencilMask = null;
              currentStencilFunc = null;
              currentStencilRef = null;
              currentStencilFuncMask = null;
              currentStencilFail = null;
              currentStencilZFail = null;
              currentStencilZPass = null;
              currentStencilClear = null;
            }
          };
        }
        const colorBuffer = new ColorBuffer();
        const depthBuffer = new DepthBuffer();
        const stencilBuffer = new StencilBuffer();
        let enabledCapabilities = {};
        let xrFramebuffer = null;
        let currentBoundFramebuffers = {};
        let currentProgram = null;
        let currentBlendingEnabled = false;
        let currentBlending = null;
        let currentBlendEquation = null;
        let currentBlendSrc = null;
        let currentBlendDst = null;
        let currentBlendEquationAlpha = null;
        let currentBlendSrcAlpha = null;
        let currentBlendDstAlpha = null;
        let currentPremultipledAlpha = false;
        let currentFlipSided = null;
        let currentCullFace = null;
        let currentLineWidth = null;
        let currentPolygonOffsetFactor = null;
        let currentPolygonOffsetUnits = null;
        const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let lineWidthAvailable = false;
        let version = 0;
        const glVersion = gl.getParameter(gl.VERSION);
        if (glVersion.indexOf("WebGL") !== -1) {
          version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 1;
        } else if (glVersion.indexOf("OpenGL ES") !== -1) {
          version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 2;
        }
        let currentTextureSlot = null;
        let currentBoundTextures = {};
        const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
        const viewportParam = gl.getParameter(gl.VIEWPORT);
        const currentScissor = new Vector4().fromArray(scissorParam);
        const currentViewport = new Vector4().fromArray(viewportParam);
        function createTexture(type, target, count) {
          const data = new Uint8Array(4);
          const texture = gl.createTexture();
          gl.bindTexture(type, texture);
          gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          for (let i = 0; i < count; i++) {
            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
          }
          return texture;
        }
        const emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl.CULL_FACE);
        setBlending(NoBlending);
        function enable(id) {
          if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
          }
        }
        function disable(id) {
          if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
          }
        }
        function bindXRFramebuffer(framebuffer) {
          if (framebuffer !== xrFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            xrFramebuffer = framebuffer;
          }
        }
        function bindFramebuffer(target, framebuffer) {
          if (framebuffer === null && xrFramebuffer !== null)
            framebuffer = xrFramebuffer;
          if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
              if (target === gl.DRAW_FRAMEBUFFER) {
                currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
              }
              if (target === gl.FRAMEBUFFER) {
                currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
              }
            }
            return true;
          }
          return false;
        }
        function useProgram(program) {
          if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
          }
          return false;
        }
        const equationToGL = {
          [AddEquation]: gl.FUNC_ADD,
          [SubtractEquation]: gl.FUNC_SUBTRACT,
          [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
        };
        if (isWebGL2) {
          equationToGL[MinEquation] = gl.MIN;
          equationToGL[MaxEquation] = gl.MAX;
        } else {
          const extension = extensions.get("EXT_blend_minmax");
          if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
          }
        }
        const factorToGL = {
          [ZeroFactor]: gl.ZERO,
          [OneFactor]: gl.ONE,
          [SrcColorFactor]: gl.SRC_COLOR,
          [SrcAlphaFactor]: gl.SRC_ALPHA,
          [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
          [DstColorFactor]: gl.DST_COLOR,
          [DstAlphaFactor]: gl.DST_ALPHA,
          [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
          [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
          [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
          [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
        };
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
          if (blending === NoBlending) {
            if (currentBlendingEnabled === true) {
              disable(gl.BLEND);
              currentBlendingEnabled = false;
            }
            return;
          }
          if (currentBlendingEnabled === false) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
          }
          if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
              if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                gl.blendEquation(gl.FUNC_ADD);
                currentBlendEquation = AddEquation;
                currentBlendEquationAlpha = AddEquation;
              }
              if (premultipliedAlpha) {
                switch (blending) {
                  case NormalBlending:
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl.blendFunc(gl.ONE, gl.ONE);
                    break;
                  case SubtractiveBlending:
                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case MultiplyBlending:
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              } else {
                switch (blending) {
                  case NormalBlending:
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    break;
                  case SubtractiveBlending:
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                    break;
                  case MultiplyBlending:
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              }
              currentBlendSrc = null;
              currentBlendDst = null;
              currentBlendSrcAlpha = null;
              currentBlendDstAlpha = null;
              currentBlending = blending;
              currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
          }
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
          currentBlending = blending;
          currentPremultipledAlpha = null;
        }
        function setMaterial(material, frontFaceCW) {
          material.side === DoubleSide2 ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
          let flipSided = material.side === BackSide;
          if (frontFaceCW)
            flipSided = !flipSided;
          setFlipSided(flipSided);
          material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
          depthBuffer.setFunc(material.depthFunc);
          depthBuffer.setTest(material.depthTest);
          depthBuffer.setMask(material.depthWrite);
          colorBuffer.setMask(material.colorWrite);
          const stencilWrite = material.stencilWrite;
          stencilBuffer.setTest(stencilWrite);
          if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
          }
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
          material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function setFlipSided(flipSided) {
          if (currentFlipSided !== flipSided) {
            if (flipSided) {
              gl.frontFace(gl.CW);
            } else {
              gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
          }
        }
        function setCullFace(cullFace) {
          if (cullFace !== CullFaceNone) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
              if (cullFace === CullFaceBack) {
                gl.cullFace(gl.BACK);
              } else if (cullFace === CullFaceFront) {
                gl.cullFace(gl.FRONT);
              } else {
                gl.cullFace(gl.FRONT_AND_BACK);
              }
            }
          } else {
            disable(gl.CULL_FACE);
          }
          currentCullFace = cullFace;
        }
        function setLineWidth(width) {
          if (width !== currentLineWidth) {
            if (lineWidthAvailable)
              gl.lineWidth(width);
            currentLineWidth = width;
          }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
          if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
              gl.polygonOffset(factor, units);
              currentPolygonOffsetFactor = factor;
              currentPolygonOffsetUnits = units;
            }
          } else {
            disable(gl.POLYGON_OFFSET_FILL);
          }
        }
        function setScissorTest(scissorTest) {
          if (scissorTest) {
            enable(gl.SCISSOR_TEST);
          } else {
            disable(gl.SCISSOR_TEST);
          }
        }
        function activeTexture(webglSlot) {
          if (webglSlot === void 0)
            webglSlot = gl.TEXTURE0 + maxTextures - 1;
          if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
          }
        }
        function bindTexture(webglType, webglTexture) {
          if (currentTextureSlot === null) {
            activeTexture();
          }
          let boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture === void 0) {
            boundTexture = {
              type: void 0,
              texture: void 0
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
          }
          if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
          }
        }
        function unbindTexture() {
          const boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture !== void 0 && boundTexture.type !== void 0) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = void 0;
            boundTexture.texture = void 0;
          }
        }
        function compressedTexImage2D() {
          try {
            gl.compressedTexImage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texImage2D() {
          try {
            gl.texImage2D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function texImage3D() {
          try {
            gl.texImage3D.apply(gl, arguments);
          } catch (error2) {
            console.error("THREE.WebGLState:", error2);
          }
        }
        function scissor(scissor2) {
          if (currentScissor.equals(scissor2) === false) {
            gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
            currentScissor.copy(scissor2);
          }
        }
        function viewport(viewport2) {
          if (currentViewport.equals(viewport2) === false) {
            gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
            currentViewport.copy(viewport2);
          }
        }
        function reset() {
          gl.disable(gl.BLEND);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.POLYGON_OFFSET_FILL);
          gl.disable(gl.SCISSOR_TEST);
          gl.disable(gl.STENCIL_TEST);
          gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ONE, gl.ZERO);
          gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
          gl.colorMask(true, true, true, true);
          gl.clearColor(0, 0, 0, 0);
          gl.depthMask(true);
          gl.depthFunc(gl.LESS);
          gl.clearDepth(1);
          gl.stencilMask(4294967295);
          gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.clearStencil(0);
          gl.cullFace(gl.BACK);
          gl.frontFace(gl.CCW);
          gl.polygonOffset(0, 0);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          if (isWebGL2 === true) {
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          }
          gl.useProgram(null);
          gl.lineWidth(1);
          gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          enabledCapabilities = {};
          currentTextureSlot = null;
          currentBoundTextures = {};
          xrFramebuffer = null;
          currentBoundFramebuffers = {};
          currentProgram = null;
          currentBlendingEnabled = false;
          currentBlending = null;
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentPremultipledAlpha = false;
          currentFlipSided = null;
          currentCullFace = null;
          currentLineWidth = null;
          currentPolygonOffsetFactor = null;
          currentPolygonOffsetUnits = null;
          currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
          currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
          colorBuffer.reset();
          depthBuffer.reset();
          stencilBuffer.reset();
        }
        return {
          buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
          },
          enable,
          disable,
          bindFramebuffer,
          bindXRFramebuffer,
          useProgram,
          setBlending,
          setMaterial,
          setFlipSided,
          setCullFace,
          setLineWidth,
          setPolygonOffset,
          setScissorTest,
          activeTexture,
          bindTexture,
          unbindTexture,
          compressedTexImage2D,
          texImage2D,
          texImage3D,
          scissor,
          viewport,
          reset
        };
      }
      function WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info) {
        const isWebGL2 = capabilities.isWebGL2;
        const maxTextures = capabilities.maxTextures;
        const maxCubemapSize = capabilities.maxCubemapSize;
        const maxTextureSize = capabilities.maxTextureSize;
        const maxSamples = capabilities.maxSamples;
        const _videoTextures = new WeakMap();
        let _canvas2;
        let useOffscreenCanvas = false;
        try {
          useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch (err) {
        }
        function createCanvas(width, height) {
          return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
          let scale = 1;
          if (image.width > maxSize || image.height > maxSize) {
            scale = maxSize / Math.max(image.width, image.height);
          }
          if (scale < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
              const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
              const width = floor(scale * image.width);
              const height = floor(scale * image.height);
              if (_canvas2 === void 0)
                _canvas2 = createCanvas(width, height);
              const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
              canvas.width = width;
              canvas.height = height;
              const context = canvas.getContext("2d");
              context.drawImage(image, 0, 0, width, height);
              console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
              return canvas;
            } else {
              if ("data" in image) {
                console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
              }
              return image;
            }
          }
          return image;
        }
        function isPowerOfTwo$1(image) {
          return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
          if (isWebGL2)
            return false;
          return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
          return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target, texture, width, height) {
          _gl.generateMipmap(target);
          const textureProperties = properties.get(texture);
          textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
        }
        function getInternalFormat(internalFormatName, glFormat, glType) {
          if (isWebGL2 === false)
            return glFormat;
          if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== void 0)
              return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
          }
          let internalFormat = glFormat;
          if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.R8;
          }
          if (glFormat === _gl.RGB) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGB32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGB16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RGB8;
          }
          if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RGBA8;
          }
          if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
            extensions.get("EXT_color_buffer_float");
          }
          return internalFormat;
        }
        function filterFallback(f) {
          if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
            return _gl.NEAREST;
          }
          return _gl.LINEAR;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          deallocateTexture(texture);
          if (texture.isVideoTexture) {
            _videoTextures.delete(texture);
          }
          info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
          const renderTarget = event.target;
          renderTarget.removeEventListener("dispose", onRenderTargetDispose);
          deallocateRenderTarget(renderTarget);
        }
        function deallocateTexture(texture) {
          const textureProperties = properties.get(texture);
          if (textureProperties.__webglInit === void 0)
            return;
          _gl.deleteTexture(textureProperties.__webglTexture);
          properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          if (!renderTarget)
            return;
          if (textureProperties.__webglTexture !== void 0) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
          }
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
          }
          if (renderTarget.isWebGLCubeRenderTarget) {
            for (let i = 0; i < 6; i++) {
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
              if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
            }
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer)
              _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
          }
          if (renderTarget.isWebGLMultipleRenderTargets) {
            for (let i = 0, il = texture.length; i < il; i++) {
              const attachmentProperties = properties.get(texture[i]);
              if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
              }
              properties.remove(texture[i]);
            }
          }
          properties.remove(texture);
          properties.remove(renderTarget);
        }
        let textureUnits = 0;
        function resetTextureUnits() {
          textureUnits = 0;
        }
        function allocateTextureUnit() {
          const textureUnit = textureUnits;
          if (textureUnit >= maxTextures) {
            console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
          }
          textureUnits += 1;
          return textureUnit;
        }
        function setTexture2D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.isVideoTexture)
            updateVideoTexture(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === void 0) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            } else if (image.complete === false) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            } else {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
          }
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
          }
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
        const wrappingToGL = {
          [RepeatWrapping]: _gl.REPEAT,
          [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
          [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
        };
        const filterToGL = {
          [NearestFilter]: _gl.NEAREST,
          [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
          [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
          [LinearFilter]: _gl.LINEAR,
          [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
          [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
        };
        function setTextureParameters(textureType, texture, supportsMips) {
          if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
          } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            }
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
          }
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
              return;
            if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false)
              return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
              _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
              properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
          }
        }
        function initTexture(textureProperties, texture) {
          if (textureProperties.__webglInit === void 0) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
        function uploadTexture(textureProperties, texture, slot) {
          let textureType = _gl.TEXTURE_2D;
          if (texture.isDataTexture2DArray)
            textureType = _gl.TEXTURE_2D_ARRAY;
          if (texture.isDataTexture3D)
            textureType = _gl.TEXTURE_3D;
          initTexture(textureProperties, texture);
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(textureType, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
          const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
          const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
          let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          setTextureParameters(textureType, texture, supportsMips);
          let mipmap;
          const mipmaps = texture.mipmaps;
          if (texture.isDepthTexture) {
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
              if (texture.type === FloatType) {
                glInternalFormat = _gl.DEPTH_COMPONENT32F;
              } else if (texture.type === UnsignedIntType) {
                glInternalFormat = _gl.DEPTH_COMPONENT24;
              } else if (texture.type === UnsignedInt248Type) {
                glInternalFormat = _gl.DEPTH24_STENCIL8;
              } else {
                glInternalFormat = _gl.DEPTH_COMPONENT16;
              }
            } else {
              if (texture.type === FloatType) {
                console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
              }
            }
            if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
              if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                texture.type = UnsignedShortType;
                glType = utils.convert(texture.type);
              }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
              glInternalFormat = _gl.DEPTH_STENCIL;
              if (texture.type !== UnsignedInt248Type) {
                console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                texture.type = UnsignedInt248Type;
                glType = utils.convert(texture.type);
              }
            }
            state2.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          } else if (texture.isDataTexture) {
            if (mipmaps.length > 0 && supportsMips) {
              for (let i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                state2.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
              texture.generateMipmaps = false;
              textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
              state2.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
              textureProperties.__maxMipLevel = 0;
            }
          } else if (texture.isCompressedTexture) {
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (glFormat !== null) {
                  state2.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                state2.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else if (texture.isDataTexture2DArray) {
            state2.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
          } else if (texture.isDataTexture3D) {
            state2.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
          } else {
            if (mipmaps.length > 0 && supportsMips) {
              for (let i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                state2.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
              }
              texture.generateMipmaps = false;
              textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
              state2.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
              textureProperties.__maxMipLevel = 0;
            }
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(textureType, texture, image.width, image.height);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function uploadCubeTexture(textureProperties, texture, slot) {
          if (texture.image.length !== 6)
            return;
          initTexture(textureProperties, texture);
          state2.activeTexture(_gl.TEXTURE0 + slot);
          state2.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
          const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
          const cubeImage = [];
          for (let i = 0; i < 6; i++) {
            if (!isCompressed && !isDataTexture) {
              cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
            } else {
              cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
            }
          }
          const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
          let mipmaps;
          if (isCompressed) {
            for (let i = 0; i < 6; i++) {
              mipmaps = cubeImage[i].mipmaps;
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                  if (glFormat !== null) {
                    state2.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                  }
                } else {
                  state2.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            mipmaps = texture.mipmaps;
            for (let i = 0; i < 6; i++) {
              if (isDataTexture) {
                state2.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  const mipmapImage = mipmap.image[i].image;
                  state2.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              } else {
                state2.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  state2.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                }
              }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
            state2.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
          } else {
            state2.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
          }
          state2.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
          state2.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample) {
              const depthTexture = renderTarget.depthTexture;
              if (depthTexture && depthTexture.isDepthTexture) {
                if (depthTexture.type === FloatType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (depthTexture.type === UnsignedIntType) {
                  glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
              }
              const samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
              const samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else {
            const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
            const glFormat = utils.convert(texture.format);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            if (isMultisample) {
              const samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
          const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
          if (isCube)
            throw new Error("Depth Texture with cube render targets is not supported");
          state2.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
          }
          setTexture2D(renderTarget.depthTexture, 0);
          const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
          if (renderTarget.depthTexture.format === DepthFormat) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
          } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
          } else {
            throw new Error("Unknown depthTexture format");
          }
        }
        function setupDepthRenderbuffer(renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          if (renderTarget.depthTexture) {
            if (isCube)
              throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
          } else {
            if (isCube) {
              renderTargetProperties.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++) {
                state2.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
              }
            } else {
              state2.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
          }
          state2.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          renderTarget.addEventListener("dispose", onRenderTargetDispose);
          if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            textureProperties.__webglTexture = _gl.createTexture();
            textureProperties.__version = texture.version;
            info.memory.textures++;
          }
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
          const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
          const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
            texture.format = RGBAFormat;
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
          }
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (let i = 0; i < 6; i++) {
              renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
              if (capabilities.drawBuffers) {
                const textures = renderTarget.texture;
                for (let i = 0, il = textures.length; i < il; i++) {
                  const attachmentProperties = properties.get(textures[i]);
                  if (attachmentProperties.__webglTexture === void 0) {
                    attachmentProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                  }
                }
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
              }
            } else if (isMultisample) {
              if (isWebGL2) {
                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                const glFormat = utils.convert(texture.format);
                const glType = utils.convert(texture.type);
                const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                state2.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                if (renderTarget.depthBuffer) {
                  renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                }
                state2.bindFramebuffer(_gl.FRAMEBUFFER, null);
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
              }
            }
          }
          if (isCube) {
            state2.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            for (let i = 0; i < 6; i++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);
            }
            state2.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
          } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for (let i = 0, il = textures.length; i < il; i++) {
              const attachment = textures[i];
              const attachmentProperties = properties.get(attachment);
              state2.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
              setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);
              if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
                generateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);
              }
            }
            state2.bindTexture(_gl.TEXTURE_2D, null);
          } else {
            let glTextureType = _gl.TEXTURE_2D;
            if (isRenderTarget3D) {
              if (isWebGL2) {
                const isTexture3D = texture.isDataTexture3D;
                glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
              } else {
                console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
              }
            }
            state2.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height);
            }
            state2.bindTexture(_gl.TEXTURE_2D, null);
          }
          if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function updateRenderTargetMipmap(renderTarget) {
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
          for (let i = 0, il = textures.length; i < il; i++) {
            const texture = textures[i];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
              const webglTexture = properties.get(texture).__webglTexture;
              state2.bindTexture(target, webglTexture);
              generateMipmap(target, texture, renderTarget.width, renderTarget.height);
              state2.bindTexture(target, null);
            }
          }
        }
        function updateMultisampleRenderTarget(renderTarget) {
          if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
              const width = renderTarget.width;
              const height = renderTarget.height;
              let mask = _gl.COLOR_BUFFER_BIT;
              if (renderTarget.depthBuffer)
                mask |= _gl.DEPTH_BUFFER_BIT;
              if (renderTarget.stencilBuffer)
                mask |= _gl.STENCIL_BUFFER_BIT;
              const renderTargetProperties = properties.get(renderTarget);
              state2.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              state2.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
              state2.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
              state2.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          }
        }
        function getRenderTargetSamples(renderTarget) {
          return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
        }
        function updateVideoTexture(texture) {
          const frame = info.render.frame;
          if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
          }
        }
        let warnedTexture2D = false;
        let warnedTextureCube = false;
        function safeSetTexture2D(texture, slot) {
          if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
              console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
              warnedTexture2D = true;
            }
            texture = texture.texture;
          }
          setTexture2D(texture, slot);
        }
        function safeSetTextureCube(texture, slot) {
          if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
              console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
              warnedTextureCube = true;
            }
            texture = texture.texture;
          }
          setTextureCube(texture, slot);
        }
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
      }
      function WebGLUtils(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function convert(p) {
          let extension;
          if (p === UnsignedByteType)
            return gl.UNSIGNED_BYTE;
          if (p === UnsignedShort4444Type)
            return gl.UNSIGNED_SHORT_4_4_4_4;
          if (p === UnsignedShort5551Type)
            return gl.UNSIGNED_SHORT_5_5_5_1;
          if (p === UnsignedShort565Type)
            return gl.UNSIGNED_SHORT_5_6_5;
          if (p === ByteType)
            return gl.BYTE;
          if (p === ShortType)
            return gl.SHORT;
          if (p === UnsignedShortType)
            return gl.UNSIGNED_SHORT;
          if (p === IntType)
            return gl.INT;
          if (p === UnsignedIntType)
            return gl.UNSIGNED_INT;
          if (p === FloatType)
            return gl.FLOAT;
          if (p === HalfFloatType) {
            if (isWebGL2)
              return gl.HALF_FLOAT;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) {
              return extension.HALF_FLOAT_OES;
            } else {
              return null;
            }
          }
          if (p === AlphaFormat)
            return gl.ALPHA;
          if (p === RGBFormat)
            return gl.RGB;
          if (p === RGBAFormat)
            return gl.RGBA;
          if (p === LuminanceFormat)
            return gl.LUMINANCE;
          if (p === LuminanceAlphaFormat)
            return gl.LUMINANCE_ALPHA;
          if (p === DepthFormat)
            return gl.DEPTH_COMPONENT;
          if (p === DepthStencilFormat)
            return gl.DEPTH_STENCIL;
          if (p === RedFormat)
            return gl.RED;
          if (p === RedIntegerFormat)
            return gl.RED_INTEGER;
          if (p === RGFormat)
            return gl.RG;
          if (p === RGIntegerFormat)
            return gl.RG_INTEGER;
          if (p === RGBIntegerFormat)
            return gl.RGB_INTEGER;
          if (p === RGBAIntegerFormat)
            return gl.RGBA_INTEGER;
          if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get("WEBGL_compressed_texture_s3tc");
            if (extension !== null) {
              if (p === RGB_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (p === RGBA_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (p === RGBA_S3TC_DXT3_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (p === RGBA_S3TC_DXT5_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else {
              return null;
            }
          }
          if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
              if (p === RGB_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (p === RGB_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (p === RGBA_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (p === RGBA_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) {
              return extension.COMPRESSED_RGB_ETC1_WEBGL;
            } else {
              return null;
            }
          }
          if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
              if (p === RGB_ETC2_Format)
                return extension.COMPRESSED_RGB8_ETC2;
              if (p === RGBA_ETC2_EAC_Format)
                return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
          }
          if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
              return p;
            } else {
              return null;
            }
          }
          if (p === RGBA_BPTC_Format) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
              return p;
            } else {
              return null;
            }
          }
          if (p === UnsignedInt248Type) {
            if (isWebGL2)
              return gl.UNSIGNED_INT_24_8;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) {
              return extension.UNSIGNED_INT_24_8_WEBGL;
            } else {
              return null;
            }
          }
        }
        return {
          convert
        };
      }
      class ArrayCamera extends PerspectiveCamera2 {
        constructor(array = []) {
          super();
          this.cameras = array;
        }
      }
      ArrayCamera.prototype.isArrayCamera = true;
      class Group2 extends Object3D {
        constructor() {
          super();
          this.type = "Group";
        }
      }
      Group2.prototype.isGroup = true;
      const _moveEvent = {
        type: "move"
      };
      class WebXRController {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group2();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
              pinching: false
            };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group2();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group2();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({
            type: "disconnected",
            data: inputSource
          });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                if (hand.joints[inputjoint.jointName] === void 0) {
                  const joint2 = new Group2();
                  joint2.matrixAutoUpdate = false;
                  joint2.visible = false;
                  hand.joints[inputjoint.jointName] = joint2;
                  hand.add(joint2);
                }
                const joint = hand.joints[inputjoint.jointName];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
      }
      class WebXRManager extends EventDispatcher {
        constructor(renderer, gl) {
          super();
          const scope = this;
          const state2 = renderer.state;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          let pose = null;
          let glBinding = null;
          let glFramebuffer = null;
          let glProjLayer = null;
          const controllers = [];
          const inputSourcesMap = new Map();
          const cameraL = new PerspectiveCamera2();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera2();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index2) {
            let controller = controllers[index2];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index2] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index2) {
            let controller = controllers[index2];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index2] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index2) {
            let controller = controllers[index2];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index2] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
              controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
              });
            }
          }
          function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
              controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            state2.bindXRFramebuffer(null);
            renderer.setRenderTarget(renderer.getRenderTarget());
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return referenceSpace;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              const attributes = gl.getContextAttributes();
              if (attributes.xrCompatible !== true) {
                await gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0) {
                const layerInit = {
                  antialias: attributes.antialias,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                const baseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({
                  baseLayer
                });
              } else {
                let depthFormat = 0;
                if (attributes.depth) {
                  depthFormat = attributes.stencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
                }
                const projectionlayerInit = {
                  colorFormat: attributes.alpha ? gl.RGBA : gl.RGB,
                  depthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                glFramebuffer = gl.createFramebuffer();
                session.updateRenderState({
                  layers: [glProjLayer]
                });
              }
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            for (let i = 0; i < controllers.length; i++) {
              inputSourcesMap.set(inputSources[i], controllers[i]);
            }
            for (let i = 0; i < event.removed.length; i++) {
              const inputSource = event.removed[i];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "disconnected",
                  data: inputSource
                });
                inputSourcesMap.delete(inputSource);
              }
            }
            for (let i = 0; i < event.added.length; i++) {
              const inputSource = event.added[i];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "connected",
                  data: inputSource
                });
              }
            }
          }
          const cameraLPos = new Vector3();
          const cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i = 0; i < cameras2.length; i++) {
              updateCamera(cameras2[i], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for (let i = 0, l = children.length; i < l; i++) {
              children[i].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            if (pose !== null) {
              const views = pose.views;
              const baseLayer = session.renderState.baseLayer;
              if (session.renderState.layers === void 0) {
                state2.bindXRFramebuffer(baseLayer.framebuffer);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i = 0; i < views.length; i++) {
                const view = views[i];
                let viewport = null;
                if (session.renderState.layers === void 0) {
                  viewport = baseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, glFramebuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
                  if (glSubImage.depthStencilTexture !== void 0) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0);
                  }
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                  state2.bindXRFramebuffer(glFramebuffer);
                  viewport = glSubImage.viewport;
                }
                const camera = cameras[i];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            const inputSources = session.inputSources;
            for (let i = 0; i < controllers.length; i++) {
              const controller = controllers[i];
              const inputSource = inputSources[i];
              controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      }
      function WebGLMaterials(properties) {
        function refreshFogUniforms(uniforms, fog) {
          uniforms.fogColor.value.copy(fog.color);
          if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
          } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
          }
        }
        function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
          if (material.isMeshBasicMaterial) {
            refreshUniformsCommon(uniforms, material);
          } else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
          } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
          } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
          } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) {
              refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
            } else {
              refreshUniformsStandard(uniforms, material);
            }
          } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
          } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
          } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
          } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
          } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) {
              refreshUniformsDash(uniforms, material);
            }
          } else if (material.isPointsMaterial) {
            refreshUniformsPoints(uniforms, material, pixelRatio, height);
          } else if (material.isSpriteMaterial) {
            refreshUniformsSprites(uniforms, material);
          } else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
          } else if (material.isShaderMaterial) {
            material.uniformsNeedUpdate = false;
          }
        }
        function refreshUniformsCommon(uniforms, material) {
          uniforms.opacity.value = material.opacity;
          if (material.color) {
            uniforms.diffuse.value.copy(material.color);
          }
          if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
          }
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.specularMap) {
            uniforms.specularMap.value = material.specularMap;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== void 0) {
              uniforms.maxMipLevel.value = maxMipLevel;
            }
          }
          if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
          }
          if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
          } else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
          } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
          } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
          } else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
          } else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          } else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
          } else if (material.clearcoatMap) {
            uvScaleMap = material.clearcoatMap;
          } else if (material.clearcoatNormalMap) {
            uvScaleMap = material.clearcoatNormalMap;
          } else if (material.clearcoatRoughnessMap) {
            uvScaleMap = material.clearcoatRoughnessMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.isWebGLRenderTarget) {
              uvScaleMap = uvScaleMap.texture;
            }
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
          let uv2ScaleMap;
          if (material.aoMap) {
            uv2ScaleMap = material.aoMap;
          } else if (material.lightMap) {
            uv2ScaleMap = material.lightMap;
          }
          if (uv2ScaleMap !== void 0) {
            if (uv2ScaleMap.isWebGLRenderTarget) {
              uv2ScaleMap = uv2ScaleMap.texture;
            }
            if (uv2ScaleMap.matrixAutoUpdate === true) {
              uv2ScaleMap.updateMatrix();
            }
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
          }
        }
        function refreshUniformsLine(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
          uniforms.dashSize.value = material.dashSize;
          uniforms.totalSize.value = material.dashSize + material.gapSize;
          uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.size.value = material.size * pixelRatio;
          uniforms.scale.value = height * 0.5;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsSprites(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.rotation.value = material.rotation;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsLambert(uniforms, material) {
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
        }
        function refreshUniformsPhong(uniforms, material) {
          uniforms.specular.value.copy(material.specular);
          uniforms.shininess.value = Math.max(material.shininess, 1e-4);
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsToon(uniforms, material) {
          if (material.gradientMap) {
            uniforms.gradientMap.value = material.gradientMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsStandard(uniforms, material) {
          uniforms.roughness.value = material.roughness;
          uniforms.metalness.value = material.metalness;
          if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
          }
          if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMapIntensity.value = material.envMapIntensity;
          }
        }
        function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
          refreshUniformsStandard(uniforms, material);
          uniforms.reflectivity.value = material.reflectivity;
          uniforms.clearcoat.value = material.clearcoat;
          uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
          if (material.sheen)
            uniforms.sheen.value.copy(material.sheen);
          if (material.clearcoatMap) {
            uniforms.clearcoatMap.value = material.clearcoatMap;
          }
          if (material.clearcoatRoughnessMap) {
            uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
          }
          if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) {
              uniforms.clearcoatNormalScale.value.negate();
            }
          }
          uniforms.transmission.value = material.transmission;
          if (material.transmissionMap) {
            uniforms.transmissionMap.value = material.transmissionMap;
          }
          if (material.transmission > 0) {
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
          }
          uniforms.thickness.value = material.thickness;
          if (material.thicknessMap) {
            uniforms.thicknessMap.value = material.thicknessMap;
          }
          uniforms.attenuationDistance.value = material.attenuationDistance;
          uniforms.attenuationColor.value.copy(material.attenuationColor);
        }
        function refreshUniformsMatcap(uniforms, material) {
          if (material.matcap) {
            uniforms.matcap.value = material.matcap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDepth(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDistance(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          uniforms.referencePosition.value.copy(material.referencePosition);
          uniforms.nearDistance.value = material.nearDistance;
          uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        return {
          refreshFogUniforms,
          refreshMaterialUniforms
        };
      }
      function createCanvasElement() {
        const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        canvas.style.display = "block";
        return canvas;
      }
      function WebGLRenderer2(parameters = {}) {
        const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
        let currentRenderList = null;
        let currentRenderState = null;
        const renderListStack = [];
        const renderStateStack = [];
        this.domElement = _canvas2;
        this.debug = {
          checkShaderErrors: true
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.gammaFactor = 2;
        this.outputEncoding = LinearEncoding;
        this.physicallyCorrectLights = false;
        this.toneMapping = NoToneMapping;
        this.toneMappingExposure = 1;
        const _this = this;
        let _isContextLost = false;
        let _currentActiveCubeFace = 0;
        let _currentActiveMipmapLevel = 0;
        let _currentRenderTarget = null;
        let _currentMaterialId = -1;
        let _currentCamera = null;
        const _currentViewport = new Vector4();
        const _currentScissor = new Vector4();
        let _currentScissorTest = null;
        let _width = _canvas2.width;
        let _height = _canvas2.height;
        let _pixelRatio = 1;
        let _opaqueSort = null;
        let _transparentSort = null;
        const _viewport = new Vector4(0, 0, _width, _height);
        const _scissor = new Vector4(0, 0, _width, _height);
        let _scissorTest = false;
        const _currentDrawBuffers = [];
        const _frustum = new Frustum();
        let _clippingEnabled = false;
        let _localClippingEnabled = false;
        let _transmissionRenderTarget = null;
        const _projScreenMatrix2 = new Matrix4();
        const _vector3 = new Vector3();
        const _emptyScene = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        function getTargetPixelRatio() {
          return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        let _gl = _context2;
        function getContext2(contextNames, contextAttributes) {
          for (let i = 0; i < contextNames.length; i++) {
            const contextName = contextNames[i];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null)
              return context;
          }
          return null;
        }
        try {
          const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
          };
          _canvas2.addEventListener("webglcontextlost", onContextLost, false);
          _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
          if (_gl === null) {
            const contextNames = ["webgl2", "webgl", "experimental-webgl"];
            if (_this.isWebGL1Renderer === true) {
              contextNames.shift();
            }
            _gl = getContext2(contextNames, contextAttributes);
            if (_gl === null) {
              if (getContext2(contextNames)) {
                throw new Error("Error creating WebGL context with your selected attributes.");
              } else {
                throw new Error("Error creating WebGL context.");
              }
            }
          }
          if (_gl.getShaderPrecisionFormat === void 0) {
            _gl.getShaderPrecisionFormat = function() {
              return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
              };
            };
          }
        } catch (error2) {
          console.error("THREE.WebGLRenderer: " + error2.message);
          throw error2;
        }
        let extensions, capabilities, state2, info;
        let properties, textures, cubemaps, attributes, geometries, objects;
        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
        let utils, bindingStates;
        function initGLContext() {
          extensions = new WebGLExtensions(_gl);
          capabilities = new WebGLCapabilities(_gl, extensions, parameters);
          extensions.init(capabilities);
          utils = new WebGLUtils(_gl, extensions, capabilities);
          state2 = new WebGLState(_gl, extensions, capabilities);
          _currentDrawBuffers[0] = _gl.BACK;
          info = new WebGLInfo(_gl);
          properties = new WebGLProperties();
          textures = new WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info);
          cubemaps = new WebGLCubeMaps(_this);
          attributes = new WebGLAttributes(_gl, capabilities);
          bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
          geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets(_gl);
          clipping = new WebGLClipping(properties);
          programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
          materials = new WebGLMaterials(properties);
          renderLists = new WebGLRenderLists(properties);
          renderStates = new WebGLRenderStates(extensions, capabilities);
          background = new WebGLBackground(_this, cubemaps, state2, objects, _premultipliedAlpha);
          shadowMap = new WebGLShadowMap(_this, objects, capabilities);
          bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
          info.programs = programCache.programs;
          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.shadowMap = shadowMap;
          _this.state = state2;
          _this.info = info;
        }
        initGLContext();
        const xr = new WebXRManager(_this, _gl);
        this.xr = xr;
        this.getContext = function() {
          return _gl;
        };
        this.getContextAttributes = function() {
          return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.loseContext();
        };
        this.forceContextRestore = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.restoreContext();
        };
        this.getPixelRatio = function() {
          return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
          if (value === void 0)
            return;
          _pixelRatio = value;
          this.setSize(_width, _height, false);
        };
        this.getSize = function(target) {
          return target.set(_width, _height);
        };
        this.setSize = function(width, height, updateStyle) {
          if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          _width = width;
          _height = height;
          _canvas2.width = Math.floor(width * _pixelRatio);
          _canvas2.height = Math.floor(height * _pixelRatio);
          if (updateStyle !== false) {
            _canvas2.style.width = width + "px";
            _canvas2.style.height = height + "px";
          }
          this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target) {
          return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
          _width = width;
          _height = height;
          _pixelRatio = pixelRatio;
          _canvas2.width = Math.floor(width * pixelRatio);
          _canvas2.height = Math.floor(height * pixelRatio);
          this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target) {
          return target.copy(_currentViewport);
        };
        this.getViewport = function(target) {
          return target.copy(_viewport);
        };
        this.setViewport = function(x, y, width, height) {
          if (x.isVector4) {
            _viewport.set(x.x, x.y, x.z, x.w);
          } else {
            _viewport.set(x, y, width, height);
          }
          state2.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function(target) {
          return target.copy(_scissor);
        };
        this.setScissor = function(x, y, width, height) {
          if (x.isVector4) {
            _scissor.set(x.x, x.y, x.z, x.w);
          } else {
            _scissor.set(x, y, width, height);
          }
          state2.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function() {
          return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
          state2.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
          _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
          _transparentSort = method;
        };
        this.getClearColor = function(target) {
          return target.copy(background.getClearColor());
        };
        this.setClearColor = function() {
          background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
          return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
          background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color, depth, stencil) {
          let bits = 0;
          if (color === void 0 || color)
            bits |= _gl.COLOR_BUFFER_BIT;
          if (depth === void 0 || depth)
            bits |= _gl.DEPTH_BUFFER_BIT;
          if (stencil === void 0 || stencil)
            bits |= _gl.STENCIL_BUFFER_BIT;
          _gl.clear(bits);
        };
        this.clearColor = function() {
          this.clear(true, false, false);
        };
        this.clearDepth = function() {
          this.clear(false, true, false);
        };
        this.clearStencil = function() {
          this.clear(false, false, true);
        };
        this.dispose = function() {
          _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
          _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          cubemaps.dispose();
          objects.dispose();
          bindingStates.dispose();
          xr.dispose();
          xr.removeEventListener("sessionstart", onXRSessionStart);
          xr.removeEventListener("sessionend", onXRSessionEnd);
          if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
          }
          animation.stop();
        };
        function onContextLost(event) {
          event.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          _isContextLost = true;
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          _isContextLost = false;
          const infoAutoReset = info.autoReset;
          const shadowMapEnabled = shadowMap.enabled;
          const shadowMapAutoUpdate = shadowMap.autoUpdate;
          const shadowMapNeedsUpdate = shadowMap.needsUpdate;
          const shadowMapType = shadowMap.type;
          initGLContext();
          info.autoReset = infoAutoReset;
          shadowMap.enabled = shadowMapEnabled;
          shadowMap.autoUpdate = shadowMapAutoUpdate;
          shadowMap.needsUpdate = shadowMapNeedsUpdate;
          shadowMap.type = shadowMapType;
        }
        function onMaterialDispose(event) {
          const material = event.target;
          material.removeEventListener("dispose", onMaterialDispose);
          deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
          releaseMaterialProgramReferences(material);
          properties.remove(material);
        }
        function releaseMaterialProgramReferences(material) {
          const programs = properties.get(material).programs;
          if (programs !== void 0) {
            programs.forEach(function(program) {
              programCache.releaseProgram(program);
            });
          }
        }
        function renderObjectImmediate(object, program) {
          object.render(function(object2) {
            _this.renderBufferImmediate(object2, program);
          });
        }
        this.renderBufferImmediate = function(object, program) {
          bindingStates.initAttributes();
          const buffers = properties.get(object);
          if (object.hasPositions && !buffers.position)
            buffers.position = _gl.createBuffer();
          if (object.hasNormals && !buffers.normal)
            buffers.normal = _gl.createBuffer();
          if (object.hasUvs && !buffers.uv)
            buffers.uv = _gl.createBuffer();
          if (object.hasColors && !buffers.color)
            buffers.color = _gl.createBuffer();
          const programAttributes = program.getAttributes();
          if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
          }
          if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
          }
          if (object.hasUvs) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
          }
          if (object.hasColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
          }
          bindingStates.disableUnusedAttributes();
          _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
          object.count = 0;
        };
        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
          if (scene === null)
            scene = _emptyScene;
          const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
          const program = setProgram(camera, scene, material, object);
          state2.setMaterial(material, frontFaceCW);
          let index2 = geometry.index;
          const position = geometry.attributes.position;
          if (index2 === null) {
            if (position === void 0 || position.count === 0)
              return;
          } else if (index2.count === 0) {
            return;
          }
          let rangeFactor = 1;
          if (material.wireframe === true) {
            index2 = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
          }
          if (material.morphTargets || material.morphNormals) {
            morphtargets.update(object, geometry, material, program);
          }
          bindingStates.setup(object, material, program, geometry, index2);
          let attribute;
          let renderer = bufferRenderer;
          if (index2 !== null) {
            attribute = attributes.get(index2);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
          }
          const dataCount = index2 !== null ? index2.count : position.count;
          const rangeStart = geometry.drawRange.start * rangeFactor;
          const rangeCount = geometry.drawRange.count * rangeFactor;
          const groupStart = group !== null ? group.start * rangeFactor : 0;
          const groupCount = group !== null ? group.count * rangeFactor : Infinity;
          const drawStart = Math.max(rangeStart, groupStart);
          const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
          const drawCount = Math.max(0, drawEnd - drawStart + 1);
          if (drawCount === 0)
            return;
          if (object.isMesh) {
            if (material.wireframe === true) {
              state2.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
              renderer.setMode(_gl.LINES);
            } else {
              renderer.setMode(_gl.TRIANGLES);
            }
          } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === void 0)
              lineWidth = 1;
            state2.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
              renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
              renderer.setMode(_gl.LINE_LOOP);
            } else {
              renderer.setMode(_gl.LINE_STRIP);
            }
          } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
          } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
          } else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
          } else {
            renderer.render(drawStart, drawCount);
          }
        };
        this.compile = function(scene, camera) {
          currentRenderState = renderStates.get(scene);
          currentRenderState.init();
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
          currentRenderState.setupLights();
          scene.traverse(function(object) {
            const material = object.material;
            if (material) {
              if (Array.isArray(material)) {
                for (let i = 0; i < material.length; i++) {
                  const material2 = material[i];
                  getProgram(material2, scene, object);
                }
              } else {
                getProgram(material, scene, object);
              }
            }
          });
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time);
        }
        function onXRSessionStart() {
          animation.stop();
        }
        function onXRSessionEnd() {
          animation.start();
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== "undefined")
          animation.setContext(window);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
          xr.setAnimationLoop(callback);
          callback === null ? animation.stop() : animation.start();
        };
        xr.addEventListener("sessionstart", onXRSessionStart);
        xr.addEventListener("sessionend", onXRSessionEnd);
        this.render = function(scene, camera) {
          if (camera !== void 0 && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (_isContextLost === true)
            return;
          if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
          if (camera.parent === null)
            camera.updateMatrixWorld();
          if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true)
              xr.updateCamera(camera);
            camera = xr.getCamera();
          }
          if (scene.isScene === true)
            scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
          currentRenderState = renderStates.get(scene, renderStateStack.length);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum.setFromProjectionMatrix(_projScreenMatrix2);
          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
          currentRenderList = renderLists.get(scene, renderListStack.length);
          currentRenderList.init();
          renderListStack.push(currentRenderList);
          projectObject(scene, camera, 0, _this.sortObjects);
          currentRenderList.finish();
          if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
          }
          if (_clippingEnabled === true)
            clipping.beginShadows();
          const shadowsArray = currentRenderState.state.shadowsArray;
          shadowMap.render(shadowsArray, scene, camera);
          currentRenderState.setupLights();
          currentRenderState.setupLightsView(camera);
          if (_clippingEnabled === true)
            clipping.endShadows();
          if (this.info.autoReset === true)
            this.info.reset();
          background.render(currentRenderList, scene);
          const opaqueObjects = currentRenderList.opaque;
          const transmissiveObjects = currentRenderList.transmissive;
          const transparentObjects = currentRenderList.transparent;
          if (opaqueObjects.length > 0)
            renderObjects(opaqueObjects, scene, camera);
          if (transmissiveObjects.length > 0)
            renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
          if (transparentObjects.length > 0)
            renderObjects(transparentObjects, scene, camera);
          if (_currentRenderTarget !== null) {
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            textures.updateRenderTargetMipmap(_currentRenderTarget);
          }
          if (scene.isScene === true)
            scene.onAfterRender(_this, scene, camera);
          state2.buffers.depth.setTest(true);
          state2.buffers.depth.setMask(true);
          state2.buffers.color.setMask(true);
          state2.setPolygonOffset(false);
          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;
          renderStateStack.pop();
          if (renderStateStack.length > 0) {
            currentRenderState = renderStateStack[renderStateStack.length - 1];
          } else {
            currentRenderState = null;
          }
          renderListStack.pop();
          if (renderListStack.length > 0) {
            currentRenderList = renderListStack[renderListStack.length - 1];
          } else {
            currentRenderList = null;
          }
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible) {
            if (object.isGroup) {
              groupOrder = object.renderOrder;
            } else if (object.isLOD) {
              if (object.autoUpdate === true)
                object.update(camera);
            } else if (object.isLight) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            } else if (object.isSprite) {
              if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            } else if (object.isImmediateRenderObject) {
              if (sortObjects) {
                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
              }
              currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
              if (object.isSkinnedMesh) {
                if (object.skeleton.frame !== info.render.frame) {
                  object.skeleton.update();
                  object.skeleton.frame = info.render.frame;
                }
              }
              if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                  const groups = geometry.groups;
                  for (let i = 0, l = groups.length; i < l; i++) {
                    const group = groups[i];
                    const groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                    }
                  }
                } else if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            }
          }
          const children = object.children;
          for (let i = 0, l = children.length; i < l; i++) {
            projectObject(children[i], camera, groupOrder, sortObjects);
          }
        }
        function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
          if (_transmissionRenderTarget === null) {
            const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
            const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
            _transmissionRenderTarget = new renderTargetType(1024, 1024, {
              generateMipmaps: true,
              type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
              minFilter: LinearMipmapLinearFilter,
              magFilter: NearestFilter,
              wrapS: ClampToEdgeWrapping,
              wrapT: ClampToEdgeWrapping
            });
          }
          const currentRenderTarget = _this.getRenderTarget();
          _this.setRenderTarget(_transmissionRenderTarget);
          _this.clear();
          const currentToneMapping = _this.toneMapping;
          _this.toneMapping = NoToneMapping;
          renderObjects(opaqueObjects, scene, camera);
          _this.toneMapping = currentToneMapping;
          textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
          textures.updateRenderTargetMipmap(_transmissionRenderTarget);
          _this.setRenderTarget(currentRenderTarget);
          renderObjects(transmissiveObjects, scene, camera);
        }
        function renderObjects(renderList, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          for (let i = 0, l = renderList.length; i < l; i++) {
            const renderItem = renderList[i];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
              const cameras = camera.cameras;
              for (let j = 0, jl = cameras.length; j < jl; j++) {
                const camera2 = cameras[j];
                if (object.layers.test(camera2.layers)) {
                  state2.viewport(_currentViewport.copy(camera2.viewport));
                  currentRenderState.setupLightsView(camera2);
                  renderObject(object, scene, camera2, geometry, material, group);
                }
              }
            } else {
              renderObject(object, scene, camera, geometry, material, group);
            }
          }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
          object.onBeforeRender(_this, scene, camera, geometry, material, group);
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state2.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
          } else {
            if (material.transparent === true && material.side === DoubleSide2) {
              material.side = BackSide;
              material.needsUpdate = true;
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
              material.side = FrontSide;
              material.needsUpdate = true;
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
              material.side = DoubleSide2;
            } else {
              _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            }
          }
          object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function getProgram(material, scene, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;
          const lightsStateVersion = lights.state.version;
          const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters2);
          let programs = materialProperties.programs;
          materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;
          materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
          if (programs === void 0) {
            material.addEventListener("dispose", onMaterialDispose);
            programs = new Map();
            materialProperties.programs = programs;
          }
          let program = programs.get(programCacheKey);
          if (program !== void 0) {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
              updateCommonMaterialProperties(material, parameters2);
              return program;
            }
          } else {
            parameters2.uniforms = programCache.getUniforms(material);
            material.onBuild(parameters2, _this);
            material.onBeforeCompile(parameters2, _this);
            program = programCache.acquireProgram(parameters2, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters2.uniforms;
          }
          const uniforms = materialProperties.uniforms;
          if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            uniforms.clippingPlanes = clipping.uniform;
          }
          updateCommonMaterialProperties(material, parameters2);
          materialProperties.needsLights = materialNeedsLights(material);
          materialProperties.lightsStateVersion = lightsStateVersion;
          if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
          }
          const progUniforms = program.getUniforms();
          const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
          materialProperties.currentProgram = program;
          materialProperties.uniformsList = uniformsList;
          return program;
        }
        function updateCommonMaterialProperties(material, parameters2) {
          const materialProperties = properties.get(material);
          materialProperties.outputEncoding = parameters2.outputEncoding;
          materialProperties.instancing = parameters2.instancing;
          materialProperties.skinning = parameters2.skinning;
          materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
          materialProperties.numIntersection = parameters2.numClipIntersection;
          materialProperties.vertexAlphas = parameters2.vertexAlphas;
        }
        function setProgram(camera, scene, material, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          textures.resetTextureUnits();
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
          const envMap = cubemaps.get(material.envMap || environment);
          const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
              const useCache = camera === _currentCamera && material.id === _currentMaterialId;
              clipping.setState(material, camera, useCache);
            }
          }
          let needsProgramChange = false;
          if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
              needsProgramChange = true;
            } else if (materialProperties.outputEncoding !== encoding) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
              needsProgramChange = true;
            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
              needsProgramChange = true;
            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
              needsProgramChange = true;
            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
              needsProgramChange = true;
            } else if (materialProperties.envMap !== envMap) {
              needsProgramChange = true;
            } else if (material.fog && materialProperties.fog !== fog) {
              needsProgramChange = true;
            } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
              needsProgramChange = true;
            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
              needsProgramChange = true;
            }
          } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
          }
          let program = materialProperties.currentProgram;
          if (needsProgramChange === true) {
            program = getProgram(material, scene, object);
          }
          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;
          const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
          if (state2.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
          }
          if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) {
              p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (_currentCamera !== camera) {
              _currentCamera = camera;
              refreshMaterial = true;
              refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
              const uCamPos = p_uniforms.map.cameraPosition;
              if (uCamPos !== void 0) {
                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
              }
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
              p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
          }
          if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
              if (capabilities.floatVertexTextures) {
                if (skeleton.boneTexture === null)
                  skeleton.computeBoneTexture();
                p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
              } else {
                p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
              }
            }
          }
          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
          }
          if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
              markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog) {
              materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          }
          if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
          }
          if (material.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
          }
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
          p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
          return program;
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;
          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
          return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        }
        this.getActiveCubeFace = function() {
          return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
          return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function() {
          return _currentRenderTarget;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;
          if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
            textures.setupRenderTarget(renderTarget);
          }
          let framebuffer = null;
          let isCube = false;
          let isRenderTarget3D = false;
          if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
              isRenderTarget3D = true;
            }
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
              framebuffer = __webglFramebuffer[activeCubeFace];
              isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) {
              framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
              framebuffer = __webglFramebuffer;
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
          } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
          }
          const framebufferBound = state2.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (framebufferBound && capabilities.drawBuffers) {
            let needsUpdate = false;
            if (renderTarget) {
              if (renderTarget.isWebGLMultipleRenderTargets) {
                const textures2 = renderTarget.texture;
                if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
                  for (let i = 0, il = textures2.length; i < il; i++) {
                    _currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
                  }
                  _currentDrawBuffers.length = textures2.length;
                  needsUpdate = true;
                }
              } else {
                if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
                  _currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
                  _currentDrawBuffers.length = 1;
                  needsUpdate = true;
                }
              }
            } else {
              if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
                _currentDrawBuffers[0] = _gl.BACK;
                _currentDrawBuffers.length = 1;
                needsUpdate = true;
              }
            }
            if (needsUpdate) {
              if (capabilities.isWebGL2) {
                _gl.drawBuffers(_currentDrawBuffers);
              } else {
                extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
              }
            }
          }
          state2.viewport(_currentViewport);
          state2.scissor(_currentScissor);
          state2.setScissorTest(_currentScissorTest);
          if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
          } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
          }
        };
        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state2.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
              if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                  _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                }
              } else {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state2.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        };
        this.copyFramebufferToTexture = function(position, texture, level = 0) {
          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          let glFormat = utils.convert(texture.format);
          if (capabilities.isWebGL2) {
            if (glFormat === _gl.RGB)
              glFormat = _gl.RGB8;
            if (glFormat === _gl.RGBA)
              glFormat = _gl.RGBA8;
          }
          textures.setTexture2D(texture, 0);
          _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);
          state2.unbindTexture();
        };
        this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
          const width = srcTexture.image.width;
          const height = srcTexture.image.height;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          textures.setTexture2D(dstTexture, 0);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
            }
          }
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(_gl.TEXTURE_2D);
          state2.unbindTexture();
        };
        this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
          if (_this.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
          }
          const width = sourceBox.max.x - sourceBox.min.x + 1;
          const height = sourceBox.max.y - sourceBox.min.y + 1;
          const depth = sourceBox.max.z - sourceBox.min.z + 1;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          let glTarget;
          if (dstTexture.isDataTexture3D) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = _gl.TEXTURE_3D;
          } else if (dstTexture.isDataTexture2DArray) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = _gl.TEXTURE_2D_ARRAY;
          } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
          }
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
          if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
            _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
              _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(glTarget);
          state2.unbindTexture();
        };
        this.initTexture = function(texture) {
          textures.setTexture2D(texture, 0);
          state2.unbindTexture();
        };
        this.resetState = function() {
          _currentActiveCubeFace = 0;
          _currentActiveMipmapLevel = 0;
          _currentRenderTarget = null;
          state2.reset();
          bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
      }
      class WebGL1Renderer extends WebGLRenderer2 {
      }
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      class FogExp2 {
        constructor(color, density = 25e-5) {
          this.name = "";
          this.color = new Color(color);
          this.density = density;
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      }
      FogExp2.prototype.isFogExp2 = true;
      class Fog {
        constructor(color, near = 1, far = 1e3) {
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      }
      Fog.prototype.isFog = true;
      class Scene2 extends Object3D {
        constructor() {
          super();
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.overrideMaterial = null;
          this.autoUpdate = true;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
              detail: this
            }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          return data;
        }
      }
      Scene2.prototype.isScene = true;
      class InterleavedBuffer {
        constructor(array, stride) {
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i = 0, l = this.stride; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      InterleavedBuffer.prototype.isInterleavedBuffer = true;
      const _vector$6 = /* @__PURE__ */ new Vector3();
      class InterleavedBufferAttribute {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized === true;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m) {
          for (let i = 0, l = this.data.count; i < l; i++) {
            _vector$6.x = this.getX(i);
            _vector$6.y = this.getY(i);
            _vector$6.z = this.getZ(i);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$6.x = this.getX(i);
            _vector$6.y = this.getY(i);
            _vector$6.z = this.getZ(i);
            _vector$6.applyNormalMatrix(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$6.x = this.getX(i);
            _vector$6.y = this.getY(i);
            _vector$6.z = this.getZ(i);
            _vector$6.transformDirection(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        setX(index2, x) {
          this.data.array[index2 * this.data.stride + this.offset] = x;
          return this;
        }
        setY(index2, y) {
          this.data.array[index2 * this.data.stride + this.offset + 1] = y;
          return this;
        }
        setZ(index2, z2) {
          this.data.array[index2 * this.data.stride + this.offset + 2] = z2;
          return this;
        }
        setW(index2, w) {
          this.data.array[index2 * this.data.stride + this.offset + 3] = w;
          return this;
        }
        getX(index2) {
          return this.data.array[index2 * this.data.stride + this.offset];
        }
        getY(index2) {
          return this.data.array[index2 * this.data.stride + this.offset + 1];
        }
        getZ(index2) {
          return this.data.array[index2 * this.data.stride + this.offset + 2];
        }
        getW(index2) {
          return this.data.array[index2 * this.data.stride + this.offset + 3];
        }
        setXY(index2, x, y) {
          index2 = index2 * this.data.stride + this.offset;
          this.data.array[index2 + 0] = x;
          this.data.array[index2 + 1] = y;
          return this;
        }
        setXYZ(index2, x, y, z2) {
          index2 = index2 * this.data.stride + this.offset;
          this.data.array[index2 + 0] = x;
          this.data.array[index2 + 1] = y;
          this.data.array[index2 + 2] = z2;
          return this;
        }
        setXYZW(index2, x, y, z2, w) {
          index2 = index2 * this.data.stride + this.offset;
          this.data.array[index2 + 0] = x;
          this.data.array[index2 + 1] = y;
          this.data.array[index2 + 2] = z2;
          this.data.array[index2 + 3] = w;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i = 0; i < this.count; i++) {
              const index2 = i * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index2 + j]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i = 0; i < this.count; i++) {
              const index2 = i * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index2 + j]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      }
      InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
      class SpriteMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "SpriteMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      }
      SpriteMaterial.prototype.isSpriteMaterial = true;
      let _geometry;
      const _intersectPoint = /* @__PURE__ */ new Vector3();
      const _worldScale = /* @__PURE__ */ new Vector3();
      const _mvPosition = /* @__PURE__ */ new Vector3();
      const _alignedPosition = /* @__PURE__ */ new Vector22();
      const _rotatedPosition = /* @__PURE__ */ new Vector22();
      const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
      const _vA = /* @__PURE__ */ new Vector3();
      const _vB = /* @__PURE__ */ new Vector3();
      const _vC = /* @__PURE__ */ new Vector3();
      const _uvA = /* @__PURE__ */ new Vector22();
      const _uvB = /* @__PURE__ */ new Vector22();
      const _uvC = /* @__PURE__ */ new Vector22();
      class Sprite extends Object3D {
        constructor(material) {
          super();
          this.type = "Sprite";
          if (_geometry === void 0) {
            _geometry = new BufferGeometry();
            const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry;
          this.material = material !== void 0 ? material : new SpriteMaterial();
          this.center = new Vector22(0.5, 0.5);
        }
        raycast(raycaster, intersects2) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
          }
          const rotation = this.material.rotation;
          let sin, cos;
          if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
          }
          const center = this.center;
          transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvA.set(0, 0);
          _uvB.set(1, 0);
          _uvC.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
          if (intersect === null) {
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector22()),
            face: null,
            object: this
          });
        }
        copy(source) {
          super.copy(source);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      }
      Sprite.prototype.isSprite = true;
      function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
        _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
        if (sin !== void 0) {
          _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
          _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
        } else {
          _rotatedPosition.copy(_alignedPosition);
        }
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
        vertexPosition.applyMatrix4(_viewWorldMatrix);
      }
      const _v1$2 = /* @__PURE__ */ new Vector3();
      const _v2$1 = /* @__PURE__ */ new Vector3();
      class LOD extends Object3D {
        constructor() {
          super();
          this._currentLevel = 0;
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: {
              enumerable: true,
              value: []
            },
            isLOD: {
              value: true
            }
          });
          this.autoUpdate = true;
        }
        copy(source) {
          super.copy(source, false);
          const levels = source.levels;
          for (let i = 0, l = levels.length; i < l; i++) {
            const level = levels[i];
            this.addLevel(level.object.clone(), level.distance);
          }
          this.autoUpdate = source.autoUpdate;
          return this;
        }
        addLevel(object, distance = 0) {
          distance = Math.abs(distance);
          const levels = this.levels;
          let l;
          for (l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
              break;
            }
          }
          levels.splice(l, 0, {
            distance,
            object
          });
          this.add(object);
          return this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(distance) {
          const levels = this.levels;
          if (levels.length > 0) {
            let i, l;
            for (i = 1, l = levels.length; i < l; i++) {
              if (distance < levels[i].distance) {
                break;
              }
            }
            return levels[i - 1].object;
          }
          return null;
        }
        raycast(raycaster, intersects2) {
          const levels = this.levels;
          if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects2);
          }
        }
        update(camera) {
          const levels = this.levels;
          if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i, l;
            for (i = 1, l = levels.length; i < l; i++) {
              if (distance >= levels[i].distance) {
                levels[i - 1].object.visible = false;
                levels[i].object.visible = true;
              } else {
                break;
              }
            }
            this._currentLevel = i - 1;
            for (; i < l; i++) {
              levels[i].object.visible = false;
            }
          }
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.autoUpdate === false)
            data.object.autoUpdate = false;
          data.object.levels = [];
          const levels = this.levels;
          for (let i = 0, l = levels.length; i < l; i++) {
            const level = levels[i];
            data.object.levels.push({
              object: level.object.uuid,
              distance: level.distance
            });
          }
          return data;
        }
      }
      const _basePosition = /* @__PURE__ */ new Vector3();
      const _skinIndex = /* @__PURE__ */ new Vector4();
      const _skinWeight = /* @__PURE__ */ new Vector4();
      const _vector$5 = /* @__PURE__ */ new Vector3();
      const _matrix = /* @__PURE__ */ new Matrix4();
      class SkinnedMesh extends Mesh2 {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
        }
        copy(source) {
          super.copy(source);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i = 0, l = skinWeight.count; i < l; i++) {
            vector.x = skinWeight.getX(i);
            vector.y = skinWeight.getY(i);
            vector.z = skinWeight.getZ(i);
            vector.w = skinWeight.getW(i);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) {
              vector.multiplyScalar(scale);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index2, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
          _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
          _basePosition.fromBufferAttribute(geometry.attributes.position, index2).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i = 0; i < 4; i++) {
            const weight = _skinWeight.getComponent(i);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i);
              _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      }
      SkinnedMesh.prototype.isSkinnedMesh = true;
      class Bone extends Object3D {
        constructor() {
          super();
          this.type = "Bone";
        }
      }
      Bone.prototype.isBone = true;
      class DataTexture extends Texture2 {
        constructor(data = null, width = 1, height = 1, format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this.image = {
            data,
            width,
            height
          };
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.needsUpdate = true;
        }
      }
      DataTexture.prototype.isDataTexture = true;
      const _offsetMatrix = /* @__PURE__ */ new Matrix4();
      const _identityMatrix = /* @__PURE__ */ new Matrix4();
      class Skeleton {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i = 0, il = this.bones.length; i < il; i++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const inverse = new Matrix4();
            if (this.bones[i]) {
              inverse.copy(this.bones[i].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i]).invert();
            }
          }
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i = 0, il = bones.length; i < il; i++) {
            const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
            _offsetMatrix.toArray(boneMatrices, i * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i = 0, l = json.bones.length; i < l; i++) {
            const uuid = json.bones[i];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i = 0, l = bones.length; i < l; i++) {
            const bone = bones[i];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      }
      const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      const _instanceIntersects = [];
      const _mesh = /* @__PURE__ */ new Mesh2();
      class InstancedMesh extends Mesh2 {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
        }
        copy(source) {
          super.copy(source);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index2, color) {
          color.fromArray(this.instanceColor.array, index2 * 3);
        }
        getMatrixAt(index2, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index2 * 16);
        }
        raycast(raycaster, intersects2) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
              const intersect = _instanceIntersects[i];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects2.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index2, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index2 * 3);
        }
        setMatrixAt(index2, matrix) {
          matrix.toArray(this.instanceMatrix.array, index2 * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      InstancedMesh.prototype.isInstancedMesh = true;
      class LineBasicMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.morphTargets = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          this.morphTargets = source.morphTargets;
          return this;
        }
      }
      LineBasicMaterial.prototype.isLineBasicMaterial = true;
      const _start$1 = /* @__PURE__ */ new Vector3();
      const _end$1 = /* @__PURE__ */ new Vector3();
      const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      const _ray$1 = /* @__PURE__ */ new Ray();
      const _sphere$1 = /* @__PURE__ */ new Sphere();
      class Line extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
          super();
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [0];
              for (let i = 1, l = positionAttribute.count; i < l; i++) {
                _start$1.fromBufferAttribute(positionAttribute, i - 1);
                _end$1.fromBufferAttribute(positionAttribute, i);
                lineDistances[i] = lineDistances[i - 1];
                lineDistances[i] += _start$1.distanceTo(_end$1);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$1.copy(geometry.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = this.isLineSegments ? 2 : 1;
          if (geometry.isBufferGeometry) {
            const index2 = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index2 !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index2.count, drawRange.start + drawRange.count);
              for (let i = start, l = end - 1; i < l; i += step) {
                const a = index2.getX(i);
                const b = index2.getX(i + 1);
                vStart.fromBufferAttribute(positionAttribute, a);
                vEnd.fromBufferAttribute(positionAttribute, b);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i = start, l = end - 1; i < l; i += step) {
                vStart.fromBufferAttribute(positionAttribute, i);
                vEnd.fromBufferAttribute(positionAttribute, i + 1);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      }
      Line.prototype.isLine = true;
      const _start = /* @__PURE__ */ new Vector3();
      const _end = /* @__PURE__ */ new Vector3();
      class LineSegments extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [];
              for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
                _start.fromBufferAttribute(positionAttribute, i);
                _end.fromBufferAttribute(positionAttribute, i + 1);
                lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
      }
      LineSegments.prototype.isLineSegments = true;
      class LineLoop extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineLoop";
        }
      }
      LineLoop.prototype.isLineLoop = true;
      class PointsMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.morphTargets = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          this.morphTargets = source.morphTargets;
          return this;
        }
      }
      PointsMaterial.prototype.isPointsMaterial = true;
      const _inverseMatrix = /* @__PURE__ */ new Matrix4();
      const _ray = /* @__PURE__ */ new Ray();
      const _sphere = /* @__PURE__ */ new Sphere();
      const _position$2 = /* @__PURE__ */ new Vector3();
      class Points extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
          super();
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          if (geometry.isBufferGeometry) {
            const index2 = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index2 !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index2.count, drawRange.start + drawRange.count);
              for (let i = start, il = end; i < il; i++) {
                const a = index2.getX(i);
                _position$2.fromBufferAttribute(positionAttribute, a);
                testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i = start, l = end; i < l; i++) {
                _position$2.fromBufferAttribute(positionAttribute, i);
                testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            }
          } else {
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      }
      Points.prototype.isPoints = true;
      function testPoint(point, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
        const rayPointDistanceSq = _ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          const intersectPoint = new Vector3();
          _ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index2,
            face: null,
            object
          });
        }
      }
      class VideoTexture extends Texture2 {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.format = format2 !== void 0 ? format2 : RGBFormat;
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      }
      VideoTexture.prototype.isVideoTexture = true;
      class CompressedTexture extends Texture2 {
        constructor(mipmaps, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
          this.image = {
            width,
            height
          };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      }
      CompressedTexture.prototype.isCompressedTexture = true;
      class CanvasTexture2 extends Texture2 {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
          super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.needsUpdate = true;
        }
      }
      CanvasTexture2.prototype.isCanvasTexture = true;
      class DepthTexture extends Texture2 {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
          format2 = format2 !== void 0 ? format2 : DepthFormat;
          if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format2 === DepthFormat)
            type = UnsignedShortType;
          if (type === void 0 && format2 === DepthStencilFormat)
            type = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
          this.image = {
            width,
            height
          };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      }
      DepthTexture.prototype.isDepthTexture = true;
      class CircleGeometry extends BufferGeometry {
        constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CircleGeometry";
          this.parameters = {
            radius,
            segments,
            thetaStart,
            thetaLength
          };
          segments = Math.max(3, segments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex = new Vector3();
          const uv = new Vector22();
          vertices.push(0, 0, 0);
          normals.push(0, 0, 1);
          uvs.push(0.5, 0.5);
          for (let s2 = 0, i = 3; s2 <= segments; s2++, i += 3) {
            const segment = thetaStart + s2 / segments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          for (let i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
      }
      class CylinderGeometry extends BufferGeometry {
        constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop,
            radiusBottom,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
          const scope = this;
          radialSegments = Math.floor(radialSegments);
          heightSegments = Math.floor(heightSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let index2 = 0;
          const indexArray = [];
          const halfHeight = height / 2;
          let groupStart = 0;
          generateTorso();
          if (openEnded === false) {
            if (radiusTop > 0)
              generateCap(true);
            if (radiusBottom > 0)
              generateCap(false);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateTorso() {
            const normal = new Vector3();
            const vertex = new Vector3();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height;
            for (let y = 0; y <= heightSegments; y++) {
              const indexRow = [];
              const v = y / heightSegments;
              const radius = v * (radiusBottom - radiusTop) + radiusTop;
              for (let x = 0; x <= radialSegments; x++) {
                const u = x / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                vertex.x = radius * sinTheta;
                vertex.y = -v * height + halfHeight;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                indexRow.push(index2++);
              }
              indexArray.push(indexRow);
            }
            for (let x = 0; x < radialSegments; x++) {
              for (let y = 0; y < heightSegments; y++) {
                const a = indexArray[y][x];
                const b = indexArray[y + 1][x];
                const c = indexArray[y + 1][x + 1];
                const d2 = indexArray[y][x + 1];
                indices.push(a, b, d2);
                indices.push(b, c, d2);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
          }
          function generateCap(top) {
            const centerIndexStart = index2;
            const uv = new Vector22();
            const vertex = new Vector3();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            for (let x = 1; x <= radialSegments; x++) {
              vertices.push(0, halfHeight * sign2, 0);
              normals.push(0, sign2, 0);
              uvs.push(0.5, 0.5);
              index2++;
            }
            const centerIndexEnd = index2;
            for (let x = 0; x <= radialSegments; x++) {
              const u = x / radialSegments;
              const theta = u * thetaLength + thetaStart;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              vertex.x = radius * sinTheta;
              vertex.y = halfHeight * sign2;
              vertex.z = radius * cosTheta;
              vertices.push(vertex.x, vertex.y, vertex.z);
              normals.push(0, sign2, 0);
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 * sign2 + 0.5;
              uvs.push(uv.x, uv.y);
              index2++;
            }
            for (let x = 0; x < radialSegments; x++) {
              const c = centerIndexStart + x;
              const i = centerIndexEnd + x;
              if (top === true) {
                indices.push(i, i + 1, c);
              } else {
                indices.push(i + 1, i, c);
              }
              groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
          }
        }
        static fromJSON(data) {
          return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      }
      class ConeGeometry extends CylinderGeometry {
        constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
          this.type = "ConeGeometry";
          this.parameters = {
            radius,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
        }
        static fromJSON(data) {
          return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      }
      class PolyhedronGeometry extends BufferGeometry {
        constructor(vertices, indices, radius = 1, detail = 0) {
          super();
          this.type = "PolyhedronGeometry";
          this.parameters = {
            vertices,
            indices,
            radius,
            detail
          };
          const vertexBuffer = [];
          const uvBuffer = [];
          subdivide(detail);
          applyRadius(radius);
          generateUVs();
          this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
          this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
          if (detail === 0) {
            this.computeVertexNormals();
          } else {
            this.normalizeNormals();
          }
          function subdivide(detail2) {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            for (let i = 0; i < indices.length; i += 3) {
              getVertexByIndex(indices[i + 0], a);
              getVertexByIndex(indices[i + 1], b);
              getVertexByIndex(indices[i + 2], c);
              subdivideFace(a, b, c, detail2);
            }
          }
          function subdivideFace(a, b, c, detail2) {
            const cols = detail2 + 1;
            const v = [];
            for (let i = 0; i <= cols; i++) {
              v[i] = [];
              const aj = a.clone().lerp(c, i / cols);
              const bj = b.clone().lerp(c, i / cols);
              const rows = cols - i;
              for (let j = 0; j <= rows; j++) {
                if (j === 0 && i === cols) {
                  v[i][j] = aj;
                } else {
                  v[i][j] = aj.clone().lerp(bj, j / rows);
                }
              }
            }
            for (let i = 0; i < cols; i++) {
              for (let j = 0; j < 2 * (cols - i) - 1; j++) {
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                  pushVertex(v[i][k + 1]);
                  pushVertex(v[i + 1][k]);
                  pushVertex(v[i][k]);
                } else {
                  pushVertex(v[i][k + 1]);
                  pushVertex(v[i + 1][k + 1]);
                  pushVertex(v[i + 1][k]);
                }
              }
            }
          }
          function applyRadius(radius2) {
            const vertex = new Vector3();
            for (let i = 0; i < vertexBuffer.length; i += 3) {
              vertex.x = vertexBuffer[i + 0];
              vertex.y = vertexBuffer[i + 1];
              vertex.z = vertexBuffer[i + 2];
              vertex.normalize().multiplyScalar(radius2);
              vertexBuffer[i + 0] = vertex.x;
              vertexBuffer[i + 1] = vertex.y;
              vertexBuffer[i + 2] = vertex.z;
            }
          }
          function generateUVs() {
            const vertex = new Vector3();
            for (let i = 0; i < vertexBuffer.length; i += 3) {
              vertex.x = vertexBuffer[i + 0];
              vertex.y = vertexBuffer[i + 1];
              vertex.z = vertexBuffer[i + 2];
              const u = azimuth(vertex) / 2 / Math.PI + 0.5;
              const v = inclination(vertex) / Math.PI + 0.5;
              uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
          }
          function correctSeam() {
            for (let i = 0; i < uvBuffer.length; i += 6) {
              const x0 = uvBuffer[i + 0];
              const x1 = uvBuffer[i + 2];
              const x2 = uvBuffer[i + 4];
              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);
              if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2)
                  uvBuffer[i + 0] += 1;
                if (x1 < 0.2)
                  uvBuffer[i + 2] += 1;
                if (x2 < 0.2)
                  uvBuffer[i + 4] += 1;
              }
            }
          }
          function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
          }
          function getVertexByIndex(index2, vertex) {
            const stride = index2 * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
          }
          function correctUVs() {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            const centroid = new Vector3();
            const uvA = new Vector22();
            const uvB = new Vector22();
            const uvC = new Vector22();
            for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
              a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
              b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
              c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
              centroid.copy(a).add(b).add(c).divideScalar(3);
              const azi = azimuth(centroid);
              correctUV(uvA, j + 0, a, azi);
              correctUV(uvB, j + 2, b, azi);
              correctUV(uvC, j + 4, c, azi);
            }
          }
          function correctUV(uv, stride, vector, azimuth2) {
            if (azimuth2 < 0 && uv.x === 1) {
              uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
              uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
            }
          }
          function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
          }
          function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
          }
        }
        static fromJSON(data) {
          return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
      }
      class DodecahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const r = 1 / t;
          const vertices = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            0,
            -t,
            0,
            -r,
            t,
            0,
            -r,
            -t,
            0,
            r,
            t,
            0,
            r
          ];
          const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
          super(vertices, indices, radius, detail);
          this.type = "DodecahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new DodecahedronGeometry(data.radius, data.detail);
        }
      }
      const _v0 = new Vector3();
      const _v1$1 = new Vector3();
      const _normal = new Vector3();
      const _triangle = new Triangle();
      class EdgesGeometry extends BufferGeometry {
        constructor(geometry, thresholdAngle) {
          super();
          this.type = "EdgesGeometry";
          this.parameters = {
            thresholdAngle
          };
          thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
          if (geometry.isGeometry === true) {
            console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return;
          }
          const precisionPoints = 4;
          const precision = Math.pow(10, precisionPoints);
          const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
          const indexAttr = geometry.getIndex();
          const positionAttr = geometry.getAttribute("position");
          const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
          const indexArr = [0, 0, 0];
          const vertKeys = ["a", "b", "c"];
          const hashes = new Array(3);
          const edgeData = {};
          const vertices = [];
          for (let i = 0; i < indexCount; i += 3) {
            if (indexAttr) {
              indexArr[0] = indexAttr.getX(i);
              indexArr[1] = indexAttr.getX(i + 1);
              indexArr[2] = indexAttr.getX(i + 2);
            } else {
              indexArr[0] = i;
              indexArr[1] = i + 1;
              indexArr[2] = i + 2;
            }
            const {
              a,
              b,
              c
            } = _triangle;
            a.fromBufferAttribute(positionAttr, indexArr[0]);
            b.fromBufferAttribute(positionAttr, indexArr[1]);
            c.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal);
            hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
            hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
            hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
              continue;
            }
            for (let j = 0; j < 3; j++) {
              const jNext = (j + 1) % 3;
              const vecHash0 = hashes[j];
              const vecHash1 = hashes[jNext];
              const v0 = _triangle[vertKeys[j]];
              const v1 = _triangle[vertKeys[jNext]];
              const hash2 = `${vecHash0}_${vecHash1}`;
              const reverseHash = `${vecHash1}_${vecHash0}`;
              if (reverseHash in edgeData && edgeData[reverseHash]) {
                if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                  vertices.push(v0.x, v0.y, v0.z);
                  vertices.push(v1.x, v1.y, v1.z);
                }
                edgeData[reverseHash] = null;
              } else if (!(hash2 in edgeData)) {
                edgeData[hash2] = {
                  index0: indexArr[j],
                  index1: indexArr[jNext],
                  normal: _normal.clone()
                };
              }
            }
          }
          for (const key in edgeData) {
            if (edgeData[key]) {
              const {
                index0,
                index1
              } = edgeData[key];
              _v0.fromBufferAttribute(positionAttr, index0);
              _v1$1.fromBufferAttribute(positionAttr, index1);
              vertices.push(_v0.x, _v0.y, _v0.z);
              vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
      class Curve {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getPoint(t, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d2 = 0; d2 <= divisions; d2++) {
            points.push(this.getPoint(d2 / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d2 = 0; d2 <= divisions; d2++) {
            points.push(this.getPointAt(d2 / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u, distance) {
          const arcLengths = this.getLengths();
          let i = 0;
          const il = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          let low = 0, high = il - 1, comparison;
          while (low <= high) {
            i = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
              low = i + 1;
            } else if (comparison > 0) {
              high = i - 1;
            } else {
              high = i;
              break;
            }
          }
          i = high;
          if (arcLengths[i] === targetArcLength) {
            return i / (il - 1);
          }
          const lengthBefore = arcLengths[i];
          const lengthAfter = arcLengths[i + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t = (i + segmentFraction) / (il - 1);
          return t;
        }
        getTangent(t, optionalTarget) {
          const delta = 1e-4;
          let t1 = t - delta;
          let t2 = t + delta;
          if (t1 < 0)
            t1 = 0;
          if (t2 > 1)
            t2 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t2);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector22() : new Vector3());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getTangent(t, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector3();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector3();
          const mat = new Matrix4();
          for (let i = 0; i <= segments; i++) {
            const u = i / segments;
            tangents[i] = this.getTangentAt(u, new Vector3());
            tangents[i].normalize();
          }
          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i = 1; i <= segments; i++) {
            normals[i] = normals[i - 1].clone();
            binormals[i] = binormals[i - 1].clone();
            vec.crossVectors(tangents[i - 1], tangents[i]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
              normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i].crossVectors(tangents[i], normals[i]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i = 1; i <= segments; i++) {
              normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
              binormals[i].crossVectors(tangents[i], normals[i]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      }
      class EllipseCurve extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t, optionalTarget) {
          const point = optionalTarget || new Vector22();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t * deltaAngle;
          let x = this.aX + this.xRadius * Math.cos(angle);
          let y = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
          }
          return point.set(x, y);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      }
      EllipseCurve.prototype.isEllipseCurve = true;
      class ArcCurve extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.type = "ArcCurve";
        }
      }
      ArcCurve.prototype.isArcCurve = true;
      function CubicPoly() {
        let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        function init2(x0, x1, t0, t1) {
          c0 = x0;
          c1 = t0;
          c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
          c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
          initCatmullRom: function(x0, x1, x2, x3, tension) {
            init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
          },
          initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            init2(x1, x2, t1, t2);
          },
          calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
          }
        };
      }
      const tmp = new Vector3();
      const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
      class CatmullRomCurve3 extends Curve {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const points = this.points;
          const l = points.length;
          const p = (l - (this.closed ? 0 : 1)) * t;
          let intPoint = Math.floor(p);
          let weight = p - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
          } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
          } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
          }
          const p1 = points[intPoint % l];
          const p2 = points[(intPoint + 1) % l];
          if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
          } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
          }
          point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i = 0, l = source.points.length; i < l; i++) {
            const point = source.points[i];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i = 0, l = this.points.length; i < l; i++) {
            const point = this.points[i];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i = 0, l = json.points.length; i < l; i++) {
            const point = json.points[i];
            this.points.push(new Vector3().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      }
      CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
      function CatmullRom(t, p0, p1, p2, p3) {
        const v0 = (p2 - p0) * 0.5;
        const v1 = (p3 - p1) * 0.5;
        const t2 = t * t;
        const t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
      function QuadraticBezierP0(t, p) {
        const k = 1 - t;
        return k * k * p;
      }
      function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
      }
      function QuadraticBezierP2(t, p) {
        return t * t * p;
      }
      function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
      }
      function CubicBezierP0(t, p) {
        const k = 1 - t;
        return k * k * k * p;
      }
      function CubicBezierP1(t, p) {
        const k = 1 - t;
        return 3 * k * k * t * p;
      }
      function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
      }
      function CubicBezierP3(t, p) {
        return t * t * t * p;
      }
      function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
      }
      class CubicBezierCurve extends Curve {
        constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22(), v3 = new Vector22()) {
          super();
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      }
      CubicBezierCurve.prototype.isCubicBezierCurve = true;
      class CubicBezierCurve3 extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
          super();
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      }
      CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
      class LineCurve extends Curve {
        constructor(v1 = new Vector22(), v2 = new Vector22()) {
          super();
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget) {
          const tangent = optionalTarget || new Vector22();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      LineCurve.prototype.isLineCurve = true;
      class LineCurve3 extends Curve {
        constructor(v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "LineCurve3";
          this.isLineCurve3 = true;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      class QuadraticBezierCurve extends Curve {
        constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22()) {
          super();
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
      class QuadraticBezierCurve3 extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      }
      QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
      class SplineCurve extends Curve {
        constructor(points = []) {
          super();
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const points = this.points;
          const p = (points.length - 1) * t;
          const intPoint = Math.floor(p);
          const weight = p - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i = 0, l = source.points.length; i < l; i++) {
            const point = source.points[i];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i = 0, l = this.points.length; i < l; i++) {
            const point = this.points[i];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i = 0, l = json.points.length; i < l; i++) {
            const point = json.points[i];
            this.points.push(new Vector22().fromArray(point));
          }
          return this;
        }
      }
      SplineCurve.prototype.isSplineCurve = true;
      var Curves = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve,
        CatmullRomCurve3,
        CubicBezierCurve,
        CubicBezierCurve3,
        EllipseCurve,
        LineCurve,
        LineCurve3,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        SplineCurve
      });
      const Earcut = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x, y, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i = dim; i < outerLen; i += dim) {
              x = data[i];
              y = data[i + 1];
              if (x < minX)
                minX = x;
              if (y < minY)
                minY = y;
              if (x > maxX)
                maxX = x;
              if (y > maxY)
                maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
      };
      function linkedList(data, start, end, dim, clockwise) {
        let i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        let p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        let stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        let p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        let p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          const a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              let c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        const queue = [];
        let i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          const b = splitPolygon(outerNode, hole);
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        if (hx === qx)
          return m;
        const stop = m, mx = m.x, my = m.y;
        let tanMin = Infinity, tan;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start) {
        let p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
        return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        const o1 = sign(area(p1, q1, p2));
        const o2 = sign(area(p1, q1, q2));
        const o3 = sign(area(p2, q2, p1));
        const o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        let p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        let p = a, inside = false;
        const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
        do {
          if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        const p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      function signedArea(data, start, end, dim) {
        let sum = 0;
        for (let i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      class ShapeUtils {
        static area(contour) {
          const n = contour.length;
          let a = 0;
          for (let p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
          }
          return a * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts(contour);
          addContour(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts);
          for (let i = 0; i < holes.length; i++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
          }
          const triangles = Earcut.triangulate(vertices, holeIndices);
          for (let i = 0; i < triangles.length; i += 3) {
            faces.push(triangles.slice(i, i + 3));
          }
          return faces;
        }
      }
      function removeDupEndPts(points) {
        const l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
          points.pop();
        }
      }
      function addContour(vertices, contour) {
        for (let i = 0; i < contour.length; i++) {
          vertices.push(contour[i].x);
          vertices.push(contour[i].y);
        }
      }
      class ExtrudeGeometry extends BufferGeometry {
        constructor(shapes, options2) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options: options2
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
            const steps = options2.steps !== void 0 ? options2.steps : 1;
            let depth = options2.depth !== void 0 ? options2.depth : 100;
            let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
            let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 6;
            let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 2;
            let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
            let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
            const extrudePath = options2.extrudePath;
            const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
            if (options2.amount !== void 0) {
              console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
              depth = options2.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector22(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector22(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = [];
              for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b = 0; b < bevelSegments; b++) {
              const t = b / bevelSegments;
              const z2 = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i = 0, il = contour.length; i < il; i++) {
                const vert = scalePt2(contour[i], contourMovements[i], bs2);
                v(vert.x, vert.y, -z2);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i = 0, il = ahole.length; i < il; i++) {
                  const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                  v(vert.x, vert.y, -z2);
                }
              }
            }
            const bs = bevelSize + bevelOffset;
            for (let i = 0; i < vlen; i++) {
              const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            for (let s2 = 1; s2 <= steps; s2++) {
              for (let i = 0; i < vlen; i++) {
                const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth / steps * s2);
                } else {
                  normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s2]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b = bevelSegments - 1; b >= 0; b--) {
              const t = b / bevelSegments;
              const z2 = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i = 0, il = contour.length; i < il; i++) {
                const vert = scalePt2(contour[i], contourMovements[i], bs2);
                v(vert.x, vert.y, depth + z2);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i = 0, il = ahole.length; i < il; i++) {
                  const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, depth + z2);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[2], face[1], face[0]);
                }
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i = contour2.length;
              while (--i >= 0) {
                const j = i;
                let k = i - 1;
                if (k < 0)
                  k = contour2.length - 1;
                for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
                  const slen1 = vlen * s2;
                  const slen2 = vlen * (s2 + 1);
                  const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d2 = layeroffset + j + slen2;
                  f4(a, b, c, d2);
                }
              }
            }
            function v(x, y, z2) {
              placeholder.push(x);
              placeholder.push(y);
              placeholder.push(z2);
            }
            function f3(a, b, c) {
              addVertex(a);
              addVertex(b);
              addVertex(c);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a, b, c, d2) {
              addVertex(a);
              addVertex(b);
              addVertex(d2);
              addVertex(b);
              addVertex(c);
              addVertex(d2);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index2) {
              verticesArray.push(placeholder[index2 * 3 + 0]);
              verticesArray.push(placeholder[index2 * 3 + 1]);
              verticesArray.push(placeholder[index2 * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options2 = this.parameters.options;
          return toJSON$1(shapes, options2, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry(geometryShapes, data.options);
        }
      }
      const WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [new Vector22(a_x, a_y), new Vector22(b_x, b_y), new Vector22(c_x, c_y)];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [new Vector22(a_x, 1 - a_z), new Vector22(b_x, 1 - b_z), new Vector22(c_x, 1 - c_z), new Vector22(d_x, 1 - d_z)];
          } else {
            return [new Vector22(a_y, 1 - a_z), new Vector22(b_y, 1 - b_z), new Vector22(c_y, 1 - c_z), new Vector22(d_y, 1 - d_z)];
          }
        }
      };
      function toJSON$1(shapes, options2, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        if (options2.extrudePath !== void 0)
          data.options.extrudePath = options2.extrudePath.toJSON();
        return data;
      }
      class IcosahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
          const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
          super(vertices, indices, radius, detail);
          this.type = "IcosahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new IcosahedronGeometry(data.radius, data.detail);
        }
      }
      class LatheGeometry extends BufferGeometry {
        constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
          super();
          this.type = "LatheGeometry";
          this.parameters = {
            points,
            segments,
            phiStart,
            phiLength
          };
          segments = Math.floor(segments);
          phiLength = clamp(phiLength, 0, Math.PI * 2);
          const indices = [];
          const vertices = [];
          const uvs = [];
          const inverseSegments = 1 / segments;
          const vertex = new Vector3();
          const uv = new Vector22();
          for (let i = 0; i <= segments; i++) {
            const phi = phiStart + i * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for (let j = 0; j <= points.length - 1; j++) {
              vertex.x = points[j].x * sin;
              vertex.y = points[j].y;
              vertex.z = points[j].x * cos;
              vertices.push(vertex.x, vertex.y, vertex.z);
              uv.x = i / segments;
              uv.y = j / (points.length - 1);
              uvs.push(uv.x, uv.y);
            }
          }
          for (let i = 0; i < segments; i++) {
            for (let j = 0; j < points.length - 1; j++) {
              const base = j + i * points.length;
              const a = base;
              const b = base + points.length;
              const c = base + points.length + 1;
              const d2 = base + 1;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          this.computeVertexNormals();
          if (phiLength === Math.PI * 2) {
            const normals = this.attributes.normal.array;
            const n1 = new Vector3();
            const n2 = new Vector3();
            const n = new Vector3();
            const base = segments * points.length * 3;
            for (let i = 0, j = 0; i < points.length; i++, j += 3) {
              n1.x = normals[j + 0];
              n1.y = normals[j + 1];
              n1.z = normals[j + 2];
              n2.x = normals[base + j + 0];
              n2.y = normals[base + j + 1];
              n2.z = normals[base + j + 2];
              n.addVectors(n1, n2).normalize();
              normals[j + 0] = normals[base + j + 0] = n.x;
              normals[j + 1] = normals[base + j + 1] = n.y;
              normals[j + 2] = normals[base + j + 2] = n.z;
            }
          }
        }
        static fromJSON(data) {
          return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
      }
      class OctahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
          const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
          super(vertices, indices, radius, detail);
          this.type = "OctahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new OctahedronGeometry(data.radius, data.detail);
        }
      }
      class ParametricGeometry extends BufferGeometry {
        constructor(func, slices, stacks) {
          super();
          this.type = "ParametricGeometry";
          this.parameters = {
            func,
            slices,
            stacks
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const EPS = 1e-5;
          const normal = new Vector3();
          const p0 = new Vector3(), p1 = new Vector3();
          const pu = new Vector3(), pv = new Vector3();
          if (func.length < 3) {
            console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
          }
          const sliceCount = slices + 1;
          for (let i = 0; i <= stacks; i++) {
            const v = i / stacks;
            for (let j = 0; j <= slices; j++) {
              const u = j / slices;
              func(u, v, p0);
              vertices.push(p0.x, p0.y, p0.z);
              if (u - EPS >= 0) {
                func(u - EPS, v, p1);
                pu.subVectors(p0, p1);
              } else {
                func(u + EPS, v, p1);
                pu.subVectors(p1, p0);
              }
              if (v - EPS >= 0) {
                func(u, v - EPS, p1);
                pv.subVectors(p0, p1);
              } else {
                func(u, v + EPS, p1);
                pv.subVectors(p1, p0);
              }
              normal.crossVectors(pu, pv).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u, v);
            }
          }
          for (let i = 0; i < stacks; i++) {
            for (let j = 0; j < slices; j++) {
              const a = i * sliceCount + j;
              const b = i * sliceCount + j + 1;
              const c = (i + 1) * sliceCount + j + 1;
              const d2 = (i + 1) * sliceCount + j;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
      }
      class RingGeometry extends BufferGeometry {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex = new Vector3();
          const uv = new Vector22();
          for (let j = 0; j <= phiSegments; j++) {
            for (let i = 0; i <= thetaSegments; i++) {
              const segment = thetaStart + i / thetaSegments * thetaLength;
              vertex.x = radius * Math.cos(segment);
              vertex.y = radius * Math.sin(segment);
              vertices.push(vertex.x, vertex.y, vertex.z);
              normals.push(0, 0, 1);
              uv.x = (vertex.x / outerRadius + 1) / 2;
              uv.y = (vertex.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j = 0; j < phiSegments; j++) {
            const thetaSegmentLevel = j * (thetaSegments + 1);
            for (let i = 0; i < thetaSegments; i++) {
              const segment = i + thetaSegmentLevel;
              const a = segment;
              const b = segment + thetaSegments + 1;
              const c = segment + thetaSegments + 2;
              const d2 = segment + 1;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      }
      class ShapeGeometry extends BufferGeometry {
        constructor(shapes, curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i = 0; i < shapes.length; i++) {
              addShape(shapes[i]);
              this.addGroup(groupStart, groupCount, i);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i = 0, l = shapeHoles.length; i < l; i++) {
              const shapeHole = shapeHoles[i];
              if (ShapeUtils.isClockWise(shapeHole) === true) {
                shapeHoles[i] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (let i = 0, l = shapeHoles.length; i < l; i++) {
              const shapeHole = shapeHoles[i];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i = 0, l = shapeVertices.length; i < l; i++) {
              const vertex = shapeVertices[i];
              vertices.push(vertex.x, vertex.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex.x, vertex.y);
            }
            for (let i = 0, l = faces.length; i < l; i++) {
              const face = faces[i];
              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;
              indices.push(a, b, c);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
      }
      function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        return data;
      }
      class SphereGeometry extends BufferGeometry {
        constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
          super();
          this.type = "SphereGeometry";
          this.parameters = {
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          };
          widthSegments = Math.max(3, Math.floor(widthSegments));
          heightSegments = Math.max(2, Math.floor(heightSegments));
          const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
          let index2 = 0;
          const grid = [];
          const vertex = new Vector3();
          const normal = new Vector3();
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy <= heightSegments; iy++) {
            const verticesRow = [];
            const v = iy / heightSegments;
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
              uOffset = 0.5 / widthSegments;
            } else if (iy == heightSegments && thetaEnd == Math.PI) {
              uOffset = -0.5 / widthSegments;
            }
            for (let ix = 0; ix <= widthSegments; ix++) {
              const u = ix / widthSegments;
              vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
              vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertices.push(vertex.x, vertex.y, vertex.z);
              normal.copy(vertex).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u + uOffset, 1 - v);
              verticesRow.push(index2++);
            }
            grid.push(verticesRow);
          }
          for (let iy = 0; iy < heightSegments; iy++) {
            for (let ix = 0; ix < widthSegments; ix++) {
              const a = grid[iy][ix + 1];
              const b = grid[iy][ix];
              const c = grid[iy + 1][ix];
              const d2 = grid[iy + 1][ix + 1];
              if (iy !== 0 || thetaStart > 0)
                indices.push(a, b, d2);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
      }
      class TetrahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
          const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(vertices, indices, radius, detail);
          this.type = "TetrahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new TetrahedronGeometry(data.radius, data.detail);
        }
      }
      class TextGeometry extends ExtrudeGeometry {
        constructor(text, parameters = {}) {
          const font = parameters.font;
          if (!(font && font.isFont)) {
            console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
            return new BufferGeometry();
          }
          const shapes = font.generateShapes(text, parameters.size);
          parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
          if (parameters.bevelThickness === void 0)
            parameters.bevelThickness = 10;
          if (parameters.bevelSize === void 0)
            parameters.bevelSize = 8;
          if (parameters.bevelEnabled === void 0)
            parameters.bevelEnabled = false;
          super(shapes, parameters);
          this.type = "TextGeometry";
        }
      }
      class TorusGeometry extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
          super();
          this.type = "TorusGeometry";
          this.parameters = {
            radius,
            tube,
            radialSegments,
            tubularSegments,
            arc
          };
          radialSegments = Math.floor(radialSegments);
          tubularSegments = Math.floor(tubularSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const center = new Vector3();
          const vertex = new Vector3();
          const normal = new Vector3();
          for (let j = 0; j <= radialSegments; j++) {
            for (let i = 0; i <= tubularSegments; i++) {
              const u = i / tubularSegments * arc;
              const v = j / radialSegments * Math.PI * 2;
              vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
              vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
              vertex.z = tube * Math.sin(v);
              vertices.push(vertex.x, vertex.y, vertex.z);
              center.x = radius * Math.cos(u);
              center.y = radius * Math.sin(u);
              normal.subVectors(vertex, center).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= radialSegments; j++) {
            for (let i = 1; i <= tubularSegments; i++) {
              const a = (tubularSegments + 1) * j + i - 1;
              const b = (tubularSegments + 1) * (j - 1) + i - 1;
              const c = (tubularSegments + 1) * (j - 1) + i;
              const d2 = (tubularSegments + 1) * j + i;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
      }
      class TorusKnotGeometry extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
          super();
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius,
            tube,
            tubularSegments,
            radialSegments,
            p,
            q
          };
          tubularSegments = Math.floor(tubularSegments);
          radialSegments = Math.floor(radialSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex = new Vector3();
          const normal = new Vector3();
          const P1 = new Vector3();
          const P2 = new Vector3();
          const B = new Vector3();
          const T = new Vector3();
          const N = new Vector3();
          for (let i = 0; i <= tubularSegments; ++i) {
            const u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (let j = 0; j <= radialSegments; ++j) {
              const v = j / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v);
              const cy = tube * Math.sin(v);
              vertex.x = P1.x + (cx * N.x + cy * B.x);
              vertex.y = P1.y + (cx * N.y + cy * B.y);
              vertex.z = P1.z + (cx * N.z + cy * B.z);
              vertices.push(vertex.x, vertex.y, vertex.z);
              normal.subVectors(vertex, P1).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= tubularSegments; j++) {
            for (let i = 1; i <= radialSegments; i++) {
              const a = (radialSegments + 1) * (j - 1) + (i - 1);
              const b = (radialSegments + 1) * j + (i - 1);
              const c = (radialSegments + 1) * j + i;
              const d2 = (radialSegments + 1) * (j - 1) + i;
              indices.push(a, b, d2);
              indices.push(b, c, d2);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function calculatePositionOnCurve(u, p2, q2, radius2, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q2 / p2 * u;
            const cs = Math.cos(quOverP);
            position.x = radius2 * (2 + cs) * 0.5 * cu;
            position.y = radius2 * (2 + cs) * su * 0.5;
            position.z = radius2 * Math.sin(quOverP) * 0.5;
          }
        }
        static fromJSON(data) {
          return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
      }
      class TubeGeometry extends BufferGeometry {
        constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
          super();
          this.type = "TubeGeometry";
          this.parameters = {
            path,
            tubularSegments,
            radius,
            radialSegments,
            closed
          };
          const frames = path.computeFrenetFrames(tubularSegments, closed);
          this.tangents = frames.tangents;
          this.normals = frames.normals;
          this.binormals = frames.binormals;
          const vertex = new Vector3();
          const normal = new Vector3();
          const uv = new Vector22();
          let P = new Vector3();
          const vertices = [];
          const normals = [];
          const uvs = [];
          const indices = [];
          generateBufferData();
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateBufferData() {
            for (let i = 0; i < tubularSegments; i++) {
              generateSegment(i);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
          }
          function generateSegment(i) {
            P = path.getPointAt(i / tubularSegments, P);
            const N = frames.normals[i];
            const B = frames.binormals[i];
            for (let j = 0; j <= radialSegments; j++) {
              const v = j / radialSegments * Math.PI * 2;
              const sin = Math.sin(v);
              const cos = -Math.cos(v);
              normal.x = cos * N.x + sin * B.x;
              normal.y = cos * N.y + sin * B.y;
              normal.z = cos * N.z + sin * B.z;
              normal.normalize();
              normals.push(normal.x, normal.y, normal.z);
              vertex.x = P.x + radius * normal.x;
              vertex.y = P.y + radius * normal.y;
              vertex.z = P.z + radius * normal.z;
              vertices.push(vertex.x, vertex.y, vertex.z);
            }
          }
          function generateIndices() {
            for (let j = 1; j <= tubularSegments; j++) {
              for (let i = 1; i <= radialSegments; i++) {
                const a = (radialSegments + 1) * (j - 1) + (i - 1);
                const b = (radialSegments + 1) * j + (i - 1);
                const c = (radialSegments + 1) * j + i;
                const d2 = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d2);
                indices.push(b, c, d2);
              }
            }
          }
          function generateUVs() {
            for (let i = 0; i <= tubularSegments; i++) {
              for (let j = 0; j <= radialSegments; j++) {
                uv.x = i / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
              }
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          data.path = this.parameters.path.toJSON();
          return data;
        }
        static fromJSON(data) {
          return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
        }
      }
      class WireframeGeometry extends BufferGeometry {
        constructor(geometry) {
          super();
          this.type = "WireframeGeometry";
          if (geometry.isGeometry === true) {
            console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return;
          }
          const vertices = [];
          const edge = [0, 0], edges = {};
          const vertex = new Vector3();
          if (geometry.index !== null) {
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) {
              groups = [{
                start: 0,
                count: indices.count,
                materialIndex: 0
              }];
            }
            for (let o = 0, ol = groups.length; o < ol; ++o) {
              const group = groups[o];
              const start = group.start;
              const count = group.count;
              for (let i = start, l = start + count; i < l; i += 3) {
                for (let j = 0; j < 3; j++) {
                  const edge1 = indices.getX(i + j);
                  const edge2 = indices.getX(i + (j + 1) % 3);
                  edge[0] = Math.min(edge1, edge2);
                  edge[1] = Math.max(edge1, edge2);
                  const key = edge[0] + "," + edge[1];
                  if (edges[key] === void 0) {
                    edges[key] = {
                      index1: edge[0],
                      index2: edge[1]
                    };
                  }
                }
              }
            }
            for (const key in edges) {
              const e = edges[key];
              vertex.fromBufferAttribute(position, e.index1);
              vertices.push(vertex.x, vertex.y, vertex.z);
              vertex.fromBufferAttribute(position, e.index2);
              vertices.push(vertex.x, vertex.y, vertex.z);
            }
          } else {
            const position = geometry.attributes.position;
            for (let i = 0, l = position.count / 3; i < l; i++) {
              for (let j = 0; j < 3; j++) {
                const index1 = 3 * i + j;
                vertex.fromBufferAttribute(position, index1);
                vertices.push(vertex.x, vertex.y, vertex.z);
                const index2 = 3 * i + (j + 1) % 3;
                vertex.fromBufferAttribute(position, index2);
                vertices.push(vertex.x, vertex.y, vertex.z);
              }
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
      var Geometries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BoxGeometry,
        BoxBufferGeometry: BoxGeometry,
        CircleGeometry,
        CircleBufferGeometry: CircleGeometry,
        ConeGeometry,
        ConeBufferGeometry: ConeGeometry,
        CylinderGeometry,
        CylinderBufferGeometry: CylinderGeometry,
        DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronGeometry,
        EdgesGeometry,
        ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeGeometry,
        IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronGeometry,
        LatheGeometry,
        LatheBufferGeometry: LatheGeometry,
        OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronGeometry,
        ParametricGeometry,
        ParametricBufferGeometry: ParametricGeometry,
        PlaneGeometry: PlaneGeometry2,
        PlaneBufferGeometry: PlaneGeometry2,
        PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronGeometry,
        RingGeometry,
        RingBufferGeometry: RingGeometry,
        ShapeGeometry,
        ShapeBufferGeometry: ShapeGeometry,
        SphereGeometry,
        SphereBufferGeometry: SphereGeometry,
        TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronGeometry,
        TextGeometry,
        TextBufferGeometry: TextGeometry,
        TorusGeometry,
        TorusBufferGeometry: TorusGeometry,
        TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotGeometry,
        TubeGeometry,
        TubeBufferGeometry: TubeGeometry,
        WireframeGeometry
      });
      class ShadowMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "ShadowMaterial";
          this.color = new Color(0);
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          return this;
        }
      }
      ShadowMaterial.prototype.isShadowMaterial = true;
      class RawShaderMaterial extends ShaderMaterial {
        constructor(parameters) {
          super(parameters);
          this.type = "RawShaderMaterial";
        }
      }
      RawShaderMaterial.prototype.isRawShaderMaterial = true;
      class MeshStandardMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": ""
          };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.morphTargets = false;
          this.morphNormals = false;
          this.flatShading = false;
          this.vertexTangents = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": ""
          };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          this.flatShading = source.flatShading;
          this.vertexTangents = source.vertexTangents;
          return this;
        }
      }
      MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
      class MeshPhysicalMaterial extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoat = 0;
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector22(1, 1);
          this.clearcoatNormalMap = null;
          this.reflectivity = 0.5;
          Object.defineProperty(this, "ior", {
            get: function() {
              return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
            },
            set: function(ior) {
              this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
            }
          });
          this.sheen = null;
          this.transmission = 0;
          this.transmissionMap = null;
          this.thickness = 0.01;
          this.thicknessMap = null;
          this.attenuationDistance = 0;
          this.attenuationColor = new Color(1, 1, 1);
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.reflectivity = source.reflectivity;
          if (source.sheen) {
            this.sheen = (this.sheen || new Color()).copy(source.sheen);
          } else {
            this.sheen = null;
          }
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          return this;
        }
      }
      MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
      class MeshPhongMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.morphTargets = false;
          this.morphNormals = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
      class MeshToonMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "TOON": ""
          };
          this.type = "MeshToonMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.morphTargets = false;
          this.morphNormals = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          return this;
        }
      }
      MeshToonMaterial.prototype.isMeshToonMaterial = true;
      class MeshNormalMaterial extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.morphTargets = false;
          this.morphNormals = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
      class MeshLambertMaterial2 extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.morphTargets = false;
          this.morphNormals = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          return this;
        }
      }
      MeshLambertMaterial2.prototype.isMeshLambertMaterial = true;
      class MeshMatcapMaterial extends Material {
        constructor(parameters) {
          super();
          this.defines = {
            "MATCAP": ""
          };
          this.type = "MeshMatcapMaterial";
          this.color = new Color(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.morphTargets = false;
          this.morphNormals = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "MATCAP": ""
          };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.morphTargets = source.morphTargets;
          this.morphNormals = source.morphNormals;
          this.flatShading = source.flatShading;
          return this;
        }
      }
      MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
      class LineDashedMaterial extends LineBasicMaterial {
        constructor(parameters) {
          super();
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      }
      LineDashedMaterial.prototype.isLineDashedMaterial = true;
      var Materials = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ShadowMaterial,
        SpriteMaterial,
        RawShaderMaterial,
        ShaderMaterial,
        PointsMaterial,
        MeshPhysicalMaterial,
        MeshStandardMaterial,
        MeshPhongMaterial,
        MeshToonMaterial,
        MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial2,
        MeshDepthMaterial,
        MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial2,
        MeshMatcapMaterial,
        LineDashedMaterial,
        LineBasicMaterial,
        Material
      });
      const AnimationUtils = {
        arraySlice: function(array, from, to) {
          if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
          }
          return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
          if (!array || !forceClone && array.constructor === type)
            return array;
          if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
          }
          return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
          function compareTime(i, j) {
            return times[i] - times[j];
          }
          const n = times.length;
          const result = new Array(n);
          for (let i = 0; i !== n; ++i)
            result[i] = i;
          result.sort(compareTime);
          return result;
        },
        sortedArray: function(values, stride, order) {
          const nValues = values.length;
          const result = new values.constructor(nValues);
          for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
            const srcOffset = order[i] * stride;
            for (let j = 0; j !== stride; ++j) {
              result[dstOffset++] = values[srcOffset + j];
            }
          }
          return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
          let i = 1, key = jsonKeys[0];
          while (key !== void 0 && key[valuePropertyName] === void 0) {
            key = jsonKeys[i++];
          }
          if (key === void 0)
            return;
          let value = key[valuePropertyName];
          if (value === void 0)
            return;
          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push.apply(values, value);
              }
              key = jsonKeys[i++];
            } while (key !== void 0);
          } else if (value.toArray !== void 0) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i++];
            } while (key !== void 0);
          } else {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i++];
            } while (key !== void 0);
          }
        },
        subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
          const clip = sourceClip.clone();
          clip.name = name;
          const tracks = [];
          for (let i = 0; i < clip.tracks.length; ++i) {
            const track = clip.tracks[i];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j = 0; j < track.times.length; ++j) {
              const frame = track.times[j] * fps;
              if (frame < startFrame || frame >= endFrame)
                continue;
              times.push(track.times[j]);
              for (let k = 0; k < valueSize; ++k) {
                values.push(track.values[j * valueSize + k]);
              }
            }
            if (times.length === 0)
              continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
          }
          clip.tracks = tracks;
          let minStartTime = Infinity;
          for (let i = 0; i < clip.tracks.length; ++i) {
            if (minStartTime > clip.tracks[i].times[0]) {
              minStartTime = clip.tracks[i].times[0];
            }
          }
          for (let i = 0; i < clip.tracks.length; ++i) {
            clip.tracks[i].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        },
        makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
          if (fps <= 0)
            fps = 30;
          const numTracks = referenceClip.tracks.length;
          const referenceTime = referenceFrame / fps;
          for (let i = 0; i < numTracks; ++i) {
            const referenceTrack = referenceClip.tracks[i];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string")
              continue;
            const targetTrack = targetClip.tracks.find(function(track) {
              return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === void 0)
              continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
              const startIndex = lastIndex * referenceValueSize + referenceOffset;
              const endIndex = startIndex + referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
              const interpolant = referenceTrack.createInterpolant();
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              interpolant.evaluate(referenceTime);
              referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === "quaternion") {
              const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
              referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for (let j = 0; j < numTimes; ++j) {
              const valueStart = j * targetValueSize + targetOffset;
              if (referenceTrackType === "quaternion") {
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
              } else {
                const valueEnd = targetValueSize - targetOffset * 2;
                for (let k = 0; k < valueEnd; ++k) {
                  targetTrack.values[valueStart + k] -= referenceValue[k];
                }
              }
            }
          }
          targetClip.blendMode = AdditiveAnimationBlendMode;
          return targetClip;
        }
      };
      class Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t) {
          const pp = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t < t0)
                          break forward_scan;
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t, t0);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp[++i1];
                      if (t < t1) {
                        break seek;
                      }
                    }
                    right = pp.length;
                    break linear_scan;
                  }
                if (!(t >= t0)) {
                  const t1global = pp[1];
                  if (t < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.beforeStart_(0, t, t1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t < pp[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp[i1];
              t0 = pp[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (t1 === void 0) {
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t0, t);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index2) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
          for (let i = 0; i !== stride; ++i) {
            result[i] = values[offset + i];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
      Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
      class CubicInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
          const sP = -wP * ppp + 2 * wP * pp - wP * p;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
          const sN = wN * ppp - wN * pp;
          for (let i = 0; i !== stride; ++i) {
            result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
          }
          return result;
        }
      }
      class LinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i = 0; i !== stride; ++i) {
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
          }
          return result;
        }
      }
      class DiscreteInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      }
      class KeyframeTrack {
        constructor(name, times, values, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
          this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": AnimationUtils.convertArray(track.times, Array),
              "values": AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i = 0, n = times.length; i !== n; ++i) {
              times[i] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i = 0, n = times.length; i !== n; ++i) {
              times[i] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to !== -1 && times[to] > endTime) {
            --to;
          }
          ++to;
          if (from !== 0 || to !== nKeys) {
            if (from >= to) {
              to = Math.max(to, 1);
              from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i = 0; i !== nKeys; i++) {
            const currTime = times[i];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (AnimationUtils.isTypedArray(values)) {
              for (let i = 0, n = values.length; i !== n; ++i) {
                const value = values[i];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i = 1; i < lastIndex; ++i) {
            let keep = false;
            const time = times[i];
            const timeNext = times[i + 1];
            if (time !== timeNext && (i !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j = 0; j !== stride; ++j) {
                  const value = values[offset + j];
                  if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i !== writeIndex) {
                times[writeIndex] = times[i];
                const readOffset = i * stride, writeOffset = writeIndex * stride;
                for (let j = 0; j !== stride; ++j) {
                  values[writeOffset + j] = values[readOffset + j];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = AnimationUtils.arraySlice(this.times, 0);
          const values = AnimationUtils.arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      }
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      class BooleanKeyframeTrack extends KeyframeTrack {
      }
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ColorKeyframeTrack extends KeyframeTrack {
      }
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      class NumberKeyframeTrack extends KeyframeTrack {
      }
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      class QuaternionLinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      }
      class QuaternionKeyframeTrack extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      }
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class StringKeyframeTrack extends KeyframeTrack {
      }
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      class VectorKeyframeTrack extends KeyframeTrack {
      }
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      class AnimationClip {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i = 0, n = clipTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i = 0; i < numMorphTargets; i++) {
            let times = [];
            let values = [];
            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
          }
          for (let i = 0; i < clipArray.length; i++) {
            if (clipArray[i].name === name) {
              return clipArray[i];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i = 0, il = morphTargets.length; i < il; i++) {
            const morphTarget = morphTargets[i];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h = 0; h < hierarchyTracks.length; h++) {
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k;
              for (k = 0; k < animationKeys.length; k++) {
                if (animationKeys[k].morphTargets) {
                  for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                  const animationKey = animationKeys[k];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * (fps || 1);
            } else {
              const boneName = ".bones[" + bones[h].name + "]";
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
              addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i = 0, n = tracks.length; i !== n; ++i) {
            const track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i = 0; i < this.tracks.length; i++) {
            this.tracks[i].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i = 0; i < this.tracks.length; i++) {
            valid = valid && this.tracks[i].validate();
          }
          return valid;
        }
        optimize() {
          for (let i = 0; i < this.tracks.length; i++) {
            this.tracks[i].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i = 0; i < this.tracks.length; i++) {
            tracks.push(this.tracks[i].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function getTrackTypeForValueTypeName(typeName) {
        switch (typeName.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack;
          case "color":
            return ColorKeyframeTrack;
          case "quaternion":
            return QuaternionKeyframeTrack;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack;
          case "string":
            return StringKeyframeTrack;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
      }
      function parseKeyframeTrack(json) {
        if (json.type === void 0) {
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        }
        const trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === void 0) {
          const times = [], values = [];
          AnimationUtils.flattenJSON(json.keys, times, values, "value");
          json.times = times;
          json.values = values;
        }
        if (trackType.parse !== void 0) {
          return trackType.parse(json);
        } else {
          return new trackType(json.name, json.times, json.values, json.interpolation);
        }
      }
      const Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      class LoadingManager {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function(regex) {
            const index2 = handlers.indexOf(regex);
            if (index2 !== -1) {
              handlers.splice(index2, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i = 0, l = handlers.length; i < l; i += 2) {
              const regex = handlers[i];
              const loader = handlers[i + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        }
      }
      const DefaultLoadingManager = new LoadingManager();
      class Loader {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve2, reject) {
            scope.load(url, resolve2, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      }
      const loading = {};
      class FileLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
          const dataUriRegexResult = url.match(dataUriRegex);
          let request;
          if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64)
              data = atob(data);
            try {
              let response;
              const responseType = (this.responseType || "").toLowerCase();
              switch (responseType) {
                case "arraybuffer":
                case "blob":
                  const view = new Uint8Array(data.length);
                  for (let i = 0; i < data.length; i++) {
                    view[i] = data.charCodeAt(i);
                  }
                  if (responseType === "blob") {
                    response = new Blob([view.buffer], {
                      type: mimeType
                    });
                  } else {
                    response = view.buffer;
                  }
                  break;
                case "document":
                  const parser = new DOMParser();
                  response = parser.parseFromString(data, mimeType);
                  break;
                case "json":
                  response = JSON.parse(data);
                  break;
                default:
                  response = data;
                  break;
              }
              setTimeout(function() {
                if (onLoad)
                  onLoad(response);
                scope.manager.itemEnd(url);
              }, 0);
            } catch (error2) {
              setTimeout(function() {
                if (onError)
                  onError(error2);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
              }, 0);
            }
          } else {
            loading[url] = [];
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.addEventListener("load", function(event) {
              const response = this.response;
              const callbacks = loading[url];
              delete loading[url];
              if (this.status === 200 || this.status === 0) {
                if (this.status === 0)
                  console.warn("THREE.FileLoader: HTTP Status 0 received.");
                Cache.add(url, response);
                for (let i = 0, il = callbacks.length; i < il; i++) {
                  const callback = callbacks[i];
                  if (callback.onLoad)
                    callback.onLoad(response);
                }
                scope.manager.itemEnd(url);
              } else {
                for (let i = 0, il = callbacks.length; i < il; i++) {
                  const callback = callbacks[i];
                  if (callback.onError)
                    callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
              }
            }, false);
            request.addEventListener("progress", function(event) {
              const callbacks = loading[url];
              for (let i = 0, il = callbacks.length; i < il; i++) {
                const callback = callbacks[i];
                if (callback.onProgress)
                  callback.onProgress(event);
              }
            }, false);
            request.addEventListener("error", function(event) {
              const callbacks = loading[url];
              delete loading[url];
              for (let i = 0, il = callbacks.length; i < il; i++) {
                const callback = callbacks[i];
                if (callback.onError)
                  callback.onError(event);
              }
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }, false);
            request.addEventListener("abort", function(event) {
              const callbacks = loading[url];
              delete loading[url];
              for (let i = 0, il = callbacks.length; i < il; i++) {
                const callback = callbacks[i];
                if (callback.onError)
                  callback.onError(event);
              }
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }, false);
            if (this.responseType !== void 0)
              request.responseType = this.responseType;
            if (this.withCredentials !== void 0)
              request.withCredentials = this.withCredentials;
            if (request.overrideMimeType)
              request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
            for (const header in this.requestHeader) {
              request.setRequestHeader(header, this.requestHeader[header]);
            }
            request.send(null);
          }
          scope.manager.itemStart(url);
          return request;
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      }
      class AnimationLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const animations = [];
          for (let i = 0; i < json.length; i++) {
            const clip = AnimationClip.parse(json[i]);
            animations.push(clip);
          }
          return animations;
        }
      }
      class CompressedTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture();
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i) {
            loader.load(url[i], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i = 0, il = url.length; i < il; ++i) {
              loadTexture(i);
            }
          } else {
            loader.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f = 0; f < faces; f++) {
                  images[f] = {
                    mipmaps: []
                  };
                  for (let i = 0; i < texDatas.mipmapCount; i++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      }
      class ImageLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
          function onImageLoad() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      }
      class CubeTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          let loaded = 0;
          function loadTexture(i) {
            loader.load(urls[i], function(image) {
              texture.images[i] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i = 0; i < urls.length; ++i) {
            loadTexture(i);
          }
          return texture;
        }
      }
      class DataTextureLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const texture = new DataTexture();
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setPath(this.path);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData)
              return;
            if (texData.image !== void 0) {
              texture.image = texData.image;
            } else if (texData.data !== void 0) {
              texture.image.width = texData.width;
              texture.image.height = texData.height;
              texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
            if (texData.encoding !== void 0) {
              texture.encoding = texData.encoding;
            }
            if (texData.flipY !== void 0) {
              texture.flipY = texData.flipY;
            }
            if (texData.format !== void 0) {
              texture.format = texData.format;
            }
            if (texData.type !== void 0) {
              texture.type = texData.type;
            }
            if (texData.mipmaps !== void 0) {
              texture.mipmaps = texData.mipmaps;
              texture.minFilter = LinearMipmapLinearFilter;
            }
            if (texData.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            if (texData.generateMipmaps !== void 0) {
              texture.generateMipmaps = texData.generateMipmaps;
            }
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture, texData);
          }, onProgress, onError);
          return texture;
        }
      }
      class TextureLoader2 extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture2();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          loader.load(url, function(image) {
            texture.image = image;
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      }
      class CurvePath extends Curve {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
          }
        }
        getPoint(t) {
          const d2 = t * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i = 0;
          while (i < curveLengths.length) {
            if (curveLengths[i] >= d2) {
              const diff = curveLengths[i] - d2;
              const curve = this.curves[i];
              const segmentLength = curve.getLength();
              const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i = 0, l = this.curves.length; i < l; i++) {
            sums += this.curves[i].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i = 0; i <= divisions; i++) {
            points.push(this.getPoint(i / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i = 0, curves = this.curves; i < curves.length; i++) {
            const curve = curves[i];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
              const point = pts[j];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i = 0, l = source.curves.length; i < l; i++) {
            const curve = source.curves[i];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i = 0, l = this.curves.length; i < l; i++) {
            const curve = this.curves[i];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i = 0, l = json.curves.length; i < l; i++) {
            const curve = json.curves[i];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
          }
          return this;
        }
      }
      class Path2 extends CurvePath {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector22();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i = 1, l = points.length; i < l; i++) {
            this.lineTo(points[i].x, points[i].y);
          }
          return this;
        }
        moveTo(x, y) {
          this.currentPoint.set(x, y);
          return this;
        }
        lineTo(x, y) {
          const curve = new LineCurve(this.currentPoint.clone(), new Vector22(x, y));
          this.curves.push(curve);
          this.currentPoint.set(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector22(aCPx, aCPy), new Vector22(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector22(aCP1x, aCP1y), new Vector22(aCP2x, aCP2y), new Vector22(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      }
      class Shape2 extends Path2 {
        constructor(points) {
          super(points);
          this.uuid = generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i = 0, l = source.holes.length; i < l; i++) {
            const hole = source.holes[i];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i = 0, l = this.holes.length; i < l; i++) {
            const hole = this.holes[i];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i = 0, l = json.holes.length; i < l; i++) {
            const hole = json.holes[i];
            this.holes.push(new Path2().fromJSON(hole));
          }
          return this;
        }
      }
      class Light extends Object3D {
        constructor(color, intensity = 1) {
          super();
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      }
      Light.prototype.isLight = true;
      class HemisphereLight extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.type = "HemisphereLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source) {
          Light.prototype.copy.call(this, source);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      }
      HemisphereLight.prototype.isHemisphereLight = true;
      const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
      const _lookTarget$1 = /* @__PURE__ */ new Vector3();
      class LightShadow {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.mapSize = new Vector22(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector22(1, 1);
          this._viewportCount = 1;
          this._viewports = [new Vector4(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      }
      class SpotLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera2(50, 1, 0.5, 500));
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      }
      SpotLightShadow.prototype.isSpotLightShadow = true;
      class SpotLight extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
          super(color, intensity);
          this.type = "SpotLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      SpotLight.prototype.isSpotLight = true;
      const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      const _lightPositionWorld = /* @__PURE__ */ new Vector3();
      const _lookTarget = /* @__PURE__ */ new Vector3();
      class PointLightShadow extends LightShadow {
        constructor() {
          super(new PerspectiveCamera2(90, 1, 0.5, 500));
          this._frameExtents = new Vector22(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
          this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      }
      PointLightShadow.prototype.isPointLightShadow = true;
      class PointLight extends Light {
        constructor(color, intensity, distance = 0, decay = 1) {
          super(color, intensity);
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      PointLight.prototype.isPointLight = true;
      class OrthographicCamera2 extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      }
      OrthographicCamera2.prototype.isOrthographicCamera = true;
      class DirectionalLightShadow extends LightShadow {
        constructor() {
          super(new OrthographicCamera2(-5, 5, 5, -5, 0.5, 500));
        }
      }
      DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
      class DirectionalLight2 extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "DirectionalLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      }
      DirectionalLight2.prototype.isDirectionalLight = true;
      class AmbientLight2 extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "AmbientLight";
        }
      }
      AmbientLight2.prototype.isAmbientLight = true;
      class RectAreaLight extends Light {
        constructor(color, intensity, width = 10, height = 10) {
          super(color, intensity);
          this.type = "RectAreaLight";
          this.width = width;
          this.height = height;
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      }
      RectAreaLight.prototype.isRectAreaLight = true;
      class SphericalHarmonics3 {
        constructor() {
          this.coefficients = [];
          for (let i = 0; i < 9; i++) {
            this.coefficients.push(new Vector3());
          }
        }
        set(coefficients) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].copy(coefficients[i]);
          }
          return this;
        }
        zero() {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x = normal.x, y = normal.y, z2 = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z2);
          target.addScaledVector(coeff[3], 0.488603 * x);
          target.addScaledVector(coeff[4], 1.092548 * (x * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z2));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x * z2));
          target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x = normal.x, y = normal.y, z2 = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y * z2);
          target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x * z2);
          target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
          return target;
        }
        add(sh) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].add(sh.coefficients[i]);
          }
          return this;
        }
        addScaledSH(sh, s2) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].addScaledVector(sh.coefficients[i], s2);
          }
          return this;
        }
        scale(s2) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].multiplyScalar(s2);
          }
          return this;
        }
        lerp(sh, alpha) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].lerp(sh.coefficients[i], alpha);
          }
          return this;
        }
        equals(sh) {
          for (let i = 0; i < 9; i++) {
            if (!this.coefficients[i].equals(sh.coefficients[i])) {
              return false;
            }
          }
          return true;
        }
        copy(sh) {
          return this.set(sh.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i = 0; i < 9; i++) {
            coefficients[i].fromArray(array, offset + i * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i = 0; i < 9; i++) {
            coefficients[i].toArray(array, offset + i * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x = normal.x, y = normal.y, z2 = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z2;
          shBasis[3] = 0.488603 * x;
          shBasis[4] = 1.092548 * x * y;
          shBasis[5] = 1.092548 * y * z2;
          shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
          shBasis[7] = 1.092548 * x * z2;
          shBasis[8] = 0.546274 * (x * x - y * y);
        }
      }
      SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
      class LightProbe extends Light {
        constructor(sh = new SphericalHarmonics3(), intensity = 1) {
          super(void 0, intensity);
          this.sh = sh;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      }
      LightProbe.prototype.isLightProbe = true;
      class MaterialLoader extends Loader {
        constructor(manager) {
          super(manager);
          this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const textures = this.textures;
          function getTexture(name) {
            if (textures[name] === void 0) {
              console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
          }
          const material = new Materials[json.type]();
          if (json.uuid !== void 0)
            material.uuid = json.uuid;
          if (json.name !== void 0)
            material.name = json.name;
          if (json.color !== void 0 && material.color !== void 0)
            material.color.setHex(json.color);
          if (json.roughness !== void 0)
            material.roughness = json.roughness;
          if (json.metalness !== void 0)
            material.metalness = json.metalness;
          if (json.sheen !== void 0)
            material.sheen = new Color().setHex(json.sheen);
          if (json.emissive !== void 0 && material.emissive !== void 0)
            material.emissive.setHex(json.emissive);
          if (json.specular !== void 0 && material.specular !== void 0)
            material.specular.setHex(json.specular);
          if (json.shininess !== void 0)
            material.shininess = json.shininess;
          if (json.clearcoat !== void 0)
            material.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== void 0)
            material.clearcoatRoughness = json.clearcoatRoughness;
          if (json.transmission !== void 0)
            material.transmission = json.transmission;
          if (json.thickness !== void 0)
            material.thickness = json.thickness;
          if (json.attenuationDistance !== void 0)
            material.attenuationDistance = json.attenuationDistance;
          if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
            material.attenuationColor.setHex(json.attenuationColor);
          if (json.fog !== void 0)
            material.fog = json.fog;
          if (json.flatShading !== void 0)
            material.flatShading = json.flatShading;
          if (json.blending !== void 0)
            material.blending = json.blending;
          if (json.combine !== void 0)
            material.combine = json.combine;
          if (json.side !== void 0)
            material.side = json.side;
          if (json.shadowSide !== void 0)
            material.shadowSide = json.shadowSide;
          if (json.opacity !== void 0)
            material.opacity = json.opacity;
          if (json.transparent !== void 0)
            material.transparent = json.transparent;
          if (json.alphaTest !== void 0)
            material.alphaTest = json.alphaTest;
          if (json.depthTest !== void 0)
            material.depthTest = json.depthTest;
          if (json.depthWrite !== void 0)
            material.depthWrite = json.depthWrite;
          if (json.colorWrite !== void 0)
            material.colorWrite = json.colorWrite;
          if (json.stencilWrite !== void 0)
            material.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== void 0)
            material.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== void 0)
            material.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== void 0)
            material.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== void 0)
            material.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== void 0)
            material.stencilFail = json.stencilFail;
          if (json.stencilZFail !== void 0)
            material.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== void 0)
            material.stencilZPass = json.stencilZPass;
          if (json.wireframe !== void 0)
            material.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== void 0)
            material.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== void 0)
            material.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== void 0)
            material.wireframeLinejoin = json.wireframeLinejoin;
          if (json.rotation !== void 0)
            material.rotation = json.rotation;
          if (json.linewidth !== 1)
            material.linewidth = json.linewidth;
          if (json.dashSize !== void 0)
            material.dashSize = json.dashSize;
          if (json.gapSize !== void 0)
            material.gapSize = json.gapSize;
          if (json.scale !== void 0)
            material.scale = json.scale;
          if (json.polygonOffset !== void 0)
            material.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== void 0)
            material.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== void 0)
            material.polygonOffsetUnits = json.polygonOffsetUnits;
          if (json.morphTargets !== void 0)
            material.morphTargets = json.morphTargets;
          if (json.morphNormals !== void 0)
            material.morphNormals = json.morphNormals;
          if (json.dithering !== void 0)
            material.dithering = json.dithering;
          if (json.alphaToCoverage !== void 0)
            material.alphaToCoverage = json.alphaToCoverage;
          if (json.premultipliedAlpha !== void 0)
            material.premultipliedAlpha = json.premultipliedAlpha;
          if (json.vertexTangents !== void 0)
            material.vertexTangents = json.vertexTangents;
          if (json.visible !== void 0)
            material.visible = json.visible;
          if (json.toneMapped !== void 0)
            material.toneMapped = json.toneMapped;
          if (json.userData !== void 0)
            material.userData = json.userData;
          if (json.vertexColors !== void 0) {
            if (typeof json.vertexColors === "number") {
              material.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
              material.vertexColors = json.vertexColors;
            }
          }
          if (json.uniforms !== void 0) {
            for (const name in json.uniforms) {
              const uniform = json.uniforms[name];
              material.uniforms[name] = {};
              switch (uniform.type) {
                case "t":
                  material.uniforms[name].value = getTexture(uniform.value);
                  break;
                case "c":
                  material.uniforms[name].value = new Color().setHex(uniform.value);
                  break;
                case "v2":
                  material.uniforms[name].value = new Vector22().fromArray(uniform.value);
                  break;
                case "v3":
                  material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                  break;
                case "v4":
                  material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                  break;
                case "m3":
                  material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                  break;
                case "m4":
                  material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                  break;
                default:
                  material.uniforms[name].value = uniform.value;
              }
            }
          }
          if (json.defines !== void 0)
            material.defines = json.defines;
          if (json.vertexShader !== void 0)
            material.vertexShader = json.vertexShader;
          if (json.fragmentShader !== void 0)
            material.fragmentShader = json.fragmentShader;
          if (json.extensions !== void 0) {
            for (const key in json.extensions) {
              material.extensions[key] = json.extensions[key];
            }
          }
          if (json.shading !== void 0)
            material.flatShading = json.shading === 1;
          if (json.size !== void 0)
            material.size = json.size;
          if (json.sizeAttenuation !== void 0)
            material.sizeAttenuation = json.sizeAttenuation;
          if (json.map !== void 0)
            material.map = getTexture(json.map);
          if (json.matcap !== void 0)
            material.matcap = getTexture(json.matcap);
          if (json.alphaMap !== void 0)
            material.alphaMap = getTexture(json.alphaMap);
          if (json.bumpMap !== void 0)
            material.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== void 0)
            material.bumpScale = json.bumpScale;
          if (json.normalMap !== void 0)
            material.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== void 0)
            material.normalMapType = json.normalMapType;
          if (json.normalScale !== void 0) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
              normalScale = [normalScale, normalScale];
            }
            material.normalScale = new Vector22().fromArray(normalScale);
          }
          if (json.displacementMap !== void 0)
            material.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== void 0)
            material.displacementScale = json.displacementScale;
          if (json.displacementBias !== void 0)
            material.displacementBias = json.displacementBias;
          if (json.roughnessMap !== void 0)
            material.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== void 0)
            material.metalnessMap = getTexture(json.metalnessMap);
          if (json.emissiveMap !== void 0)
            material.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== void 0)
            material.emissiveIntensity = json.emissiveIntensity;
          if (json.specularMap !== void 0)
            material.specularMap = getTexture(json.specularMap);
          if (json.envMap !== void 0)
            material.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== void 0)
            material.envMapIntensity = json.envMapIntensity;
          if (json.reflectivity !== void 0)
            material.reflectivity = json.reflectivity;
          if (json.refractionRatio !== void 0)
            material.refractionRatio = json.refractionRatio;
          if (json.lightMap !== void 0)
            material.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== void 0)
            material.lightMapIntensity = json.lightMapIntensity;
          if (json.aoMap !== void 0)
            material.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== void 0)
            material.aoMapIntensity = json.aoMapIntensity;
          if (json.gradientMap !== void 0)
            material.gradientMap = getTexture(json.gradientMap);
          if (json.clearcoatMap !== void 0)
            material.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== void 0)
            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== void 0)
            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== void 0)
            material.clearcoatNormalScale = new Vector22().fromArray(json.clearcoatNormalScale);
          if (json.transmissionMap !== void 0)
            material.transmissionMap = getTexture(json.transmissionMap);
          if (json.thicknessMap !== void 0)
            material.thicknessMap = getTexture(json.thicknessMap);
          return material;
        }
        setTextures(value) {
          this.textures = value;
          return this;
        }
      }
      class LoaderUtils {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s2 = "";
          for (let i = 0, il = array.length; i < il; i++) {
            s2 += String.fromCharCode(array[i]);
          }
          try {
            return decodeURIComponent(escape(s2));
          } catch (e) {
            return s2;
          }
        }
        static extractUrlBase(url) {
          const index2 = url.lastIndexOf("/");
          if (index2 === -1)
            return "./";
          return url.substr(0, index2 + 1);
        }
      }
      class InstancedBufferGeometry extends BufferGeometry {
        constructor() {
          super();
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const data = super.toJSON(this);
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      }
      InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
      class InstancedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
          }
          super(array, itemSize, normalized);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      }
      InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
      class BufferGeometryLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const interleavedBufferMap = {};
          const arrayBufferMap = {};
          function getInterleavedBuffer(json2, uuid) {
            if (interleavedBufferMap[uuid] !== void 0)
              return interleavedBufferMap[uuid];
            const interleavedBuffers = json2.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
          }
          function getArrayBuffer(json2, uuid) {
            if (arrayBufferMap[uuid] !== void 0)
              return arrayBufferMap[uuid];
            const arrayBuffers = json2.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
          }
          const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
          const index2 = json.data.index;
          if (index2 !== void 0) {
            const typedArray = getTypedArray(index2.type, index2.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
          }
          const attributes = json.data.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
              bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            if (attribute.usage !== void 0)
              bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== void 0) {
              bufferAttribute.updateRange.offset = attribute.updateRange.offset;
              bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
          }
          const morphAttributes = json.data.morphAttributes;
          if (morphAttributes) {
            for (const key in morphAttributes) {
              const attributeArray = morphAttributes[key];
              const array = [];
              for (let i = 0, il = attributeArray.length; i < il; i++) {
                const attribute = attributeArray[i];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  const typedArray = getTypedArray(attribute.type, attribute.array);
                  bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== void 0)
                  bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
              }
              geometry.morphAttributes[key] = array;
            }
          }
          const morphTargetsRelative = json.data.morphTargetsRelative;
          if (morphTargetsRelative) {
            geometry.morphTargetsRelative = true;
          }
          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
          if (groups !== void 0) {
            for (let i = 0, n = groups.length; i !== n; ++i) {
              const group = groups[i];
              geometry.addGroup(group.start, group.count, group.materialIndex);
            }
          }
          const boundingSphere = json.data.boundingSphere;
          if (boundingSphere !== void 0) {
            const center = new Vector3();
            if (boundingSphere.center !== void 0) {
              center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
          }
          if (json.name)
            geometry.name = json.name;
          if (json.userData)
            geometry.userData = json.userData;
          return geometry;
        }
      }
      class ObjectLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            let json = null;
            try {
              json = JSON.parse(text);
            } catch (error2) {
              if (onError !== void 0)
                onError(error2);
              console.error("THREE:ObjectLoader: Can't parse " + url + ".", error2.message);
              return;
            }
            const metadata = json.metadata;
            if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
              console.error("THREE.ObjectLoader: Can't load " + url);
              return;
            }
            scope.parse(json, onLoad);
          }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          const text = await loader.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = this.parseImages(json.images, function() {
            if (onLoad !== void 0)
              onLoad(object);
          });
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          if (onLoad !== void 0) {
            let hasImages = false;
            for (const uuid in images) {
              if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
              }
            }
            if (hasImages === false)
              onLoad(object);
          }
          return object;
        }
        async parseAsync(json) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = await this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          return object;
        }
        parseShapes(json) {
          const shapes = {};
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const shape = new Shape2().fromJSON(json[i]);
              shapes[shape.uuid] = shape;
            }
          }
          return shapes;
        }
        parseSkeletons(json, object) {
          const skeletons = {};
          const bones = {};
          object.traverse(function(child) {
            if (child.isBone)
              bones[child.uuid] = child;
          });
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const skeleton = new Skeleton().fromJSON(json[i], bones);
              skeletons[skeleton.uuid] = skeleton;
            }
          }
          return skeletons;
        }
        parseGeometries(json, shapes) {
          const geometries = {};
          if (json !== void 0) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for (let i = 0, l = json.length; i < l; i++) {
              let geometry;
              const data = json[i];
              switch (data.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  geometry = bufferGeometryLoader.parse(data);
                  break;
                case "Geometry":
                  console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                  break;
                default:
                  if (data.type in Geometries) {
                    geometry = Geometries[data.type].fromJSON(data, shapes);
                  } else {
                    console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
              }
              geometry.uuid = data.uuid;
              if (data.name !== void 0)
                geometry.name = data.name;
              if (geometry.isBufferGeometry === true && data.userData !== void 0)
                geometry.userData = data.userData;
              geometries[data.uuid] = geometry;
            }
          }
          return geometries;
        }
        parseMaterials(json, textures) {
          const cache = {};
          const materials = {};
          if (json !== void 0) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for (let i = 0, l = json.length; i < l; i++) {
              const data = json[i];
              if (data.type === "MultiMaterial") {
                const array = [];
                for (let j = 0; j < data.materials.length; j++) {
                  const material = data.materials[j];
                  if (cache[material.uuid] === void 0) {
                    cache[material.uuid] = loader.parse(material);
                  }
                  array.push(cache[material.uuid]);
                }
                materials[data.uuid] = array;
              } else {
                if (cache[data.uuid] === void 0) {
                  cache[data.uuid] = loader.parse(data);
                }
                materials[data.uuid] = cache[data.uuid];
              }
            }
          }
          return materials;
        }
        parseAnimations(json) {
          const animations = {};
          if (json !== void 0) {
            for (let i = 0; i < json.length; i++) {
              const data = json[i];
              const clip = AnimationClip.parse(data);
              animations[clip.uuid] = clip;
            }
          }
          return animations;
        }
        parseImages(json, onLoad) {
          const scope = this;
          const images = {};
          let loader;
          function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            }, void 0, function() {
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            });
          }
          function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return loadImage(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i = 0, il = json.length; i < il; i++) {
              const image = json[i];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        async parseImagesAsync(json) {
          const scope = this;
          const images = {};
          let loader;
          async function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return await loader.loadAsync(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i = 0, il = json.length; i < il; i++) {
              const image = json[i];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = await deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = await deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        parseTextures(json, images) {
          function parseConstant(value, type) {
            if (typeof value === "number")
              return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
          }
          const textures = {};
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const data = json[i];
              if (data.image === void 0) {
                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
              }
              if (images[data.image] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined image", data.image);
              }
              let texture;
              const image = images[data.image];
              if (Array.isArray(image)) {
                texture = new CubeTexture(image);
                if (image.length === 6)
                  texture.needsUpdate = true;
              } else {
                if (image && image.data) {
                  texture = new DataTexture(image.data, image.width, image.height);
                } else {
                  texture = new Texture2(image);
                }
                if (image)
                  texture.needsUpdate = true;
              }
              texture.uuid = data.uuid;
              if (data.name !== void 0)
                texture.name = data.name;
              if (data.mapping !== void 0)
                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
              if (data.offset !== void 0)
                texture.offset.fromArray(data.offset);
              if (data.repeat !== void 0)
                texture.repeat.fromArray(data.repeat);
              if (data.center !== void 0)
                texture.center.fromArray(data.center);
              if (data.rotation !== void 0)
                texture.rotation = data.rotation;
              if (data.wrap !== void 0) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
              }
              if (data.format !== void 0)
                texture.format = data.format;
              if (data.type !== void 0)
                texture.type = data.type;
              if (data.encoding !== void 0)
                texture.encoding = data.encoding;
              if (data.minFilter !== void 0)
                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
              if (data.magFilter !== void 0)
                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
              if (data.anisotropy !== void 0)
                texture.anisotropy = data.anisotropy;
              if (data.flipY !== void 0)
                texture.flipY = data.flipY;
              if (data.premultiplyAlpha !== void 0)
                texture.premultiplyAlpha = data.premultiplyAlpha;
              if (data.unpackAlignment !== void 0)
                texture.unpackAlignment = data.unpackAlignment;
              textures[data.uuid] = texture;
            }
          }
          return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
          let object;
          function getGeometry(name) {
            if (geometries[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined geometry", name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === void 0)
              return void 0;
            if (Array.isArray(name)) {
              const array = [];
              for (let i = 0, l = name.length; i < l; i++) {
                const uuid = name[i];
                if (materials[uuid] === void 0) {
                  console.warn("THREE.ObjectLoader: Undefined material", uuid);
                }
                array.push(materials[uuid]);
              }
              return array;
            }
            if (materials[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", name);
            }
            return materials[name];
          }
          function getTexture(uuid) {
            if (textures[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            }
            return textures[uuid];
          }
          let geometry, material;
          switch (data.type) {
            case "Scene":
              object = new Scene2();
              if (data.background !== void 0) {
                if (Number.isInteger(data.background)) {
                  object.background = new Color(data.background);
                } else {
                  object.background = getTexture(data.background);
                }
              }
              if (data.environment !== void 0)
                object.environment = getTexture(data.environment);
              if (data.fog !== void 0) {
                if (data.fog.type === "Fog") {
                  object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                } else if (data.fog.type === "FogExp2") {
                  object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
              }
              break;
            case "PerspectiveCamera":
              object = new PerspectiveCamera2(data.fov, data.aspect, data.near, data.far);
              if (data.focus !== void 0)
                object.focus = data.focus;
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.filmGauge !== void 0)
                object.filmGauge = data.filmGauge;
              if (data.filmOffset !== void 0)
                object.filmOffset = data.filmOffset;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "OrthographicCamera":
              object = new OrthographicCamera2(data.left, data.right, data.top, data.bottom, data.near, data.far);
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "AmbientLight":
              object = new AmbientLight2(data.color, data.intensity);
              break;
            case "DirectionalLight":
              object = new DirectionalLight2(data.color, data.intensity);
              break;
            case "PointLight":
              object = new PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case "RectAreaLight":
              object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
              break;
            case "SpotLight":
              object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
              break;
            case "HemisphereLight":
              object = new HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case "LightProbe":
              object = new LightProbe().fromJSON(data);
              break;
            case "SkinnedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new SkinnedMesh(geometry, material);
              if (data.bindMode !== void 0)
                object.bindMode = data.bindMode;
              if (data.bindMatrix !== void 0)
                object.bindMatrix.fromArray(data.bindMatrix);
              if (data.skeleton !== void 0)
                object.skeleton = data.skeleton;
              break;
            case "Mesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new Mesh2(geometry, material);
              break;
            case "InstancedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              const count = data.count;
              const instanceMatrix = data.instanceMatrix;
              const instanceColor = data.instanceColor;
              object = new InstancedMesh(geometry, material, count);
              object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
              if (instanceColor !== void 0)
                object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
              break;
            case "LOD":
              object = new LOD();
              break;
            case "Line":
              object = new Line(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineLoop":
              object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineSegments":
              object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "PointCloud":
            case "Points":
              object = new Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "Sprite":
              object = new Sprite(getMaterial(data.material));
              break;
            case "Group":
              object = new Group2();
              break;
            case "Bone":
              object = new Bone();
              break;
            default:
              object = new Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== void 0)
            object.name = data.name;
          if (data.matrix !== void 0) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== void 0)
              object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate)
              object.matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== void 0)
              object.position.fromArray(data.position);
            if (data.rotation !== void 0)
              object.rotation.fromArray(data.rotation);
            if (data.quaternion !== void 0)
              object.quaternion.fromArray(data.quaternion);
            if (data.scale !== void 0)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== void 0)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== void 0)
            object.receiveShadow = data.receiveShadow;
          if (data.shadow) {
            if (data.shadow.bias !== void 0)
              object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== void 0)
              object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== void 0)
              object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== void 0)
              object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== void 0)
              object.shadow.camera = this.parseObject(data.shadow.camera);
          }
          if (data.visible !== void 0)
            object.visible = data.visible;
          if (data.frustumCulled !== void 0)
            object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== void 0)
            object.renderOrder = data.renderOrder;
          if (data.userData !== void 0)
            object.userData = data.userData;
          if (data.layers !== void 0)
            object.layers.mask = data.layers;
          if (data.children !== void 0) {
            const children = data.children;
            for (let i = 0; i < children.length; i++) {
              object.add(this.parseObject(children[i], geometries, materials, textures, animations));
            }
          }
          if (data.animations !== void 0) {
            const objectAnimations = data.animations;
            for (let i = 0; i < objectAnimations.length; i++) {
              const uuid = objectAnimations[i];
              object.animations.push(animations[uuid]);
            }
          }
          if (data.type === "LOD") {
            if (data.autoUpdate !== void 0)
              object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for (let l = 0; l < levels.length; l++) {
              const level = levels[l];
              const child = object.getObjectByProperty("uuid", level.object);
              if (child !== void 0) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        }
        bindSkeletons(object, skeletons) {
          if (Object.keys(skeletons).length === 0)
            return;
          object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
              const skeleton = skeletons[child.skeleton];
              if (skeleton === void 0) {
                console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
              } else {
                child.bind(skeleton, child.bindMatrix);
              }
            }
          });
        }
        setTexturePath(value) {
          console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
          return this.setResourcePath(value);
        }
      }
      const TEXTURE_MAPPING = {
        UVMapping,
        CubeReflectionMapping,
        CubeRefractionMapping,
        EquirectangularReflectionMapping,
        EquirectangularRefractionMapping,
        CubeUVReflectionMapping,
        CubeUVRefractionMapping
      };
      const TEXTURE_WRAPPING = {
        RepeatWrapping,
        ClampToEdgeWrapping,
        MirroredRepeatWrapping
      };
      const TEXTURE_FILTER = {
        NearestFilter,
        NearestMipmapNearestFilter,
        NearestMipmapLinearFilter,
        LinearFilter,
        LinearMipmapNearestFilter,
        LinearMipmapLinearFilter
      };
      class ImageBitmapLoader extends Loader {
        constructor(manager) {
          super(manager);
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(options2) {
          this.options = options2;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e) {
            if (onError)
              onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      }
      ImageBitmapLoader.prototype.isImageBitmapLoader = true;
      class ShapePath {
        constructor() {
          this.type = "ShapePath";
          this.color = new Color();
          this.subPaths = [];
          this.currentPath = null;
        }
        moveTo(x, y) {
          this.currentPath = new Path2();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x, y);
          return this;
        }
        lineTo(x, y) {
          this.currentPath.lineTo(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
        }
        splineThru(pts) {
          this.currentPath.splineThru(pts);
          return this;
        }
        toShapes(isCCW, noHoles) {
          function toShapesNoHoles(inSubpaths) {
            const shapes2 = [];
            for (let i = 0, l = inSubpaths.length; i < l; i++) {
              const tmpPath2 = inSubpaths[i];
              const tmpShape2 = new Shape2();
              tmpShape2.curves = tmpPath2.curves;
              shapes2.push(tmpShape2);
            }
            return shapes2;
          }
          function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
              let edgeLowPt = inPolygon[p];
              let edgeHighPt = inPolygon[q];
              let edgeDx = edgeHighPt.x - edgeLowPt.x;
              let edgeDy = edgeHighPt.y - edgeLowPt.y;
              if (Math.abs(edgeDy) > Number.EPSILON) {
                if (edgeDy < 0) {
                  edgeLowPt = inPolygon[q];
                  edgeDx = -edgeDx;
                  edgeHighPt = inPolygon[p];
                  edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                  continue;
                if (inPt.y === edgeLowPt.y) {
                  if (inPt.x === edgeLowPt.x)
                    return true;
                } else {
                  const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                  if (perpEdge === 0)
                    return true;
                  if (perpEdge < 0)
                    continue;
                  inside = !inside;
                }
              } else {
                if (inPt.y !== edgeLowPt.y)
                  continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                  return true;
              }
            }
            return inside;
          }
          const isClockWise = ShapeUtils.isClockWise;
          const subPaths = this.subPaths;
          if (subPaths.length === 0)
            return [];
          if (noHoles === true)
            return toShapesNoHoles(subPaths);
          let solid, tmpPath, tmpShape;
          const shapes = [];
          if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape2();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
          }
          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;
          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;
          newShapes[mainIdx] = void 0;
          newShapeHoles[mainIdx] = [];
          for (let i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
              if (!holesFirst && newShapes[mainIdx])
                mainIdx++;
              newShapes[mainIdx] = {
                s: new Shape2(),
                p: tmpPoints
              };
              newShapes[mainIdx].s.curves = tmpPath.curves;
              if (holesFirst)
                mainIdx++;
              newShapeHoles[mainIdx] = [];
            } else {
              newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
              });
            }
          }
          if (!newShapes[0])
            return toShapesNoHoles(subPaths);
          if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              const sho = newShapeHoles[sIdx];
              for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                const ho = sho[hIdx];
                let hole_unassigned = true;
                for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                  if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                      toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                      });
                    if (hole_unassigned) {
                      hole_unassigned = false;
                      betterShapeHoles[s2Idx].push(ho);
                    } else {
                      ambiguous = true;
                    }
                  }
                }
                if (hole_unassigned) {
                  betterShapeHoles[sIdx].push(ho);
                }
              }
            }
            if (toChange.length > 0) {
              if (!ambiguous)
                newShapeHoles = betterShapeHoles;
            }
          }
          let tmpHoles;
          for (let i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
              tmpShape.holes.push(tmpHoles[j].h);
            }
          }
          return shapes;
        }
      }
      class Font {
        constructor(data) {
          this.type = "Font";
          this.data = data;
        }
        generateShapes(text, size = 100) {
          const shapes = [];
          const paths = createPaths(text, size, this.data);
          for (let p = 0, pl = paths.length; p < pl; p++) {
            Array.prototype.push.apply(shapes, paths[p].toShapes());
          }
          return shapes;
        }
      }
      function createPaths(text, size, data) {
        const chars2 = Array.from(text);
        const scale = size / data.resolution;
        const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        const paths = [];
        let offsetX = 0, offsetY = 0;
        for (let i = 0; i < chars2.length; i++) {
          const char = chars2[i];
          if (char === "\n") {
            offsetX = 0;
            offsetY -= line_height;
          } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
          }
        }
        return paths;
      }
      function createPath(char, scale, offsetX, offsetY, data) {
        const glyph = data.glyphs[char] || data.glyphs["?"];
        if (!glyph) {
          console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
          return;
        }
        const path = new ShapePath();
        let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
          const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
          for (let i = 0, l = outline.length; i < l; ) {
            const action = outline[i++];
            switch (action) {
              case "m":
                x = outline[i++] * scale + offsetX;
                y = outline[i++] * scale + offsetY;
                path.moveTo(x, y);
                break;
              case "l":
                x = outline[i++] * scale + offsetX;
                y = outline[i++] * scale + offsetY;
                path.lineTo(x, y);
                break;
              case "q":
                cpx = outline[i++] * scale + offsetX;
                cpy = outline[i++] * scale + offsetY;
                cpx1 = outline[i++] * scale + offsetX;
                cpy1 = outline[i++] * scale + offsetY;
                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                break;
              case "b":
                cpx = outline[i++] * scale + offsetX;
                cpy = outline[i++] * scale + offsetY;
                cpx1 = outline[i++] * scale + offsetX;
                cpy1 = outline[i++] * scale + offsetY;
                cpx2 = outline[i++] * scale + offsetX;
                cpy2 = outline[i++] * scale + offsetY;
                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                break;
            }
          }
        }
        return {
          offsetX: glyph.ha * scale,
          path
        };
      }
      Font.prototype.isFont = true;
      class FontLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            let json;
            try {
              json = JSON.parse(text);
            } catch (e) {
              console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
              json = JSON.parse(text.substring(65, text.length - 2));
            }
            const font = scope.parse(json);
            if (onLoad)
              onLoad(font);
          }, onProgress, onError);
        }
        parse(json) {
          return new Font(json);
        }
      }
      let _context;
      const AudioContext = {
        getContext: function() {
          if (_context === void 0) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context;
        },
        setContext: function(value) {
          _context = value;
        }
      };
      class AudioLoader extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      }
      class HemisphereLightProbe extends LightProbe {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(skyColor);
          const color2 = new Color().set(groundColor);
          const sky = new Vector3(color1.r, color1.g, color1.b);
          const ground = new Vector3(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      }
      HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
      class AmbientLightProbe extends LightProbe {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      AmbientLightProbe.prototype.isAmbientLightProbe = true;
      const _eyeRight = /* @__PURE__ */ new Matrix4();
      const _eyeLeft = /* @__PURE__ */ new Matrix4();
      class StereoCamera {
        constructor() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new PerspectiveCamera2();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = false;
          this.cameraR = new PerspectiveCamera2();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = false;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(camera) {
          const cache = this._cache;
          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
          if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
          }
          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
      }
      class Clock {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      }
      function now() {
        return (typeof performance === "undefined" ? Date : performance).now();
      }
      const _position$1 = /* @__PURE__ */ new Vector3();
      const _quaternion$1 = /* @__PURE__ */ new Quaternion();
      const _scale$1 = /* @__PURE__ */ new Vector3();
      const _orientation$1 = /* @__PURE__ */ new Vector3();
      class AudioListener extends Object3D {
        constructor() {
          super();
          this.type = "AudioListener";
          this.context = AudioContext.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Clock();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          return this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(value) {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
          } else {
            this.gain.disconnect(this.context.destination);
          }
          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);
          return this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          const listener = this.context.listener;
          const up = this.up;
          this.timeDelta = this._clock.getDelta();
          this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
          _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
          if (listener.positionX) {
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
          } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
          }
        }
      }
      class Audio extends Object3D {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i = 1, l = this.filters.length; i < l; i++) {
              this.filters[i - 1].connect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i = 1, l = this.filters.length; i < l; i++) {
              this.filters[i - 1].disconnect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter) {
          return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      }
      const _position = /* @__PURE__ */ new Vector3();
      const _quaternion = /* @__PURE__ */ new Quaternion();
      const _scale = /* @__PURE__ */ new Vector3();
      const _orientation = /* @__PURE__ */ new Vector3();
      class PositionalAudio extends Audio {
        constructor(listener) {
          super(listener);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(value) {
          this.panner.refDistance = value;
          return this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
          this.panner.rolloffFactor = value;
          return this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(value) {
          this.panner.distanceModel = value;
          return this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(value) {
          this.panner.maxDistance = value;
          return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.hasPlaybackControl === true && this.isPlaying === false)
            return;
          this.matrixWorld.decompose(_position, _quaternion, _scale);
          _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
          const panner = this.panner;
          if (panner.positionX) {
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
          } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
          }
        }
      }
      class AudioAnalyser {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i = 0; i < data.length; i++) {
            value += data[i];
          }
          return value / data.length;
        }
      }
      class PropertyMixer {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i = 0; i !== stride; ++i) {
              buffer[offset + i] = buffer[i];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i = stride, e = stride + stride; i !== e; ++i) {
            if (buffer[i] !== buffer[i + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i = stride, e = originalValueOffset; i !== e; ++i) {
            buffer[i] = buffer[originalValueOffset + i % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i = startIndex; i < endIndex; i++) {
            this.buffer[i] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++) {
            this.buffer[targetIndex + i] = this.buffer[startIndex + i];
          }
        }
        _select(buffer, dstOffset, srcOffset, t, stride) {
          if (t >= 0.5) {
            for (let i = 0; i !== stride; ++i) {
              buffer[dstOffset + i] = buffer[srcOffset + i];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
          const s2 = 1 - t;
          for (let i = 0; i !== stride; ++i) {
            const j = dstOffset + i;
            buffer[j] = buffer[j] * s2 + buffer[srcOffset + i] * t;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          for (let i = 0; i !== stride; ++i) {
            const j = dstOffset + i;
            buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
          }
        }
      }
      const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
      const _supportedObjectNames = ["material", "materials", "bones"];
      class Composite {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].unbind();
          }
        }
      }
      class PropertyBinding {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
          this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
          } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (!matches) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i = 0; i < children.length; i++) {
                const childNode = children[i];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.node[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i = 0, n = source.length; i !== n; ++i) {
            buffer[offset++] = source[i];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i = 0; i < targetObject.length; i++) {
                  if (targetObject[i].name === objectIndex) {
                    objectIndex = i;
                    break;
                  }
                }
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (targetObject.geometry.isBufferGeometry) {
                if (!targetObject.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                  propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                }
              } else {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                return;
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      }
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]];
      class AnimationObjectGroup {
        constructor() {
          this.uuid = generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid;
            let index2 = indicesByUUID[uuid];
            if (index2 === void 0) {
              index2 = nObjects++;
              indicesByUUID[uuid] = index2;
              objects.push(object);
              for (let j = 0, m = nBindings; j !== m; ++j) {
                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
              }
            } else if (index2 < nCachedObjects) {
              knownObject = objects[index2];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index2;
              objects[index2] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index2];
                bindingsForPath[index2] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index2] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== void 0 && index2 >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index2;
              objects[index2] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
                bindingsForPath[index2] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== void 0) {
              delete indicesByUUID[uuid];
              if (index2 < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index2;
                objects[index2] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index2] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index2;
                }
                objects[index2] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j];
                  bindingsForPath[index2] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index2 = indicesByPath[path];
          const bindings = this._bindings;
          if (index2 !== void 0)
            return bindings[index2];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index2 = bindings.length;
          indicesByPath[path] = index2;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
            const object = objects[i];
            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path];
          if (index2 !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index2;
            bindings[index2] = lastBindings;
            bindings.pop();
            parsedPaths[index2] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index2] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      }
      AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
      class AnimationAction {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i = 0; i !== nTracks; ++i) {
            const interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          times[1] = now2 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now2 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          values[0] = weightNow;
          times[1] = now2 + duration;
          values[1] = weightThen;
          return this;
        }
      }
      class AnimationMixer extends EventDispatcher {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i = 0; i !== nTracks; ++i) {
            const track = tracks[i], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              bindings[i] = binding;
            } else {
              binding = bindings[i];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
              binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i = 0, n = bindings.length; i !== n; ++i) {
              const binding = bindings[i];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i = 0, n = bindings.length; i !== n; ++i) {
              const binding = bindings[i];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index2 = action._cacheIndex;
          return index2 !== null && index2 < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i = 0, n = bindings.length; i !== n; ++i) {
            const binding = bindings[i];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i = nActions - 1; i >= 0; --i) {
            actions[i].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i = 0; i !== nActions; ++i) {
            const action = actions[i];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i = 0; i !== nBindings; ++i) {
            bindings[i].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i = 0; i < this._actions.length; i++) {
            this._actions[i].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
              const action = actionsToRemove[i];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      }
      AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Uniform {
        constructor(value) {
          if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
          }
          this.value = value;
        }
        clone() {
          return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      }
      class InstancedInterleavedBuffer extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      }
      InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
      class GLBufferAttribute {
        constructor(buffer, type, itemSize, elementSize, count) {
          this.buffer = buffer;
          this.type = type;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type, elementSize) {
          this.type = type;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      }
      GLBufferAttribute.prototype.isGLBufferAttribute = true;
      class Raycaster {
        constructor(origin, direction, near = 0, far = Infinity) {
          this.ray = new Ray(origin, direction);
          this.near = near;
          this.far = far;
          this.camera = null;
          this.layers = new Layers();
          this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(origin, direction) {
          this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
          if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
          } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
          } else {
            console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
          }
        }
        intersectObject(object, recursive = false, intersects2 = []) {
          intersectObject(object, this, intersects2, recursive);
          intersects2.sort(ascSort);
          return intersects2;
        }
        intersectObjects(objects, recursive = false, intersects2 = []) {
          for (let i = 0, l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects2, recursive);
          }
          intersects2.sort(ascSort);
          return intersects2;
        }
      }
      function ascSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects2, recursive) {
        if (object.layers.test(raycaster.layers)) {
          object.raycast(raycaster, intersects2);
        }
        if (recursive === true) {
          const children = object.children;
          for (let i = 0, l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects2, true);
          }
        }
      }
      class Spherical {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z2) {
          this.radius = Math.sqrt(x * x + y * y + z2 * z2);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x, z2);
            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Cylindrical {
        constructor(radius = 1, theta = 0, y = 0) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        set(radius, theta, y) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z2) {
          this.radius = Math.sqrt(x * x + z2 * z2);
          this.theta = Math.atan2(x, z2);
          this.y = y;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _vector$4 = /* @__PURE__ */ new Vector22();
      class Box2 {
        constructor(min = new Vector22(Infinity, Infinity), max = new Vector22(-Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      }
      Box2.prototype.isBox2 = true;
      const _startP = /* @__PURE__ */ new Vector3();
      const _startEnd = /* @__PURE__ */ new Vector3();
      class Line3 {
        constructor(start = new Vector3(), end = new Vector3()) {
          this.start = start;
          this.end = end;
        }
        set(start, end) {
          this.start.copy(start);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, target) {
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);
          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);
          let t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = clamp(t, 0, 1);
          }
          return t;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ImmediateRenderObject extends Object3D {
        constructor(material) {
          super();
          this.material = material;
          this.render = function() {
          };
          this.hasPositions = false;
          this.hasNormals = false;
          this.hasColors = false;
          this.hasUvs = false;
          this.positionArray = null;
          this.normalArray = null;
          this.colorArray = null;
          this.uvArray = null;
          this.count = 0;
        }
      }
      ImmediateRenderObject.prototype.isImmediateRenderObject = true;
      const _vector$3 = /* @__PURE__ */ new Vector3();
      class SpotLightHelper extends Object3D {
        constructor(light, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new BufferGeometry();
          const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
            const p1 = i / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
          });
          this.cone = new LineSegments(geometry, material);
          this.add(this.cone);
          this.update();
        }
        dispose() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const coneLength = this.light.distance ? this.light.distance : 1e3;
          const coneWidth = coneLength * Math.tan(this.light.angle);
          this.cone.scale.set(coneWidth, coneWidth, coneLength);
          _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(_vector$3);
          if (this.color !== void 0) {
            this.cone.material.color.set(this.color);
          } else {
            this.cone.material.color.copy(this.light.color);
          }
        }
      }
      const _vector$2 = /* @__PURE__ */ new Vector3();
      const _boneMatrix = /* @__PURE__ */ new Matrix4();
      const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      class SkeletonHelper extends LineSegments {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry = new BufferGeometry();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i = 0; i < bones.length; i++) {
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(geometry, material);
          this.type = "SkeletonHelper";
          this.isSkeletonHelper = true;
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i = 0, j = 0; i < bones.length; i++) {
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
      }
      function getBoneList(object) {
        const boneList = [];
        if (object && object.isBone) {
          boneList.push(object);
        }
        for (let i = 0; i < object.children.length; i++) {
          boneList.push.apply(boneList, getBoneList(object.children[i]));
        }
        return boneList;
      }
      class PointLightHelper extends Mesh2 {
        constructor(light, sphereSize, color) {
          const geometry = new SphereGeometry(sphereSize, 4, 2);
          const material = new MeshBasicMaterial2({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          super(geometry, material);
          this.light = light;
          this.light.updateMatrixWorld();
          this.color = color;
          this.type = "PointLightHelper";
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.update();
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
        update() {
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            this.material.color.copy(this.light.color);
          }
        }
      }
      const _vector$1 = /* @__PURE__ */ new Vector3();
      const _color1 = /* @__PURE__ */ new Color();
      const _color2 = /* @__PURE__ */ new Color();
      class HemisphereLightHelper extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new OctahedronGeometry(size);
          geometry.rotateY(Math.PI * 0.5);
          this.material = new MeshBasicMaterial2({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          if (this.color === void 0)
            this.material.vertexColors = true;
          const position = geometry.getAttribute("position");
          const colors = new Float32Array(position.count * 3);
          geometry.setAttribute("color", new BufferAttribute(colors, 3));
          this.add(new Mesh2(geometry, this.material));
          this.update();
        }
        dispose() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
        update() {
          const mesh = this.children[0];
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            const colors = mesh.geometry.getAttribute("color");
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for (let i = 0, l = colors.count; i < l; i++) {
              const color = i < l / 2 ? _color1 : _color2;
              colors.setXYZ(i, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
          }
          mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class GridHelper extends LineSegments {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "GridHelper";
        }
      }
      class PolarGridHelper extends LineSegments {
        constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const vertices = [];
          const colors = [];
          for (let i = 0; i <= radials; i++) {
            const v = i / radials * (Math.PI * 2);
            const x = Math.sin(v) * radius;
            const z2 = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z2);
            const color = i & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
          }
          for (let i = 0; i <= circles; i++) {
            const color = i & 1 ? color1 : color2;
            const r = radius - radius / circles * i;
            for (let j = 0; j < divisions; j++) {
              let v = j / divisions * (Math.PI * 2);
              let x = Math.sin(v) * r;
              let z2 = Math.cos(v) * r;
              vertices.push(x, 0, z2);
              colors.push(color.r, color.g, color.b);
              v = (j + 1) / divisions * (Math.PI * 2);
              x = Math.sin(v) * r;
              z2 = Math.cos(v) * r;
              vertices.push(x, 0, z2);
              colors.push(color.r, color.g, color.b);
            }
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "PolarGridHelper";
        }
      }
      const _v1 = /* @__PURE__ */ new Vector3();
      const _v2 = /* @__PURE__ */ new Vector3();
      const _v3 = /* @__PURE__ */ new Vector3();
      class DirectionalLightHelper extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          if (size === void 0)
            size = 1;
          let geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
          const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new Line(geometry, material);
          this.add(this.lightPlane);
          geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new Line(geometry, material);
          this.add(this.targetLine);
          this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        }
        update() {
          _v1.setFromMatrixPosition(this.light.matrixWorld);
          _v2.setFromMatrixPosition(this.light.target.matrixWorld);
          _v3.subVectors(_v2, _v1);
          this.lightPlane.lookAt(_v2);
          if (this.color !== void 0) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
          } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
          }
          this.targetLine.lookAt(_v2);
          this.targetLine.scale.z = _v3.length();
        }
      }
      const _vector = /* @__PURE__ */ new Vector3();
      const _camera = /* @__PURE__ */ new Camera();
      class CameraHelper extends LineSegments {
        constructor(camera) {
          const geometry = new BufferGeometry();
          const material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
          });
          const vertices = [];
          const colors = [];
          const pointMap = {};
          const colorFrustum = new Color(16755200);
          const colorCone = new Color(16711680);
          const colorUp = new Color(43775);
          const colorTarget = new Color(16777215);
          const colorCross = new Color(3355443);
          addLine("n1", "n2", colorFrustum);
          addLine("n2", "n4", colorFrustum);
          addLine("n4", "n3", colorFrustum);
          addLine("n3", "n1", colorFrustum);
          addLine("f1", "f2", colorFrustum);
          addLine("f2", "f4", colorFrustum);
          addLine("f4", "f3", colorFrustum);
          addLine("f3", "f1", colorFrustum);
          addLine("n1", "f1", colorFrustum);
          addLine("n2", "f2", colorFrustum);
          addLine("n3", "f3", colorFrustum);
          addLine("n4", "f4", colorFrustum);
          addLine("p", "n1", colorCone);
          addLine("p", "n2", colorCone);
          addLine("p", "n3", colorCone);
          addLine("p", "n4", colorCone);
          addLine("u1", "u2", colorUp);
          addLine("u2", "u3", colorUp);
          addLine("u3", "u1", colorUp);
          addLine("c", "t", colorTarget);
          addLine("p", "c", colorCross);
          addLine("cn1", "cn2", colorCross);
          addLine("cn3", "cn4", colorCross);
          addLine("cf1", "cf2", colorCross);
          addLine("cf3", "cf4", colorCross);
          function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
          }
          function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === void 0) {
              pointMap[id] = [];
            }
            pointMap[id].push(vertices.length / 3 - 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          super(geometry, material);
          this.type = "CameraHelper";
          this.camera = camera;
          if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
          this.matrix = camera.matrixWorld;
          this.matrixAutoUpdate = false;
          this.pointMap = pointMap;
          this.update();
        }
        update() {
          const geometry = this.geometry;
          const pointMap = this.pointMap;
          const w = 1, h = 1;
          _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
          setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
          setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
          setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
          setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
          setPoint("n4", pointMap, geometry, _camera, w, h, -1);
          setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
          setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
          setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
          setPoint("f4", pointMap, geometry, _camera, w, h, 1);
          setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
          setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
          setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
          setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
          setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
          setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
          setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
          setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
          setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
          setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
          setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
          geometry.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      }
      function setPoint(point, pointMap, geometry, camera, x, y, z2) {
        _vector.set(x, y, z2).unproject(camera);
        const points = pointMap[point];
        if (points !== void 0) {
          const position = geometry.getAttribute("position");
          for (let i = 0, l = points.length; i < l; i++) {
            position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
          }
        }
      }
      const _box = /* @__PURE__ */ new Box3();
      class BoxHelper extends LineSegments {
        constructor(object, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = new Float32Array(8 * 3);
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.object = object;
          this.type = "BoxHelper";
          this.matrixAutoUpdate = false;
          this.update();
        }
        update(object) {
          if (object !== void 0) {
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          }
          if (this.object !== void 0) {
            _box.setFromObject(this.object);
          }
          if (_box.isEmpty())
            return;
          const min = _box.min;
          const max = _box.max;
          const position = this.geometry.attributes.position;
          const array = position.array;
          array[0] = max.x;
          array[1] = max.y;
          array[2] = max.z;
          array[3] = min.x;
          array[4] = max.y;
          array[5] = max.z;
          array[6] = min.x;
          array[7] = min.y;
          array[8] = max.z;
          array[9] = max.x;
          array[10] = min.y;
          array[11] = max.z;
          array[12] = max.x;
          array[13] = max.y;
          array[14] = min.z;
          array[15] = min.x;
          array[16] = max.y;
          array[17] = min.z;
          array[18] = min.x;
          array[19] = min.y;
          array[20] = min.z;
          array[21] = max.x;
          array[22] = min.y;
          array[23] = min.z;
          position.needsUpdate = true;
          this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
          this.object = object;
          this.update();
          return this;
        }
        copy(source) {
          LineSegments.prototype.copy.call(this, source);
          this.object = source.object;
          return this;
        }
      }
      class Box3Helper extends LineSegments {
        constructor(box, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.box = box;
          this.type = "Box3Helper";
          this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
          const box = this.box;
          if (box.isEmpty())
            return;
          box.getCenter(this.position);
          box.getSize(this.scale);
          this.scale.multiplyScalar(0.5);
          super.updateMatrixWorld(force);
        }
      }
      class PlaneHelper extends Line {
        constructor(plane, size = 1, hex = 16776960) {
          const color = hex;
          const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          geometry.computeBoundingSphere();
          super(geometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.type = "PlaneHelper";
          this.plane = plane;
          this.size = size;
          const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
          const geometry2 = new BufferGeometry();
          geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
          geometry2.computeBoundingSphere();
          this.add(new Mesh2(geometry2, new MeshBasicMaterial2({
            color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
          })));
        }
        updateMatrixWorld(force) {
          let scale = -this.plane.constant;
          if (Math.abs(scale) < 1e-8)
            scale = 1e-8;
          this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
          this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
          this.lookAt(this.plane.normal);
          super.updateMatrixWorld(force);
        }
      }
      const _axis = /* @__PURE__ */ new Vector3();
      let _lineGeometry, _coneGeometry;
      class ArrowHelper extends Object3D {
        constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
          super();
          this.type = "ArrowHelper";
          if (_lineGeometry === void 0) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
          }
          this.position.copy(origin);
          this.line = new Line(_lineGeometry, new LineBasicMaterial({
            color,
            toneMapped: false
          }));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
          this.cone = new Mesh2(_coneGeometry, new MeshBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.cone.matrixAutoUpdate = false;
          this.add(this.cone);
          this.setDirection(dir);
          this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
          if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
          } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
          } else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
          }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
          this.line.updateMatrix();
          this.cone.scale.set(headWidth, headLength, headWidth);
          this.cone.position.y = length;
          this.cone.updateMatrix();
        }
        setColor(color) {
          this.line.material.color.set(color);
          this.cone.material.color.set(color);
        }
        copy(source) {
          super.copy(source, false);
          this.line.copy(source.line);
          this.cone.copy(source.cone);
          return this;
        }
      }
      class AxesHelper extends LineSegments {
        constructor(size = 1) {
          const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
          const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "AxesHelper";
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
          const color = new Color();
          const array = this.geometry.attributes.color.array;
          color.set(xAxisColor);
          color.toArray(array, 0);
          color.toArray(array, 3);
          color.set(yAxisColor);
          color.toArray(array, 6);
          color.toArray(array, 9);
          color.set(zAxisColor);
          color.toArray(array, 12);
          color.toArray(array, 15);
          this.geometry.attributes.color.needsUpdate = true;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      }
      const _floatView = new Float32Array(1);
      const _int32View = new Int32Array(_floatView.buffer);
      class DataUtils {
        static toHalfFloat(val) {
          _floatView[0] = val;
          const x = _int32View[0];
          let bits = x >> 16 & 32768;
          let m = x >> 12 & 2047;
          const e = x >> 23 & 255;
          if (e < 103)
            return bits;
          if (e > 142) {
            bits |= 31744;
            bits |= (e == 255 ? 0 : 1) && x & 8388607;
            return bits;
          }
          if (e < 113) {
            m |= 2048;
            bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
          }
          bits |= e - 112 << 10 | m >> 1;
          bits += m & 1;
          return bits;
        }
      }
      const LOD_MIN = 4;
      const LOD_MAX = 8;
      const SIZE_MAX = Math.pow(2, LOD_MAX);
      const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
      const MAX_SAMPLES = 20;
      const ENCODINGS = {
        [LinearEncoding]: 0,
        [sRGBEncoding]: 1,
        [RGBEEncoding]: 2,
        [RGBM7Encoding]: 3,
        [RGBM16Encoding]: 4,
        [RGBDEncoding]: 5,
        [GammaEncoding]: 6
      };
      const backgroundMaterial = new MeshBasicMaterial2({
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh2(new BoxGeometry(), backgroundMaterial);
      const _flatCamera = /* @__PURE__ */ new OrthographicCamera2();
      const {
        _lodPlanes,
        _sizeLods,
        _sigmas
      } = /* @__PURE__ */ _createPlanes();
      const _clearColor = /* @__PURE__ */ new Color();
      let _oldTarget = null;
      const PHI = (1 + Math.sqrt(5)) / 2;
      const INV_PHI = 1 / PHI;
      const _axisDirections = [/* @__PURE__ */ new Vector3(1, 1, 1), /* @__PURE__ */ new Vector3(-1, 1, 1), /* @__PURE__ */ new Vector3(1, 1, -1), /* @__PURE__ */ new Vector3(-1, 1, -1), /* @__PURE__ */ new Vector3(0, PHI, INV_PHI), /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI), /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0), /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)];
      function convertLinearToRGBE(color) {
        const maxComponent = Math.max(color.r, color.g, color.b);
        const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
        color.multiplyScalar(Math.pow(2, -fExp));
        const alpha = (fExp + 128) / 255;
        return alpha;
      }
      class PMREMGenerator {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._blurMaterial = _getBlurShader(MAX_SAMPLES);
          this._equirectShader = null;
          this._cubemapShader = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets();
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular) {
          return this._fromTexture(equirectangular);
        }
        fromCubemap(cubemap) {
          return this._fromTexture(cubemap);
        }
        compileCubemapShader() {
          if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
          }
        }
        dispose() {
          this._blurMaterial.dispose();
          if (this._cubemapShader !== null)
            this._cubemapShader.dispose();
          if (this._equirectShader !== null)
            this._equirectShader.dispose();
          for (let i = 0; i < _lodPlanes.length; i++) {
            _lodPlanes[i].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._pingPongRenderTarget.dispose();
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets(texture);
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets(texture) {
          const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(params);
          cubeUVRenderTarget.depthBuffer = texture ? false : true;
          this._pingPongRenderTarget = _createRenderTarget(params);
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh2(_lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera2(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const outputEncoding = renderer.outputEncoding;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping;
          renderer.outputEncoding = LinearEncoding;
          renderer.autoClear = false;
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background).convertSRGBToLinear();
              scene.background = null;
              const alpha = convertLinearToRGBE(backgroundMaterial.color);
              backgroundMaterial.opacity = alpha;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
            const alpha = convertLinearToRGBE(backgroundMaterial.color);
            backgroundMaterial.opacity = alpha;
            useSolidColor = true;
          }
          for (let i = 0; i < 6; i++) {
            const col = i % 3;
            if (col == 0) {
              cubeCamera.up.set(0, upSign[i], 0);
              cubeCamera.lookAt(forwardSign[i], 0, 0);
            } else if (col == 1) {
              cubeCamera.up.set(0, 0, upSign[i]);
              cubeCamera.lookAt(0, forwardSign[i], 0);
            } else {
              cubeCamera.up.set(0, upSign[i], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          renderer.toneMapping = toneMapping;
          renderer.outputEncoding = outputEncoding;
          renderer.autoClear = originalAutoClear;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          if (texture.isCubeTexture) {
            if (this._cubemapShader == null) {
              this._cubemapShader = _getCubemapShader();
            }
          } else {
            if (this._equirectShader == null) {
              this._equirectShader = _getEquirectShader();
            }
          }
          const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
          const mesh = new Mesh2(_lodPlanes[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          if (!texture.isCubeTexture) {
            uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
          }
          uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
          uniforms["outputEncoding"].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i = 1; i < TOTAL_LODS; i++) {
            const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
            const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
          this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh2(_lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = _sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum = 0;
          for (let i = 0; i < MAX_SAMPLES; ++i) {
            const x2 = i / sigmaPixels;
            const weight = Math.exp(-x2 * x2 / 2);
            weights.push(weight);
            if (i == 0) {
              sum += weight;
            } else if (i < samples) {
              sum += 2 * weight;
            }
          }
          for (let i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = LOD_MAX - lodIn;
          blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
          blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
          const outputSize = _sizeLods[lodOut];
          const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
          const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
          _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      }
      function _isLDR(texture) {
        if (texture === void 0 || texture.type !== UnsignedByteType)
          return false;
        return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
      }
      function _createPlanes() {
        const _lodPlanes2 = [];
        const _sizeLods2 = [];
        const _sigmas2 = [];
        let lod = LOD_MAX;
        for (let i = 0; i < TOTAL_LODS; i++) {
          const sizeLod = Math.pow(2, lod);
          _sizeLods2.push(sizeLod);
          let sigma = 1 / sizeLod;
          if (i > LOD_MAX - LOD_MIN) {
            sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
          } else if (i == 0) {
            sigma = 0;
          }
          _sigmas2.push(sigma);
          const texelSize = 1 / (sizeLod - 1);
          const min = -texelSize / 2;
          const max = 1 + texelSize / 2;
          const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
          const cubeFaces = 6;
          const vertices = 6;
          const positionSize = 3;
          const uvSize = 2;
          const faceIndexSize = 1;
          const position = new Float32Array(positionSize * vertices * cubeFaces);
          const uv = new Float32Array(uvSize * vertices * cubeFaces);
          const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
          for (let face = 0; face < cubeFaces; face++) {
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
          }
          const planes = new BufferGeometry();
          planes.setAttribute("position", new BufferAttribute(position, positionSize));
          planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
          planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
          _lodPlanes2.push(planes);
          if (lod > LOD_MIN) {
            lod--;
          }
        }
        return {
          _lodPlanes: _lodPlanes2,
          _sizeLods: _sizeLods2,
          _sigmas: _sigmas2
        };
      }
      function _createRenderTarget(params) {
        const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
      }
      function _setViewport(target, x, y, width, height) {
        target.viewport.set(x, y, width, height);
        target.scissor.set(x, y, width, height);
      }
      function _getBlurShader(maxSamples) {
        const weights = new Float32Array(maxSamples);
        const poleAxis = new Vector3(0, 1, 0);
        const shaderMaterial = new RawShaderMaterial({
          name: "SphericalGaussianBlur",
          defines: {
            "n": maxSamples
          },
          uniforms: {
            "envMap": {
              value: null
            },
            "samples": {
              value: 1
            },
            "weights": {
              value: weights
            },
            "latitudinal": {
              value: false
            },
            "dTheta": {
              value: 0
            },
            "mipInt": {
              value: 0
            },
            "poleAxis": {
              value: poleAxis
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getEquirectShader() {
        const texelSize = new Vector22(1, 1);
        const shaderMaterial = new RawShaderMaterial({
          name: "EquirectangularToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "texelSize": {
              value: texelSize
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCubemapShader() {
        const shaderMaterial = new RawShaderMaterial({
          name: "CubemapToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "inputEncoding": {
              value: ENCODINGS[LinearEncoding]
            },
            "outputEncoding": {
              value: ENCODINGS[LinearEncoding]
            }
          },
          vertexShader: _getCommonVertexShader(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
          blending: NoBlending,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCommonVertexShader() {
        return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function _getEncodings() {
        return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
      }
      const LineStrip = 0;
      const LinePieces = 1;
      const NoColors = 0;
      const FaceColors = 1;
      const VertexColors = 2;
      function MeshFaceMaterial(materials) {
        console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
        return materials;
      }
      function MultiMaterial(materials = []) {
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
          return materials.slice();
        };
        return materials;
      }
      function PointCloud(geometry, material) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Points(geometry, material);
      }
      function Particle(material) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Sprite(material);
      }
      function ParticleSystem(geometry, material) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Points(geometry, material);
      }
      function PointCloudMaterial(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleBasicMaterial(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function ParticleSystemMaterial(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial(parameters);
      }
      function Vertex(x, y, z2) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new Vector3(x, y, z2);
      }
      function DynamicBufferAttribute(array, itemSize) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
        return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
      }
      function Int8Attribute(array, itemSize) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new Int8BufferAttribute(array, itemSize);
      }
      function Uint8Attribute(array, itemSize) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new Uint8BufferAttribute(array, itemSize);
      }
      function Uint8ClampedAttribute(array, itemSize) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new Uint8ClampedBufferAttribute(array, itemSize);
      }
      function Int16Attribute(array, itemSize) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new Int16BufferAttribute(array, itemSize);
      }
      function Uint16Attribute(array, itemSize) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new Uint16BufferAttribute(array, itemSize);
      }
      function Int32Attribute(array, itemSize) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        return new Int32BufferAttribute(array, itemSize);
      }
      function Uint32Attribute(array, itemSize) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new Uint32BufferAttribute(array, itemSize);
      }
      function Float32Attribute(array, itemSize) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        return new Float32BufferAttribute(array, itemSize);
      }
      function Float64Attribute(array, itemSize) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new Float64BufferAttribute(array, itemSize);
      }
      Curve.create = function(construct, getPoint) {
        console.log("THREE.Curve.create() has been deprecated");
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
      };
      Path2.prototype.fromPoints = function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      };
      function AxisHelper(size) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        return new AxesHelper(size);
      }
      function BoundingBoxHelper(object, color) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new BoxHelper(object, color);
      }
      function EdgesHelper(object, hex) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      };
      SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      };
      function WireframeHelper(object, hex) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      Loader.prototype.extractUrlBase = function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
      };
      Loader.Handlers = {
        add: function() {
          console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
        },
        get: function() {
          console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
        }
      };
      function XHRLoader(manager) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new FileLoader(manager);
      }
      function BinaryTextureLoader(manager) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new DataTextureLoader(manager);
      }
      Box2.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box2.prototype.empty = function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box2.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box2.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Box3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box3.prototype.empty = function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box3.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box3.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Box3.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Sphere.prototype.empty = function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Frustum.prototype.setFromMatrix = function(m) {
        console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
        return this.setFromProjectionMatrix(m);
      };
      Line3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix3.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      };
      Matrix3.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      };
      Matrix3.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      };
      Matrix3.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      };
      Matrix3.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Matrix4.prototype.extractPosition = function(m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
      };
      Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix4.prototype.getPosition = function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
      };
      Matrix4.prototype.setRotationFromQuaternion = function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      };
      Matrix4.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Matrix4.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector4 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      };
      Matrix4.prototype.rotateAxis = function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      };
      Matrix4.prototype.crossVector = function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Matrix4.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Matrix4.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Matrix4.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Matrix4.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Matrix4.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      };
      Matrix4.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      };
      Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      };
      Matrix4.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Plane.prototype.isIntersectionLine = function(line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
      };
      Quaternion.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
      };
      Quaternion.prototype.inverse = function() {
        console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
        return this.invert();
      };
      Ray.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Ray.prototype.isIntersectionPlane = function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      };
      Ray.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Triangle.prototype.area = function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      };
      Triangle.prototype.barycoordFromPoint = function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      };
      Triangle.prototype.midpoint = function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      };
      Triangle.prototypenormal = function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      };
      Triangle.prototype.plane = function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      };
      Triangle.barycoordFromPoint = function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
      };
      Triangle.normal = function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
      };
      Shape2.prototype.extractAllPoints = function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      };
      Shape2.prototype.extrude = function(options2) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options2);
      };
      Shape2.prototype.makeGeometry = function(options2) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options2);
      };
      Vector22.prototype.fromAttribute = function(attribute, index2, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      };
      Vector22.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector22.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector3.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      };
      Vector3.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      };
      Vector3.prototype.getPositionFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
      };
      Vector3.prototype.getScaleFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
      };
      Vector3.prototype.getColumnFromMatrix = function(index2, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index2);
      };
      Vector3.prototype.applyProjection = function(m) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m);
      };
      Vector3.prototype.fromAttribute = function(attribute, index2, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      };
      Vector3.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector3.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector4.prototype.fromAttribute = function(attribute, index2, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index2, offset);
      };
      Vector4.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Object3D.prototype.getChildByName = function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      };
      Object3D.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      };
      Object3D.prototype.translate = function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      };
      Object3D.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      };
      Object3D.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
          get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
          }
        },
        useQuaternion: {
          get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          },
          set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          }
        }
      });
      Mesh2.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      };
      Object.defineProperties(Mesh2.prototype, {
        drawMode: {
          get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return TrianglesDrawMode;
          },
          set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
          }
        }
      });
      SkinnedMesh.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      PerspectiveCamera2.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== void 0)
          this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
      };
      Object.defineProperties(Light.prototype, {
        onlyShadow: {
          set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
          }
        },
        shadowCameraLeft: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
          }
        },
        shadowCameraRight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
          }
        },
        shadowCameraTop: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
          }
        },
        shadowCameraBottom: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
          }
        },
        shadowCameraNear: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
          }
        },
        shadowCameraFar: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
          }
        },
        shadowCameraVisible: {
          set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
          }
        },
        shadowBias: {
          set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
          }
        },
        shadowDarkness: {
          set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
          }
        },
        shadowMapHeight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
          }
        }
      });
      Object.defineProperties(BufferAttribute.prototype, {
        length: {
          get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
          }
        },
        dynamic: {
          get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === DynamicDrawUsage;
          },
          set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(DynamicDrawUsage);
          }
        }
      });
      BufferAttribute.prototype.setDynamic = function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      BufferAttribute.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, BufferAttribute.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      BufferGeometry.prototype.addIndex = function(index2) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index2);
      };
      BufferGeometry.prototype.addAttribute = function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      };
      BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      };
      BufferGeometry.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      };
      BufferGeometry.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      };
      BufferGeometry.prototype.removeAttribute = function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      };
      BufferGeometry.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
          get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
          }
        },
        offsets: {
          get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
          }
        }
      });
      InterleavedBuffer.prototype.setDynamic = function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      InterleavedBuffer.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      ExtrudeGeometry.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      ExtrudeGeometry.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      };
      ExtrudeGeometry.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Scene2.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Uniform.prototype.onUpdate = function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      };
      Object.defineProperties(Material.prototype, {
        wrapAround: {
          get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
          }
        },
        shading: {
          get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
          }
        },
        stencilMask: {
          get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
          }
        }
      });
      Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
          get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
          },
          set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
          }
        }
      });
      WebGLRenderer2.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      WebGLRenderer2.prototype.animate = function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      };
      WebGLRenderer2.prototype.getCurrentRenderTarget = function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      };
      WebGLRenderer2.prototype.getMaxAnisotropy = function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      };
      WebGLRenderer2.prototype.getPrecision = function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      };
      WebGLRenderer2.prototype.resetGLState = function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      };
      WebGLRenderer2.prototype.supportsFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      };
      WebGLRenderer2.prototype.supportsHalfFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      };
      WebGLRenderer2.prototype.supportsStandardDerivatives = function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      };
      WebGLRenderer2.prototype.supportsCompressedTextureS3TC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      };
      WebGLRenderer2.prototype.supportsCompressedTexturePVRTC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      };
      WebGLRenderer2.prototype.supportsBlendMinMax = function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      };
      WebGLRenderer2.prototype.supportsVertexTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      };
      WebGLRenderer2.prototype.supportsInstancedArrays = function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      };
      WebGLRenderer2.prototype.enableScissorTest = function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      };
      WebGLRenderer2.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      WebGLRenderer2.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      WebGLRenderer2.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      WebGLRenderer2.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      };
      WebGLRenderer2.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      };
      WebGLRenderer2.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      };
      WebGLRenderer2.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      WebGLRenderer2.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      WebGLRenderer2.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      };
      WebGLRenderer2.prototype.getActiveMipMapLevel = function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      };
      Object.defineProperties(WebGLRenderer2.prototype, {
        shadowMapEnabled: {
          get: function() {
            return this.shadowMap.enabled;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return this.shadowMap.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        context: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
          }
        },
        vr: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
          }
        },
        gammaInput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          }
        },
        gammaOutput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
          }
        },
        toneMappingWhitePoint: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          }
        }
      });
      Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        renderReverseSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          }
        },
        renderSingleSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          }
        }
      });
      function WebGLRenderTargetCube(width, height, options2) {
        console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
        return new WebGLCubeRenderTarget(width, options2);
      }
      Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
          }
        },
        wrapT: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
          }
        },
        magFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
          }
        },
        minFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
          }
        },
        anisotropy: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
          }
        },
        offset: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
          }
        },
        repeat: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
          }
        },
        format: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
          }
        },
        type: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
          }
        },
        generateMipmaps: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
          }
        }
      });
      Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      };
      AudioAnalyser.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
      };
      CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(renderer, scene);
      };
      CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
        return this.renderTarget.clear(renderer, color, depth, stencil);
      };
      ImageUtils.crossOrigin = void 0;
      ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const loader = new TextureLoader2();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(url, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const loader = new CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(urls, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      };
      ImageUtils.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function JSONLoader() {
        console.error("THREE.JSONLoader has been removed.");
      }
      const SceneUtils = {
        createMultiMaterialObject: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        detach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        attach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        }
      };
      function LensFlare() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
          detail: {
            revision: REVISION
          }
        }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
      exports2.ACESFilmicToneMapping = ACESFilmicToneMapping;
      exports2.AddEquation = AddEquation;
      exports2.AddOperation = AddOperation;
      exports2.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
      exports2.AdditiveBlending = AdditiveBlending;
      exports2.AlphaFormat = AlphaFormat;
      exports2.AlwaysDepth = AlwaysDepth;
      exports2.AlwaysStencilFunc = AlwaysStencilFunc;
      exports2.AmbientLight = AmbientLight2;
      exports2.AmbientLightProbe = AmbientLightProbe;
      exports2.AnimationClip = AnimationClip;
      exports2.AnimationLoader = AnimationLoader;
      exports2.AnimationMixer = AnimationMixer;
      exports2.AnimationObjectGroup = AnimationObjectGroup;
      exports2.AnimationUtils = AnimationUtils;
      exports2.ArcCurve = ArcCurve;
      exports2.ArrayCamera = ArrayCamera;
      exports2.ArrowHelper = ArrowHelper;
      exports2.Audio = Audio;
      exports2.AudioAnalyser = AudioAnalyser;
      exports2.AudioContext = AudioContext;
      exports2.AudioListener = AudioListener;
      exports2.AudioLoader = AudioLoader;
      exports2.AxesHelper = AxesHelper;
      exports2.AxisHelper = AxisHelper;
      exports2.BackSide = BackSide;
      exports2.BasicDepthPacking = BasicDepthPacking;
      exports2.BasicShadowMap = BasicShadowMap;
      exports2.BinaryTextureLoader = BinaryTextureLoader;
      exports2.Bone = Bone;
      exports2.BooleanKeyframeTrack = BooleanKeyframeTrack;
      exports2.BoundingBoxHelper = BoundingBoxHelper;
      exports2.Box2 = Box2;
      exports2.Box3 = Box3;
      exports2.Box3Helper = Box3Helper;
      exports2.BoxBufferGeometry = BoxGeometry;
      exports2.BoxGeometry = BoxGeometry;
      exports2.BoxHelper = BoxHelper;
      exports2.BufferAttribute = BufferAttribute;
      exports2.BufferGeometry = BufferGeometry;
      exports2.BufferGeometryLoader = BufferGeometryLoader;
      exports2.ByteType = ByteType;
      exports2.Cache = Cache;
      exports2.Camera = Camera;
      exports2.CameraHelper = CameraHelper;
      exports2.CanvasRenderer = CanvasRenderer;
      exports2.CanvasTexture = CanvasTexture2;
      exports2.CatmullRomCurve3 = CatmullRomCurve3;
      exports2.CineonToneMapping = CineonToneMapping;
      exports2.CircleBufferGeometry = CircleGeometry;
      exports2.CircleGeometry = CircleGeometry;
      exports2.ClampToEdgeWrapping = ClampToEdgeWrapping;
      exports2.Clock = Clock;
      exports2.Color = Color;
      exports2.ColorKeyframeTrack = ColorKeyframeTrack;
      exports2.CompressedTexture = CompressedTexture;
      exports2.CompressedTextureLoader = CompressedTextureLoader;
      exports2.ConeBufferGeometry = ConeGeometry;
      exports2.ConeGeometry = ConeGeometry;
      exports2.CubeCamera = CubeCamera;
      exports2.CubeReflectionMapping = CubeReflectionMapping;
      exports2.CubeRefractionMapping = CubeRefractionMapping;
      exports2.CubeTexture = CubeTexture;
      exports2.CubeTextureLoader = CubeTextureLoader;
      exports2.CubeUVReflectionMapping = CubeUVReflectionMapping;
      exports2.CubeUVRefractionMapping = CubeUVRefractionMapping;
      exports2.CubicBezierCurve = CubicBezierCurve;
      exports2.CubicBezierCurve3 = CubicBezierCurve3;
      exports2.CubicInterpolant = CubicInterpolant;
      exports2.CullFaceBack = CullFaceBack;
      exports2.CullFaceFront = CullFaceFront;
      exports2.CullFaceFrontBack = CullFaceFrontBack;
      exports2.CullFaceNone = CullFaceNone;
      exports2.Curve = Curve;
      exports2.CurvePath = CurvePath;
      exports2.CustomBlending = CustomBlending;
      exports2.CustomToneMapping = CustomToneMapping;
      exports2.CylinderBufferGeometry = CylinderGeometry;
      exports2.CylinderGeometry = CylinderGeometry;
      exports2.Cylindrical = Cylindrical;
      exports2.DataTexture = DataTexture;
      exports2.DataTexture2DArray = DataTexture2DArray;
      exports2.DataTexture3D = DataTexture3D;
      exports2.DataTextureLoader = DataTextureLoader;
      exports2.DataUtils = DataUtils;
      exports2.DecrementStencilOp = DecrementStencilOp;
      exports2.DecrementWrapStencilOp = DecrementWrapStencilOp;
      exports2.DefaultLoadingManager = DefaultLoadingManager;
      exports2.DepthFormat = DepthFormat;
      exports2.DepthStencilFormat = DepthStencilFormat;
      exports2.DepthTexture = DepthTexture;
      exports2.DirectionalLight = DirectionalLight2;
      exports2.DirectionalLightHelper = DirectionalLightHelper;
      exports2.DiscreteInterpolant = DiscreteInterpolant;
      exports2.DodecahedronBufferGeometry = DodecahedronGeometry;
      exports2.DodecahedronGeometry = DodecahedronGeometry;
      exports2.DoubleSide = DoubleSide2;
      exports2.DstAlphaFactor = DstAlphaFactor;
      exports2.DstColorFactor = DstColorFactor;
      exports2.DynamicBufferAttribute = DynamicBufferAttribute;
      exports2.DynamicCopyUsage = DynamicCopyUsage;
      exports2.DynamicDrawUsage = DynamicDrawUsage;
      exports2.DynamicReadUsage = DynamicReadUsage;
      exports2.EdgesGeometry = EdgesGeometry;
      exports2.EdgesHelper = EdgesHelper;
      exports2.EllipseCurve = EllipseCurve;
      exports2.EqualDepth = EqualDepth;
      exports2.EqualStencilFunc = EqualStencilFunc;
      exports2.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
      exports2.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
      exports2.Euler = Euler;
      exports2.EventDispatcher = EventDispatcher;
      exports2.ExtrudeBufferGeometry = ExtrudeGeometry;
      exports2.ExtrudeGeometry = ExtrudeGeometry;
      exports2.FaceColors = FaceColors;
      exports2.FileLoader = FileLoader;
      exports2.FlatShading = FlatShading;
      exports2.Float16BufferAttribute = Float16BufferAttribute;
      exports2.Float32Attribute = Float32Attribute;
      exports2.Float32BufferAttribute = Float32BufferAttribute;
      exports2.Float64Attribute = Float64Attribute;
      exports2.Float64BufferAttribute = Float64BufferAttribute;
      exports2.FloatType = FloatType;
      exports2.Fog = Fog;
      exports2.FogExp2 = FogExp2;
      exports2.Font = Font;
      exports2.FontLoader = FontLoader;
      exports2.FrontSide = FrontSide;
      exports2.Frustum = Frustum;
      exports2.GLBufferAttribute = GLBufferAttribute;
      exports2.GLSL1 = GLSL1;
      exports2.GLSL3 = GLSL3;
      exports2.GammaEncoding = GammaEncoding;
      exports2.GreaterDepth = GreaterDepth;
      exports2.GreaterEqualDepth = GreaterEqualDepth;
      exports2.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
      exports2.GreaterStencilFunc = GreaterStencilFunc;
      exports2.GridHelper = GridHelper;
      exports2.Group = Group2;
      exports2.HalfFloatType = HalfFloatType;
      exports2.HemisphereLight = HemisphereLight;
      exports2.HemisphereLightHelper = HemisphereLightHelper;
      exports2.HemisphereLightProbe = HemisphereLightProbe;
      exports2.IcosahedronBufferGeometry = IcosahedronGeometry;
      exports2.IcosahedronGeometry = IcosahedronGeometry;
      exports2.ImageBitmapLoader = ImageBitmapLoader;
      exports2.ImageLoader = ImageLoader;
      exports2.ImageUtils = ImageUtils;
      exports2.ImmediateRenderObject = ImmediateRenderObject;
      exports2.IncrementStencilOp = IncrementStencilOp;
      exports2.IncrementWrapStencilOp = IncrementWrapStencilOp;
      exports2.InstancedBufferAttribute = InstancedBufferAttribute;
      exports2.InstancedBufferGeometry = InstancedBufferGeometry;
      exports2.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
      exports2.InstancedMesh = InstancedMesh;
      exports2.Int16Attribute = Int16Attribute;
      exports2.Int16BufferAttribute = Int16BufferAttribute;
      exports2.Int32Attribute = Int32Attribute;
      exports2.Int32BufferAttribute = Int32BufferAttribute;
      exports2.Int8Attribute = Int8Attribute;
      exports2.Int8BufferAttribute = Int8BufferAttribute;
      exports2.IntType = IntType;
      exports2.InterleavedBuffer = InterleavedBuffer;
      exports2.InterleavedBufferAttribute = InterleavedBufferAttribute;
      exports2.Interpolant = Interpolant;
      exports2.InterpolateDiscrete = InterpolateDiscrete;
      exports2.InterpolateLinear = InterpolateLinear;
      exports2.InterpolateSmooth = InterpolateSmooth;
      exports2.InvertStencilOp = InvertStencilOp;
      exports2.JSONLoader = JSONLoader;
      exports2.KeepStencilOp = KeepStencilOp;
      exports2.KeyframeTrack = KeyframeTrack;
      exports2.LOD = LOD;
      exports2.LatheBufferGeometry = LatheGeometry;
      exports2.LatheGeometry = LatheGeometry;
      exports2.Layers = Layers;
      exports2.LensFlare = LensFlare;
      exports2.LessDepth = LessDepth;
      exports2.LessEqualDepth = LessEqualDepth;
      exports2.LessEqualStencilFunc = LessEqualStencilFunc;
      exports2.LessStencilFunc = LessStencilFunc;
      exports2.Light = Light;
      exports2.LightProbe = LightProbe;
      exports2.Line = Line;
      exports2.Line3 = Line3;
      exports2.LineBasicMaterial = LineBasicMaterial;
      exports2.LineCurve = LineCurve;
      exports2.LineCurve3 = LineCurve3;
      exports2.LineDashedMaterial = LineDashedMaterial;
      exports2.LineLoop = LineLoop;
      exports2.LinePieces = LinePieces;
      exports2.LineSegments = LineSegments;
      exports2.LineStrip = LineStrip;
      exports2.LinearEncoding = LinearEncoding;
      exports2.LinearFilter = LinearFilter;
      exports2.LinearInterpolant = LinearInterpolant;
      exports2.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
      exports2.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
      exports2.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
      exports2.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
      exports2.LinearToneMapping = LinearToneMapping;
      exports2.Loader = Loader;
      exports2.LoaderUtils = LoaderUtils;
      exports2.LoadingManager = LoadingManager;
      exports2.LogLuvEncoding = LogLuvEncoding;
      exports2.LoopOnce = LoopOnce;
      exports2.LoopPingPong = LoopPingPong;
      exports2.LoopRepeat = LoopRepeat;
      exports2.LuminanceAlphaFormat = LuminanceAlphaFormat;
      exports2.LuminanceFormat = LuminanceFormat;
      exports2.MOUSE = MOUSE;
      exports2.Material = Material;
      exports2.MaterialLoader = MaterialLoader;
      exports2.Math = MathUtils;
      exports2.MathUtils = MathUtils;
      exports2.Matrix3 = Matrix3;
      exports2.Matrix4 = Matrix4;
      exports2.MaxEquation = MaxEquation;
      exports2.Mesh = Mesh2;
      exports2.MeshBasicMaterial = MeshBasicMaterial2;
      exports2.MeshDepthMaterial = MeshDepthMaterial;
      exports2.MeshDistanceMaterial = MeshDistanceMaterial;
      exports2.MeshFaceMaterial = MeshFaceMaterial;
      exports2.MeshLambertMaterial = MeshLambertMaterial2;
      exports2.MeshMatcapMaterial = MeshMatcapMaterial;
      exports2.MeshNormalMaterial = MeshNormalMaterial;
      exports2.MeshPhongMaterial = MeshPhongMaterial;
      exports2.MeshPhysicalMaterial = MeshPhysicalMaterial;
      exports2.MeshStandardMaterial = MeshStandardMaterial;
      exports2.MeshToonMaterial = MeshToonMaterial;
      exports2.MinEquation = MinEquation;
      exports2.MirroredRepeatWrapping = MirroredRepeatWrapping;
      exports2.MixOperation = MixOperation;
      exports2.MultiMaterial = MultiMaterial;
      exports2.MultiplyBlending = MultiplyBlending;
      exports2.MultiplyOperation = MultiplyOperation;
      exports2.NearestFilter = NearestFilter;
      exports2.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
      exports2.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
      exports2.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
      exports2.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
      exports2.NeverDepth = NeverDepth;
      exports2.NeverStencilFunc = NeverStencilFunc;
      exports2.NoBlending = NoBlending;
      exports2.NoColors = NoColors;
      exports2.NoToneMapping = NoToneMapping;
      exports2.NormalAnimationBlendMode = NormalAnimationBlendMode;
      exports2.NormalBlending = NormalBlending;
      exports2.NotEqualDepth = NotEqualDepth;
      exports2.NotEqualStencilFunc = NotEqualStencilFunc;
      exports2.NumberKeyframeTrack = NumberKeyframeTrack;
      exports2.Object3D = Object3D;
      exports2.ObjectLoader = ObjectLoader;
      exports2.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
      exports2.OctahedronBufferGeometry = OctahedronGeometry;
      exports2.OctahedronGeometry = OctahedronGeometry;
      exports2.OneFactor = OneFactor;
      exports2.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
      exports2.OneMinusDstColorFactor = OneMinusDstColorFactor;
      exports2.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
      exports2.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
      exports2.OrthographicCamera = OrthographicCamera2;
      exports2.PCFShadowMap = PCFShadowMap;
      exports2.PCFSoftShadowMap = PCFSoftShadowMap;
      exports2.PMREMGenerator = PMREMGenerator;
      exports2.ParametricBufferGeometry = ParametricGeometry;
      exports2.ParametricGeometry = ParametricGeometry;
      exports2.Particle = Particle;
      exports2.ParticleBasicMaterial = ParticleBasicMaterial;
      exports2.ParticleSystem = ParticleSystem;
      exports2.ParticleSystemMaterial = ParticleSystemMaterial;
      exports2.Path = Path2;
      exports2.PerspectiveCamera = PerspectiveCamera2;
      exports2.Plane = Plane;
      exports2.PlaneBufferGeometry = PlaneGeometry2;
      exports2.PlaneGeometry = PlaneGeometry2;
      exports2.PlaneHelper = PlaneHelper;
      exports2.PointCloud = PointCloud;
      exports2.PointCloudMaterial = PointCloudMaterial;
      exports2.PointLight = PointLight;
      exports2.PointLightHelper = PointLightHelper;
      exports2.Points = Points;
      exports2.PointsMaterial = PointsMaterial;
      exports2.PolarGridHelper = PolarGridHelper;
      exports2.PolyhedronBufferGeometry = PolyhedronGeometry;
      exports2.PolyhedronGeometry = PolyhedronGeometry;
      exports2.PositionalAudio = PositionalAudio;
      exports2.PropertyBinding = PropertyBinding;
      exports2.PropertyMixer = PropertyMixer;
      exports2.QuadraticBezierCurve = QuadraticBezierCurve;
      exports2.QuadraticBezierCurve3 = QuadraticBezierCurve3;
      exports2.Quaternion = Quaternion;
      exports2.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
      exports2.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
      exports2.REVISION = REVISION;
      exports2.RGBADepthPacking = RGBADepthPacking;
      exports2.RGBAFormat = RGBAFormat;
      exports2.RGBAIntegerFormat = RGBAIntegerFormat;
      exports2.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
      exports2.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
      exports2.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
      exports2.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
      exports2.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
      exports2.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
      exports2.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
      exports2.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
      exports2.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
      exports2.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
      exports2.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
      exports2.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
      exports2.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
      exports2.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
      exports2.RGBA_BPTC_Format = RGBA_BPTC_Format;
      exports2.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
      exports2.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
      exports2.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
      exports2.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
      exports2.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
      exports2.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
      exports2.RGBDEncoding = RGBDEncoding;
      exports2.RGBEEncoding = RGBEEncoding;
      exports2.RGBEFormat = RGBEFormat;
      exports2.RGBFormat = RGBFormat;
      exports2.RGBIntegerFormat = RGBIntegerFormat;
      exports2.RGBM16Encoding = RGBM16Encoding;
      exports2.RGBM7Encoding = RGBM7Encoding;
      exports2.RGB_ETC1_Format = RGB_ETC1_Format;
      exports2.RGB_ETC2_Format = RGB_ETC2_Format;
      exports2.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
      exports2.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
      exports2.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
      exports2.RGFormat = RGFormat;
      exports2.RGIntegerFormat = RGIntegerFormat;
      exports2.RawShaderMaterial = RawShaderMaterial;
      exports2.Ray = Ray;
      exports2.Raycaster = Raycaster;
      exports2.RectAreaLight = RectAreaLight;
      exports2.RedFormat = RedFormat;
      exports2.RedIntegerFormat = RedIntegerFormat;
      exports2.ReinhardToneMapping = ReinhardToneMapping;
      exports2.RepeatWrapping = RepeatWrapping;
      exports2.ReplaceStencilOp = ReplaceStencilOp;
      exports2.ReverseSubtractEquation = ReverseSubtractEquation;
      exports2.RingBufferGeometry = RingGeometry;
      exports2.RingGeometry = RingGeometry;
      exports2.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
      exports2.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
      exports2.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
      exports2.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
      exports2.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
      exports2.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
      exports2.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
      exports2.Scene = Scene2;
      exports2.SceneUtils = SceneUtils;
      exports2.ShaderChunk = ShaderChunk;
      exports2.ShaderLib = ShaderLib;
      exports2.ShaderMaterial = ShaderMaterial;
      exports2.ShadowMaterial = ShadowMaterial;
      exports2.Shape = Shape2;
      exports2.ShapeBufferGeometry = ShapeGeometry;
      exports2.ShapeGeometry = ShapeGeometry;
      exports2.ShapePath = ShapePath;
      exports2.ShapeUtils = ShapeUtils;
      exports2.ShortType = ShortType;
      exports2.Skeleton = Skeleton;
      exports2.SkeletonHelper = SkeletonHelper;
      exports2.SkinnedMesh = SkinnedMesh;
      exports2.SmoothShading = SmoothShading;
      exports2.Sphere = Sphere;
      exports2.SphereBufferGeometry = SphereGeometry;
      exports2.SphereGeometry = SphereGeometry;
      exports2.Spherical = Spherical;
      exports2.SphericalHarmonics3 = SphericalHarmonics3;
      exports2.SplineCurve = SplineCurve;
      exports2.SpotLight = SpotLight;
      exports2.SpotLightHelper = SpotLightHelper;
      exports2.Sprite = Sprite;
      exports2.SpriteMaterial = SpriteMaterial;
      exports2.SrcAlphaFactor = SrcAlphaFactor;
      exports2.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
      exports2.SrcColorFactor = SrcColorFactor;
      exports2.StaticCopyUsage = StaticCopyUsage;
      exports2.StaticDrawUsage = StaticDrawUsage;
      exports2.StaticReadUsage = StaticReadUsage;
      exports2.StereoCamera = StereoCamera;
      exports2.StreamCopyUsage = StreamCopyUsage;
      exports2.StreamDrawUsage = StreamDrawUsage;
      exports2.StreamReadUsage = StreamReadUsage;
      exports2.StringKeyframeTrack = StringKeyframeTrack;
      exports2.SubtractEquation = SubtractEquation;
      exports2.SubtractiveBlending = SubtractiveBlending;
      exports2.TOUCH = TOUCH;
      exports2.TangentSpaceNormalMap = TangentSpaceNormalMap;
      exports2.TetrahedronBufferGeometry = TetrahedronGeometry;
      exports2.TetrahedronGeometry = TetrahedronGeometry;
      exports2.TextBufferGeometry = TextGeometry;
      exports2.TextGeometry = TextGeometry;
      exports2.Texture = Texture2;
      exports2.TextureLoader = TextureLoader2;
      exports2.TorusBufferGeometry = TorusGeometry;
      exports2.TorusGeometry = TorusGeometry;
      exports2.TorusKnotBufferGeometry = TorusKnotGeometry;
      exports2.TorusKnotGeometry = TorusKnotGeometry;
      exports2.Triangle = Triangle;
      exports2.TriangleFanDrawMode = TriangleFanDrawMode;
      exports2.TriangleStripDrawMode = TriangleStripDrawMode;
      exports2.TrianglesDrawMode = TrianglesDrawMode;
      exports2.TubeBufferGeometry = TubeGeometry;
      exports2.TubeGeometry = TubeGeometry;
      exports2.UVMapping = UVMapping;
      exports2.Uint16Attribute = Uint16Attribute;
      exports2.Uint16BufferAttribute = Uint16BufferAttribute;
      exports2.Uint32Attribute = Uint32Attribute;
      exports2.Uint32BufferAttribute = Uint32BufferAttribute;
      exports2.Uint8Attribute = Uint8Attribute;
      exports2.Uint8BufferAttribute = Uint8BufferAttribute;
      exports2.Uint8ClampedAttribute = Uint8ClampedAttribute;
      exports2.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
      exports2.Uniform = Uniform;
      exports2.UniformsLib = UniformsLib;
      exports2.UniformsUtils = UniformsUtils;
      exports2.UnsignedByteType = UnsignedByteType;
      exports2.UnsignedInt248Type = UnsignedInt248Type;
      exports2.UnsignedIntType = UnsignedIntType;
      exports2.UnsignedShort4444Type = UnsignedShort4444Type;
      exports2.UnsignedShort5551Type = UnsignedShort5551Type;
      exports2.UnsignedShort565Type = UnsignedShort565Type;
      exports2.UnsignedShortType = UnsignedShortType;
      exports2.VSMShadowMap = VSMShadowMap;
      exports2.Vector2 = Vector22;
      exports2.Vector3 = Vector3;
      exports2.Vector4 = Vector4;
      exports2.VectorKeyframeTrack = VectorKeyframeTrack;
      exports2.Vertex = Vertex;
      exports2.VertexColors = VertexColors;
      exports2.VideoTexture = VideoTexture;
      exports2.WebGL1Renderer = WebGL1Renderer;
      exports2.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
      exports2.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
      exports2.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
      exports2.WebGLRenderTarget = WebGLRenderTarget;
      exports2.WebGLRenderTargetCube = WebGLRenderTargetCube;
      exports2.WebGLRenderer = WebGLRenderer2;
      exports2.WebGLUtils = WebGLUtils;
      exports2.WireframeGeometry = WireframeGeometry;
      exports2.WireframeHelper = WireframeHelper;
      exports2.WrapAroundEnding = WrapAroundEnding;
      exports2.XHRLoader = XHRLoader;
      exports2.ZeroCurvatureEnding = ZeroCurvatureEnding;
      exports2.ZeroFactor = ZeroFactor;
      exports2.ZeroSlopeEnding = ZeroSlopeEnding;
      exports2.ZeroStencilOp = ZeroStencilOp;
      exports2.sRGBEncoding = sRGBEncoding;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
var import_http = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_crypto = __toModule(require("crypto"));
var import_url = __toModule(require("url"));
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var src = dataUriToBuffer;
var { Readable } = import_stream.default;
var wm = new WeakMap();
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
var Blob2 = class {
  constructor(blobParts = [], options2 = {}) {
    let size = 0;
    const parts = blobParts.map((element) => {
      let buffer;
      if (element instanceof Buffer) {
        buffer = element;
      } else if (ArrayBuffer.isView(element)) {
        buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
      } else if (element instanceof ArrayBuffer) {
        buffer = Buffer.from(element);
      } else if (element instanceof Blob2) {
        buffer = element;
      } else {
        buffer = Buffer.from(typeof element === "string" ? element : String(element));
      }
      size += buffer.length || buffer.size || 0;
      return buffer;
    });
    const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
    wm.set(this, {
      type: /[^\u0020-\u007E]/.test(type) ? "" : type,
      size,
      parts
    });
  }
  get size() {
    return wm.get(this).size;
  }
  get type() {
    return wm.get(this).type;
  }
  async text() {
    return Buffer.from(await this.arrayBuffer()).toString();
  }
  async arrayBuffer() {
    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of this.stream()) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    return Readable.from(read(wm.get(this).parts));
  }
  slice(start = 0, end = this.size, type = "") {
    const { size } = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = wm.get(this).parts.values();
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size2 <= relativeStart) {
        relativeStart -= size2;
        relativeEnd -= size2;
      } else {
        const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
        blobParts.push(chunk);
        added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
        relativeStart = 0;
        if (added >= span) {
          break;
        }
      }
    }
    const blob = new Blob2([], { type: String(type).toLowerCase() });
    Object.assign(wm.get(blob), { size: span, parts: blobParts });
    return blob;
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(Blob2.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
});
var fetchBlob = Blob2;
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isAbortSignal = (object) => {
  return typeof object === "object" && object[NAME] === "AbortSignal";
};
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
var INTERNALS$2 = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (import_util.types.isAnyArrayBuffer(body)) {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else if (isFormData(body)) {
      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      body = import_stream.default.Readable.from(formDataIterator(body, boundary));
    } else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS$2] = {
      body,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_stream.default) {
      body.on("error", (err) => {
        const error2 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
        this[INTERNALS$2].error = error2;
      });
    }
  }
  get body() {
    return this[INTERNALS$2].body;
  }
  get bodyUsed() {
    return this[INTERNALS$2].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
    const buf = await this.buffer();
    return new fetchBlob([buf], {
      type: ct
    });
  }
  async json() {
    const buffer = await consumeBody(this);
    return JSON.parse(buffer.toString());
  }
  async text() {
    const buffer = await consumeBody(this);
    return buffer.toString();
  }
  buffer() {
    return consumeBody(this);
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true }
});
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    if (error2 instanceof FetchBaseError) {
      throw error2;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_stream.PassThrough({ highWaterMark });
    p2 = new import_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS$2].body = p1;
    body = p2;
  }
  return body;
};
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  }
  if (isFormData(body)) {
    return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
  }
  if (body instanceof import_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request;
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  if (isFormData(body)) {
    return getFormDataLength(request[INTERNALS$2].boundary);
  }
  return null;
};
var writeToStream = (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
};
var validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw err;
  }
};
var validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const err = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
    throw err;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init2) {
    let result = [];
    if (init2 instanceof Headers) {
      const raw = init2.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init2 == null)
      ;
    else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
      const method = init2[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init2));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init2].map((pair) => {
          if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback) {
    for (const name of this.keys()) {
      callback(this.get(name), name);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = { enumerable: true };
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};
var INTERNALS$1 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options2 = {}) {
    super(body, options2);
    const status = options2.status || 200;
    const headers = new Headers(options2.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: options2.url,
      status,
      statusText: options2.statusText || "",
      headers,
      counter: options2.counter,
      highWaterMark: options2.highWaterMark
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  get highWaterMark() {
    return this[INTERNALS$1].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
};
var INTERNALS = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS] === "object";
};
var Request = class extends Body {
  constructor(input, init2 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    let method = init2.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init2.size || input.size || 0
    });
    const headers = new Headers(init2.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init2) {
      signal = init2.signal;
    }
    if (signal !== null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS] = {
      method,
      redirect: init2.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
    this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
    this.counter = init2.counter || input.counter || 0;
    this.agent = init2.agent || input.agent;
    this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  get method() {
    return this[INTERNALS].method;
  }
  get url() {
    return (0, import_url.format)(this[INTERNALS].parsedURL);
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }
  get signal() {
    return this[INTERNALS].signal;
  }
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS];
  const headers = new Headers(request[INTERNALS].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error2) {
                reject(error2);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error2) => {
        reject(error2);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error2) => {
          reject(error2);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error2) => {
          reject(error2);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error2) => {
              reject(error2);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error2) => {
              reject(error2);
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error2) => {
          reject(error2);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
globalThis.fetch = fetch2;
globalThis.Response = Response2;
globalThis.Request = Request;
globalThis.Headers = Headers;

// node_modules/@sveltejs/kit/dist/ssr.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (branch) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${branch.map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page.path)},
						query: new URLSearchParams(${s$1(page.query.toString())}),
						params: ${s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    return body2 ? `<script type="svelte-data" url="${url}" body="${hash(body2)}">${json}<\/script>` : `<script type="svelte-data" url="${url}">${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status = loaded.status;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base, path) {
  const baseparts = path[0] === "/" ? [] : base.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state: state2,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          response = await fetch(url, opts);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new Response(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await fetch(`http://${page.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = { ...opts.headers };
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state2.prerender) {
                state2.prerender.dependencies.set(resolved, rendered);
              }
              response = new Response(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape2(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: { ...context }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape2(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({ request, options: options2, state: state2, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state: state2,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state: state2,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (error3) {
    options2.handle_error(error3);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
async function respond$1({ request, options: options2, state: state2, $session, route }) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error3) {
    options2.handle_error(error3);
    return await respond_with_error({
      request,
      options: options2,
      state: state2,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state2.prerender && !state2.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status = 200;
  let error2;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state: state2,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status = 500;
            error2 = e;
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state: state2,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state: state2,
              $session,
              status,
              error: error2
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error2,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (error3) {
    options2.handle_error(error3);
    return await respond_with_error({
      request,
      options: options2,
      state: state2,
      $session,
      status: 500,
      error: error3
    });
  }
}
async function render_page(request, route, options2, state2) {
  if (state2.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state: state2,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state2.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state2.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state: state2,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler2) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler2({ ...request, params });
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let { status = 200, body, headers = {} } = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = { ...headers, "content-type": "application/json" };
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return { status, body: normalized_body, headers };
    }
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        map.get(key).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state2 = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    const headers = lowercase_keys(incoming.headers);
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: null,
        locals: {}
      },
      resolve: async (request) => {
        if (state2.prerender && state2.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state2);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state2);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var tasks = new Set();
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name) => {
    if (invalid_attribute_name_character.test(name))
      return;
    const value = attributes[name];
    if (value === true)
      str += " " + name;
    else if (boolean_attributes.has(name.toLowerCase())) {
      if (value)
        str += " " + name;
    } else if (value != null) {
      str += ` ${name}="${String(value).replace(/"/g, "&#34;").replace(/'/g, "&#39;")}"`;
    }
  });
  return str;
}
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape3(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape3(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// .svelte-kit/output/server/app.js
var THREE = __toModule(require_three());

// node_modules/svelte/store/index.mjs
var subscriber_queue2 = [];
function writable2(value, start = noop2) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue2.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}

// .svelte-kit/output/server/app.js
var css$f = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$f);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1j55zn5"}">${navigated ? `${escape3(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-c88d451d.js",
      css: ["/./_app/assets/start-a8cd1609.css", "/./_app/assets/vendor-83544678.css"],
      js: ["/./_app/start-c88d451d.js", "/./_app/chunks/vendor-e92375a5.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2) => {
      console.error(error2.stack);
      error2.stack = options.get_stack(error2);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "bg-1.png", "size": 645088, "type": "image/png" }, { "file": "favicon.png", "size": 56365, "type": "image/png" }, { "file": "gradient.png", "size": 44564, "type": "image/png" }, { "file": "Profile1.png", "size": 2983038, "type": "image/png" }, { "file": "Profile2.jpg", "size": 333176, "type": "image/jpeg" }, { "file": "Profile3.jpg", "size": 201423, "type": "image/jpeg" }, { "file": "Profile4.jpg", "size": 224498, "type": "image/jpeg" }],
  layout: "src/routes/__layout.svelte",
  error: "src/routes/__error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/about\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/about.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/blogs\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/blogs/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/blogs\/([^/]+?)\/?$/,
      params: (m) => ({ id: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/blogs/[id].svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/ar\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/ar.svelte"],
      b: ["src/routes/__error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request))
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/__error.svelte": () => Promise.resolve().then(function() {
    return __error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/about.svelte": () => Promise.resolve().then(function() {
    return about;
  }),
  "src/routes/blogs/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/blogs/[id].svelte": () => Promise.resolve().then(function() {
    return _id_;
  }),
  "src/routes/ar.svelte": () => Promise.resolve().then(function() {
    return ar;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-0b2e0ec3.js", "css": ["/./_app/assets/pages/__layout.svelte-497364af.css", "/./_app/assets/vendor-83544678.css"], "js": ["/./_app/pages/__layout.svelte-0b2e0ec3.js", "/./_app/chunks/vendor-e92375a5.js"], "styles": null }, "src/routes/__error.svelte": { "entry": "/./_app/pages/__error.svelte-4e6b6686.js", "css": ["/./_app/assets/pages/__error.svelte-a2155a8b.css", "/./_app/assets/vendor-83544678.css"], "js": ["/./_app/pages/__error.svelte-4e6b6686.js", "/./_app/chunks/vendor-e92375a5.js"], "styles": null }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-756b4b7c.js", "css": ["/./_app/assets/pages/index.svelte-05a79a66.css", "/./_app/assets/vendor-83544678.css", "/./_app/assets/experience-463ff09a.css"], "js": ["/./_app/pages/index.svelte-756b4b7c.js", "/./_app/chunks/vendor-e92375a5.js", "/./_app/chunks/experience-173bda50.js"], "styles": null }, "src/routes/about.svelte": { "entry": "/./_app/pages/about.svelte-1bbfbc91.js", "css": ["/./_app/assets/pages/about.svelte-97b10dbf.css", "/./_app/assets/vendor-83544678.css", "/./_app/assets/experience-463ff09a.css"], "js": ["/./_app/pages/about.svelte-1bbfbc91.js", "/./_app/chunks/vendor-e92375a5.js", "/./_app/chunks/experience-173bda50.js"], "styles": null }, "src/routes/blogs/index.svelte": { "entry": "/./_app/pages/blogs/index.svelte-d4cb7b85.js", "css": ["/./_app/assets/pages/blogs/index.svelte-5dccbc71.css", "/./_app/assets/vendor-83544678.css"], "js": ["/./_app/pages/blogs/index.svelte-d4cb7b85.js", "/./_app/chunks/vendor-e92375a5.js"], "styles": null }, "src/routes/blogs/[id].svelte": { "entry": "/./_app/pages/blogs/[id].svelte-896f27cb.js", "css": ["/./_app/assets/pages/blogs/[id].svelte-3e07d515.css", "/./_app/assets/vendor-83544678.css"], "js": ["/./_app/pages/blogs/[id].svelte-896f27cb.js", "/./_app/chunks/vendor-e92375a5.js"], "styles": null }, "src/routes/ar.svelte": { "entry": "/./_app/pages/ar.svelte-8df7f878.js", "css": ["/./_app/assets/pages/ar.svelte-811f31ee.css", "/./_app/assets/vendor-83544678.css"], "js": ["/./_app/pages/ar.svelte-8df7f878.js", "/./_app/chunks/vendor-e92375a5.js"], "styles": null } };
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({ paths: { "base": "", "assets": "/." } });
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var css$e = {
  code: '@import url("https://fonts.googleapis.com/css2?family=Roboto:wght@100;400;500;900&display=swap");@import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@200;400;600;700&family=Source+Sans+Pro:wght@300;400;600;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Work+Sans:wght@200;300;400;500;600;700;800&display=swap");*{margin:0;padding:0;box-sizing:border-box}body{font-family:"Work Sans", "Roboto", "Source Sans Pro";background:#121212;background-position:top right;background-repeat:no-repeat;min-height:100vh}.grid{min-height:100vh;padding:10vh 0;display:grid;place-items:center}.glass-element{background:linear-gradient(to bottom right, #1ee8b766, #7a88d866);backdrop-filter:blur(10px);border-radius:2rem;text-decoration:none;padding:0.5rem;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);transition:all 0.3s}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{background-color:#121212}::-webkit-scrollbar-thumb{background-color:#1ee8b788}.circle.svelte-18o01hb{background:radial-gradient(at 0% 30%, #25e0ba 20%, #7a88d8, #c362f6);border-radius:100%;animation-name:svelte-18o01hb-circle;animation-duration:4s;animation-iteration-count:infinite}.circle-1.svelte-18o01hb{z-index:-1;position:fixed;bottom:50vh;right:1vw;width:300px;height:300px;animation-delay:1s}.circle-2.svelte-18o01hb{z-index:-1;position:fixed;top:20vh;left:20vw;width:100px;height:100px;animation-delay:2s}.circle-3.svelte-18o01hb{z-index:-1;position:fixed;bottom:8vh;right:30vw;width:50px;height:50px;animation-delay:3s}.circle-4.svelte-18o01hb{z-index:-1;position:fixed;bottom:20vh;left:5vw;width:75px;height:75px}@keyframes svelte-18o01hb-circle{0%{transform:translateY(0rem)}50%{transform:translateY(2rem)}100%{transform:translateY(0)}}',
  map: '{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<slot />\\r\\n<div class=\\"circle circle-1\\" />\\r\\n<div class=\\"circle circle-2\\" />\\r\\n<div class=\\"circle circle-3\\" />\\r\\n<div class=\\"circle circle-4\\" />\\r\\n\\r\\n<style lang=\\"scss\\">@import url(\\"https://fonts.googleapis.com/css2?family=Roboto:wght@100;400;500;900&display=swap\\");\\n@import url(\\"https://fonts.googleapis.com/css2?family=Montserrat:wght@200;400;600;700&family=Source+Sans+Pro:wght@300;400;600;700&display=swap\\");\\n@import url(\\"https://fonts.googleapis.com/css2?family=Work+Sans:wght@200;300;400;500;600;700;800&display=swap\\");\\n:global(*) {\\n  margin: 0;\\n  padding: 0;\\n  box-sizing: border-box;\\n}\\n\\n:global(body) {\\n  font-family: \\"Work Sans\\", \\"Roboto\\", \\"Source Sans Pro\\";\\n  background: #121212;\\n  background-position: top right;\\n  background-repeat: no-repeat;\\n  min-height: 100vh;\\n}\\n\\n:global(.grid) {\\n  min-height: 100vh;\\n  padding: 10vh 0;\\n  display: grid;\\n  place-items: center;\\n}\\n\\n:global(.glass-element) {\\n  background: linear-gradient(to bottom right, #1ee8b766, #7a88d866);\\n  backdrop-filter: blur(10px);\\n  border-radius: 2rem;\\n  text-decoration: none;\\n  padding: 0.5rem;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n  transition: all 0.3s;\\n}\\n\\n:global(::-webkit-scrollbar) {\\n  width: 5px;\\n}\\n\\n:global(::-webkit-scrollbar-track) {\\n  background-color: #121212;\\n}\\n\\n:global(::-webkit-scrollbar-thumb) {\\n  background-color: #1ee8b788;\\n}\\n\\n.circle {\\n  background: radial-gradient(at 0% 30%, #25e0ba 20%, #7a88d8, #c362f6);\\n  border-radius: 100%;\\n  animation-name: circle;\\n  animation-duration: 4s;\\n  animation-iteration-count: infinite;\\n}\\n\\n.circle-1 {\\n  z-index: -1;\\n  position: fixed;\\n  bottom: 50vh;\\n  right: 1vw;\\n  width: 300px;\\n  height: 300px;\\n  animation-delay: 1s;\\n}\\n\\n.circle-2 {\\n  z-index: -1;\\n  position: fixed;\\n  top: 20vh;\\n  left: 20vw;\\n  width: 100px;\\n  height: 100px;\\n  animation-delay: 2s;\\n}\\n\\n.circle-3 {\\n  z-index: -1;\\n  position: fixed;\\n  bottom: 8vh;\\n  right: 30vw;\\n  width: 50px;\\n  height: 50px;\\n  animation-delay: 3s;\\n}\\n\\n.circle-4 {\\n  z-index: -1;\\n  position: fixed;\\n  bottom: 20vh;\\n  left: 5vw;\\n  width: 75px;\\n  height: 75px;\\n}\\n\\n@keyframes circle {\\n  0% {\\n    transform: translateY(0rem);\\n  }\\n  50% {\\n    transform: translateY(2rem);\\n  }\\n  100% {\\n    transform: translateY(0);\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAMmB,QAAQ,IAAI,mFAAmF,CAAC,CAAC,AACpH,QAAQ,IAAI,mIAAmI,CAAC,CAAC,AACjJ,QAAQ,IAAI,kGAAkG,CAAC,CAAC,AACxG,CAAC,AAAE,CAAC,AACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,UAAU,AACxB,CAAC,AAEO,IAAI,AAAE,CAAC,AACb,WAAW,CAAE,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,iBAAiB,CACrD,UAAU,CAAE,OAAO,CACnB,mBAAmB,CAAE,GAAG,CAAC,KAAK,CAC9B,iBAAiB,CAAE,SAAS,CAC5B,UAAU,CAAE,KAAK,AACnB,CAAC,AAEO,KAAK,AAAE,CAAC,AACd,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,AACrB,CAAC,AAEO,cAAc,AAAE,CAAC,AACvB,UAAU,CAAE,gBAAgB,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,CAAC,SAAS,CAAC,CAClE,eAAe,CAAE,KAAK,IAAI,CAAC,CAC3B,aAAa,CAAE,IAAI,CACnB,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,MAAM,CACf,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpF,UAAU,CAAE,GAAG,CAAC,IAAI,AACtB,CAAC,AAEO,mBAAmB,AAAE,CAAC,AAC5B,KAAK,CAAE,GAAG,AACZ,CAAC,AAEO,yBAAyB,AAAE,CAAC,AAClC,gBAAgB,CAAE,OAAO,AAC3B,CAAC,AAEO,yBAAyB,AAAE,CAAC,AAClC,gBAAgB,CAAE,SAAS,AAC7B,CAAC,AAED,OAAO,eAAC,CAAC,AACP,UAAU,CAAE,gBAAgB,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CACrE,aAAa,CAAE,IAAI,CACnB,cAAc,CAAE,qBAAM,CACtB,kBAAkB,CAAE,EAAE,CACtB,yBAAyB,CAAE,QAAQ,AACrC,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,GAAG,CACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,eAAe,CAAE,EAAE,AACrB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,eAAe,CAAE,EAAE,AACrB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,GAAG,CACX,KAAK,CAAE,IAAI,CACX,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,eAAe,CAAE,EAAE,AACrB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,GAAG,CACT,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACd,CAAC,AAED,WAAW,qBAAO,CAAC,AACjB,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,WAAW,IAAI,CAAC,AAC7B,CAAC,AACD,GAAG,AAAC,CAAC,AACH,SAAS,CAAE,WAAW,IAAI,CAAC,AAC7B,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,WAAW,CAAC,CAAC,AAC1B,CAAC,AACH,CAAC"}'
};
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$e);
  return `${slots.default ? slots.default({}) : ``}
<div class="${"circle circle-1 svelte-18o01hb"}"></div>
<div class="${"circle circle-2 svelte-18o01hb"}"></div>
<div class="${"circle circle-3 svelte-18o01hb"}"></div>
<div class="${"circle circle-4 svelte-18o01hb"}"></div>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
var Path = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { id = "" } = $$props;
  let { data = {} } = $$props;
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  return `<path${spread([{ key: "path-" + escape3(id) }, data])}></path>`;
});
var Polygon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { id = "" } = $$props;
  let { data = {} } = $$props;
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  return `<polygon${spread([{ key: "polygon-" + escape3(id) }, data])}></polygon>`;
});
var Raw = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let cursor = 870711;
  function getId() {
    cursor += 1;
    return `fa-${cursor.toString(16)}`;
  }
  let raw;
  let { data } = $$props;
  function getRaw(data2) {
    if (!data2 || !data2.raw) {
      return null;
    }
    let rawData = data2.raw;
    const ids = {};
    rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
      const uniqueId = getId();
      ids[id] = uniqueId;
      return ` id="${uniqueId}"`;
    });
    rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
      const id = rawId || pointerId;
      if (!id || !ids[id]) {
        return match;
      }
      return `#${ids[id]}`;
    });
    return rawData;
  }
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  raw = getRaw(data);
  return `<g>${raw}</g>`;
});
var css$d = {
  code: ".fa-icon.svelte-1dof0an{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1dof0an{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1dof0an{transform:scale(1, -1)}.fa-spin.svelte-1dof0an{animation:svelte-1dof0an-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1dof0an{color:#fff}.fa-pulse.svelte-1dof0an{animation:svelte-1dof0an-fa-spin 1s infinite steps(8)}@keyframes svelte-1dof0an-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}",
  map: `{"version":3,"file":"Svg.svelte","sources":["Svg.svelte"],"sourcesContent":["<svg version=\\"1.1\\" class=\\"fa-icon {className}\\"\\n  class:fa-spin={spin} class:fa-pulse={pulse} class:fa-inverse={inverse}\\n  class:fa-flip-horizontal=\\"{flip === 'horizontal'}\\" class:fa-flip-vertical=\\"{flip === 'vertical'}\\"\\n  {x} {y} {width} {height}\\n  aria-label={label}\\n  role=\\"{ label ? 'img' : 'presentation' }\\"\\n  viewBox={box} {style}\\n  >\\n  <slot></slot>\\n</svg>\\n\\n<style>\\n.fa-icon {\\n  display: inline-block;\\n  fill: currentColor;\\n}\\n.fa-flip-horizontal {\\n  transform: scale(-1, 1);\\n}\\n.fa-flip-vertical {\\n  transform: scale(1, -1);\\n}\\n.fa-spin {\\n  animation: fa-spin 1s 0s infinite linear;\\n}\\n.fa-inverse {\\n  color: #fff;\\n}\\n.fa-pulse {\\n  animation: fa-spin 1s infinite steps(8);\\n}\\n@keyframes fa-spin {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    transform: rotate(360deg);\\n  }\\n}\\n</style>\\n\\n<script>\\n  let className;\\n\\n  export { className as class };\\n\\n  export let width;\\n  export let height;\\n  export let box;\\n\\n  export let spin = false;\\n  export let inverse = false;\\n  export let pulse = false;\\n  export let flip = null;\\n\\n  // optionals\\n  export let x = undefined;\\n  export let y = undefined;\\n  export let style = undefined;\\n  export let label = undefined;\\n<\/script>\\n"],"names":[],"mappings":"AAYA,QAAQ,eAAC,CAAC,AACR,OAAO,CAAE,YAAY,CACrB,IAAI,CAAE,YAAY,AACpB,CAAC,AACD,mBAAmB,eAAC,CAAC,AACnB,SAAS,CAAE,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,AACzB,CAAC,AACD,iBAAiB,eAAC,CAAC,AACjB,SAAS,CAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,AACzB,CAAC,AACD,QAAQ,eAAC,CAAC,AACR,SAAS,CAAE,sBAAO,CAAC,EAAE,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,AAC1C,CAAC,AACD,WAAW,eAAC,CAAC,AACX,KAAK,CAAE,IAAI,AACb,CAAC,AACD,SAAS,eAAC,CAAC,AACT,SAAS,CAAE,sBAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,AACzC,CAAC,AACD,WAAW,sBAAQ,CAAC,AAClB,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,OAAO,IAAI,CAAC,AACzB,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC3B,CAAC,AACH,CAAC"}`
};
var Svg = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { class: className } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { box } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = null } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { label = void 0 } = $$props;
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  if ($$props.height === void 0 && $$bindings.height && height !== void 0)
    $$bindings.height(height);
  if ($$props.box === void 0 && $$bindings.box && box !== void 0)
    $$bindings.box(box);
  if ($$props.spin === void 0 && $$bindings.spin && spin !== void 0)
    $$bindings.spin(spin);
  if ($$props.inverse === void 0 && $$bindings.inverse && inverse !== void 0)
    $$bindings.inverse(inverse);
  if ($$props.pulse === void 0 && $$bindings.pulse && pulse !== void 0)
    $$bindings.pulse(pulse);
  if ($$props.flip === void 0 && $$bindings.flip && flip !== void 0)
    $$bindings.flip(flip);
  if ($$props.x === void 0 && $$bindings.x && x !== void 0)
    $$bindings.x(x);
  if ($$props.y === void 0 && $$bindings.y && y !== void 0)
    $$bindings.y(y);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  $$result.css.add(css$d);
  return `<svg version="${"1.1"}" class="${[
    "fa-icon " + escape3(className) + " svelte-1dof0an",
    (spin ? "fa-spin" : "") + " " + (pulse ? "fa-pulse" : "") + " " + (inverse ? "fa-inverse" : "") + " " + (flip === "horizontal" ? "fa-flip-horizontal" : "") + " " + (flip === "vertical" ? "fa-flip-vertical" : "")
  ].join(" ").trim()}"${add_attribute("x", x, 0)}${add_attribute("y", y, 0)}${add_attribute("width", width, 0)}${add_attribute("height", height, 0)}${add_attribute("aria-label", label, 0)}${add_attribute("role", label ? "img" : "presentation", 0)}${add_attribute("viewBox", box, 0)}${add_attribute("style", style, 0)}>${slots.default ? slots.default({}) : ``}</svg>`;
});
var outerScale = 1;
function normaliseData(data) {
  if ("iconName" in data && "icon" in data) {
    let normalisedData = {};
    let faIcon = data.icon;
    let name = data.iconName;
    let width = faIcon[0];
    let height = faIcon[1];
    let paths = faIcon[4];
    let iconData = { width, height, paths: [{ d: paths }] };
    normalisedData[name] = iconData;
    return normalisedData;
  }
  return data;
}
var Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { class: className = "" } = $$props;
  let { data } = $$props;
  let { scale = 1 } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = null } = $$props;
  let { label = null } = $$props;
  let { self: self2 = null } = $$props;
  let { style = null } = $$props;
  let width;
  let height;
  let combinedStyle;
  let box;
  function init2() {
    if (typeof data === "undefined") {
      return;
    }
    const normalisedData = normaliseData(data);
    const [name] = Object.keys(normalisedData);
    const icon = normalisedData[name];
    if (!icon.paths) {
      icon.paths = [];
    }
    if (icon.d) {
      icon.paths.push({ d: icon.d });
    }
    if (!icon.polygons) {
      icon.polygons = [];
    }
    if (icon.points) {
      icon.polygons.push({ points: icon.points });
    }
    self2 = icon;
  }
  function normalisedScale() {
    let numScale = 1;
    if (typeof scale !== "undefined") {
      numScale = Number(scale);
    }
    if (isNaN(numScale) || numScale <= 0) {
      console.warn('Invalid prop: prop "scale" should be a number over 0.');
      return outerScale;
    }
    return numScale * outerScale;
  }
  function calculateBox() {
    if (self2) {
      return `0 0 ${self2.width} ${self2.height}`;
    }
    return `0 0 ${width} ${height}`;
  }
  function calculateRatio() {
    if (!self2) {
      return 1;
    }
    return Math.max(self2.width, self2.height) / 16;
  }
  function calculateWidth() {
    if (self2) {
      return self2.width / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateHeight() {
    if (self2) {
      return self2.height / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateStyle() {
    let combined = "";
    if (style !== null) {
      combined += style;
    }
    let size = normalisedScale();
    if (size === 1) {
      if (combined.length === 0) {
        return void 0;
      }
      return combined;
    }
    if (combined !== "" && !combined.endsWith(";")) {
      combined += "; ";
    }
    return `${combined}font-size: ${size}em`;
  }
  if ($$props.class === void 0 && $$bindings.class && className !== void 0)
    $$bindings.class(className);
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
    $$bindings.scale(scale);
  if ($$props.spin === void 0 && $$bindings.spin && spin !== void 0)
    $$bindings.spin(spin);
  if ($$props.inverse === void 0 && $$bindings.inverse && inverse !== void 0)
    $$bindings.inverse(inverse);
  if ($$props.pulse === void 0 && $$bindings.pulse && pulse !== void 0)
    $$bindings.pulse(pulse);
  if ($$props.flip === void 0 && $$bindings.flip && flip !== void 0)
    $$bindings.flip(flip);
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  if ($$props.self === void 0 && $$bindings.self && self2 !== void 0)
    $$bindings.self(self2);
  if ($$props.style === void 0 && $$bindings.style && style !== void 0)
    $$bindings.style(style);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      {
        init2();
        width = calculateWidth();
        height = calculateHeight();
        combinedStyle = calculateStyle();
        box = calculateBox();
      }
    }
    $$rendered = `${validate_component(Svg, "Svg").$$render($$result, {
      label,
      width,
      height,
      box,
      style: combinedStyle,
      spin,
      flip,
      inverse,
      pulse,
      class: className
    }, {}, {
      default: () => `${slots.default ? slots.default({}) : `
    ${self2 ? `${self2.paths ? `${each(self2.paths, (path, i) => `${validate_component(Path, "Path").$$render($$result, { id: i, data: path }, {}, {})}`)}` : ``}
      ${self2.polygons ? `${each(self2.polygons, (polygon, i) => `${validate_component(Polygon, "Polygon").$$render($$result, { id: i, data: polygon }, {}, {})}`)}` : ``}
      ${self2.raw ? `${validate_component(Raw, "Raw").$$render($$result, { data: self2 }, {
        data: ($$value) => {
          self2 = $$value;
          $$settled = false;
        }
      }, {})}` : ``}` : ``}
  `}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var refresh = { refresh: { width: 1536, height: 1792, paths: [{ d: "M1511 1056q0 5-1 7-64 268-268 434.5t-478 166.5q-146 0-282.5-55t-243.5-157l-129 129q-19 19-45 19t-45-19-19-45v-448q0-26 19-45t45-19h448q26 0 45 19t19 45-19 45l-137 137q71 66 161 102t187 36q134 0 250-65t186-179q11-17 53-117 8-23 30-23h192q13 0 22.5 9.5t9.5 22.5zM1536 256v448q0 26-19 45t-45 19h-448q-26 0-45-19t-19-45 19-45l138-138q-148-137-349-137-134 0-250 65t-186 179q-11 17-53 117-8 23-30 23h-199q-13 0-22.5-9.5t-9.5-22.5v-7q65-268 270-434.5t480-166.5q146 0 284 55.5t245 156.5l130-129q19-19 45-19t45 19 19 45z" }] } };
var arrowLeft = { "arrow-left": { width: 1536, height: 1792, paths: [{ d: "M1536 896v128q0 53-32.5 90.5t-84.5 37.5h-704l293 294q38 36 38 90t-38 90l-75 76q-37 37-90 37-52 0-91-37l-651-652q-37-37-37-90 0-52 37-91l651-650q38-38 91-38 52 0 90 38l75 74q38 38 38 91t-38 91l-293 293h704q52 0 84.5 37.5t32.5 90.5z" }] } };
var calendar = { calendar: { width: 1664, height: 1792, paths: [{ d: "M128 1664h288v-288h-288v288zM480 1664h320v-288h-320v288zM128 1312h288v-320h-288v320zM480 1312h320v-320h-320v320zM128 928h288v-288h-288v288zM864 1664h320v-288h-320v288zM480 928h320v-288h-320v288zM1248 1664h288v-288h-288v288zM864 1312h320v-320h-320v320zM512 448v-288q0-13-9.5-22.5t-22.5-9.5h-64q-13 0-22.5 9.5t-9.5 22.5v288q0 13 9.5 22.5t22.5 9.5h64q13 0 22.5-9.5t9.5-22.5zM1248 1312h288v-320h-288v320zM864 928h320v-288h-320v288zM1248 928h288v-288h-288v288zM1280 448v-288q0-13-9.5-22.5t-22.5-9.5h-64q-13 0-22.5 9.5t-9.5 22.5v288q0 13 9.5 22.5t22.5 9.5h64q13 0 22.5-9.5t9.5-22.5zM1664 384v1280q0 52-38 90t-90 38h-1408q-52 0-90-38t-38-90v-1280q0-52 38-90t90-38h128v-96q0-66 47-113t113-47h64q66 0 113 47t47 113v96h384v-96q0-66 47-113t113-47h64q66 0 113 47t47 113v96h128q52 0 90 38t38 90z" }] } };
var twitter = { twitter: { width: 1664, height: 1792, paths: [{ d: "M1620 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z" }] } };
var github = { github: { width: 1536, height: 1792, paths: [{ d: "M768 128q209 0 385.5 103t279.5 279.5 103 385.5q0 251-146.5 451.5t-378.5 277.5q-27 5-40-7t-13-30q0-3 0.5-76.5t0.5-134.5q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105 20.5-150.5q0-119-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27t-83.5-38.5-85-13.5q-45 113-8 204-79 87-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-39 36-49 103-21 10-45 15t-57 5-65.5-21.5-55.5-62.5q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 0.5 88.5t0.5 54.5q0 18-13 30t-40 7q-232-77-378.5-277.5t-146.5-451.5q0-209 103-385.5t279.5-279.5 385.5-103zM291 1231q3-7-7-12-10-3-13 2-3 7 7 12 9 6 13-2zM322 1265q7-5-2-16-10-9-16-3-7 5 2 16 10 10 16 3zM352 1310q9-7 0-19-8-13-17-6-9 5 0 18t17 7zM394 1352q8-8-4-19-12-12-20-3-9 8 4 19 12 12 20 3zM451 1377q3-11-13-16-15-4-19 7t13 15q15 6 19-6zM514 1382q0-13-17-11-16 0-16 11 0 13 17 11 16 0 16-11zM572 1372q-2-11-18-9-16 3-14 15t18 8 14-14z" }] } };
var arrowCircleUp = { "arrow-circle-up": { width: 1536, height: 1792, paths: [{ d: "M1284 895q0-27-18-45l-362-362-91-91q-18-18-45-18t-45 18l-91 91-362 362q-18 18-18 45t18 45l91 91q18 18 45 18t45-18l189-189v502q0 26 19 45t45 19h128q26 0 45-19t19-45v-502l189 189q19 19 45 19t45-19l91-91q18-18 18-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z" }] } };
var arrowCircleDown = { "arrow-circle-down": { width: 1536, height: 1792, paths: [{ d: "M1284 897q0-27-18-45l-91-91q-18-18-45-18t-45 18l-189 189v-502q0-26-19-45t-45-19h-128q-26 0-45 19t-19 45v502l-189-189q-19-19-45-19t-45 19l-91 91q-18 18-18 45t18 45l362 362 91 91q18 18 45 18t45-18l91-91 362-362q18-18 18-45zM1536 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z" }] } };
var linkedin = { linkedin: { width: 1536, height: 1792, paths: [{ d: "M349 625v991h-330v-991h330zM370 319q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zM1536 1048v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z" }] } };
var spinner = { spinner: { width: 1792, height: 1792, paths: [{ d: "M526 1394q0 53-37.5 90.5t-90.5 37.5q-52 0-90-38t-38-90q0-53 37.5-90.5t90.5-37.5 90.5 37.5 37.5 90.5zM1024 1600q0 53-37.5 90.5t-90.5 37.5-90.5-37.5-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zM320 896q0 53-37.5 90.5t-90.5 37.5-90.5-37.5-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zM1522 1394q0 52-38 90t-90 38q-53 0-90.5-37.5t-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zM558 398q0 66-47 113t-113 47-113-47-47-113 47-113 113-47 113 47 47 113zM1728 896q0 53-37.5 90.5t-90.5 37.5-90.5-37.5-37.5-90.5 37.5-90.5 90.5-37.5 90.5 37.5 37.5 90.5zM1088 192q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zM1618 398q0 93-66 158.5t-158 65.5q-93 0-158.5-65.5t-65.5-158.5q0-92 65.5-158t158.5-66q92 0 158 66t66 158z" }] } };
var trackRadius = 225;
var trackWidth = 45;
var innerTrackRadius = trackRadius - trackWidth;
var outerTrackRadius = trackRadius + trackWidth;
var arcAngle1 = 1 / 3 * Math.PI;
var deltaY = Math.sin(arcAngle1) * innerTrackRadius;
var arcAngle2 = Math.asin(deltaY / outerTrackRadius);
var arcCenterX = (Math.cos(arcAngle1) * innerTrackRadius + Math.cos(arcAngle2) * outerTrackRadius) / 2;
var arcAngle3 = Math.acos(arcCenterX / innerTrackRadius);
var arcAngle4 = Math.acos(arcCenterX / outerTrackRadius);
function getLineMarkings(mapWidth, mapHeight) {
  const canvas = document.createElement("canvas");
  canvas.width = mapWidth;
  canvas.height = mapHeight;
  const context = canvas.getContext("2d");
  context.fillStyle = "#546e90";
  context.fillRect(0, 0, mapWidth, mapHeight);
  context.lineWidth = 2;
  context.strokeStyle = "#e0ffff";
  context.setLineDash([10, 14]);
  context.beginPath();
  context.arc(mapWidth / 2 - arcCenterX, mapHeight / 2, trackRadius, 0, Math.PI * 2);
  context.stroke();
  context.beginPath();
  context.arc(mapWidth / 2 + arcCenterX, mapHeight / 2, trackRadius, 0, Math.PI * 2);
  context.stroke();
  return new THREE.CanvasTexture(canvas);
}
function getLeftIsland() {
  const islandLeft = new THREE.Shape();
  islandLeft.absarc(-arcCenterX, 0, innerTrackRadius, arcAngle1, -arcAngle1, false);
  islandLeft.absarc(arcCenterX, 0, outerTrackRadius, Math.PI + arcAngle2, Math.PI - arcAngle2, true);
  return islandLeft;
}
function getMiddleIsland() {
  const islandMiddle = new THREE.Shape();
  islandMiddle.absarc(-arcCenterX, 0, innerTrackRadius, arcAngle3, -arcAngle3, true);
  islandMiddle.absarc(arcCenterX, 0, innerTrackRadius, Math.PI + arcAngle3, Math.PI - arcAngle3, true);
  return islandMiddle;
}
function getRightIsland() {
  const islandRight = new THREE.Shape();
  islandRight.absarc(arcCenterX, 0, innerTrackRadius, Math.PI - arcAngle1, Math.PI + arcAngle1, true);
  islandRight.absarc(-arcCenterX, 0, outerTrackRadius, -arcAngle2, arcAngle2, false);
  return islandRight;
}
function getOuterField(mapWidth, mapHeight) {
  const field = new THREE.Shape();
  field.moveTo(-mapWidth / 2, -mapHeight / 2);
  field.lineTo(0, -mapHeight / 2);
  field.absarc(-arcCenterX, 0, outerTrackRadius, -arcAngle4, arcAngle4, true);
  field.absarc(arcCenterX, 0, outerTrackRadius, Math.PI - arcAngle4, Math.PI + arcAngle4, true);
  field.lineTo(0, -mapHeight / 2);
  field.lineTo(mapWidth / 2, -mapHeight / 2);
  field.lineTo(mapWidth / 2, mapHeight / 2);
  field.lineTo(-mapWidth / 2, mapHeight / 2);
  return field;
}
var vehicleColors = [16711782, 65382, 16737792];
function Car() {
  const car = new THREE.Group();
  const backWheel = Wheel();
  backWheel.position.x = -18;
  car.add(backWheel);
  const frontWheel = Wheel();
  frontWheel.position.z = 6;
  frontWheel.position.x = 18;
  car.add(frontWheel);
  const main = new THREE.Mesh(new THREE.BoxBufferGeometry(60, 30, 15), new THREE.MeshLambertMaterial({ color: pickRandom(vehicleColors) }));
  main.position.z = 12;
  car.add(main);
  const carFrontTexture = getCarFrontTexture();
  carFrontTexture.center = new THREE.Vector2(0.5, 0.5);
  carFrontTexture.rotation = -Math.PI / 2;
  const carBackTexture = getCarFrontTexture();
  carBackTexture.center = new THREE.Vector2(0.5, 0.5);
  carFrontTexture.rotation = Math.PI / 2;
  const carRightSideTexture = getCarSideTexture();
  const carLeftSideTexture = getCarSideTexture();
  carLeftSideTexture.flipY = false;
  const cabin = new THREE.Mesh(new THREE.BoxBufferGeometry(33, 24, 12), [
    new THREE.MeshLambertMaterial({ map: carFrontTexture }),
    new THREE.MeshLambertMaterial({ map: carBackTexture }),
    new THREE.MeshLambertMaterial({ map: carLeftSideTexture }),
    new THREE.MeshLambertMaterial({ map: carRightSideTexture }),
    new THREE.MeshLambertMaterial({ color: 16777215 }),
    new THREE.MeshLambertMaterial({ color: 16777215 })
  ]);
  cabin.position.x = -6;
  cabin.position.z = 25.5;
  car.add(cabin);
  return car;
}
function Wheel() {
  const wheel = new THREE.Mesh(new THREE.BoxBufferGeometry(12, 33, 12), new THREE.MeshLambertMaterial({ color: 3355443 }));
  wheel.position.z = 6;
  return wheel;
}
function pickRandom(array) {
  return array[Math.floor(Math.random() * array.length)];
}
function getCarFrontTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 64;
  canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 64, 32);
  context.fillStyle = "#666666";
  context.fillRect(8, 8, 48, 24);
  return new THREE.CanvasTexture(canvas);
}
function getCarSideTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 128;
  canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 128, 32);
  context.fillStyle = "#666666";
  context.fillRect(10, 8, 38, 24);
  context.fillRect(58, 8, 60, 24);
  return new THREE.CanvasTexture(canvas);
}
var App$1 = class {
  constructor() {
    this.initThree();
    this.scoreElement = document.getElementById("score");
    this.resetElement = document.getElementById("reset");
    this.otherVehicles = [];
    this.reset();
    this.accelerate = false;
    this.decelerate = false;
  }
  animation(timestamp) {
    if (!this.lastTimeStamp) {
      this.lastTimeStamp = timestamp;
      return;
    }
    const timeDelta = timestamp - this.lastTimeStamp;
    this.movePlayerCar(timeDelta);
    const laps = Math.floor(Math.abs(this.playerAngleMoved) / (Math.PI * 2));
    if (laps != this.score) {
      this.score = laps;
      this.scoreElement.innerText = this.score;
    }
    if (this.otherVehicles.length <= (laps + 1) / 5)
      this.addVehicle();
    this.moveOtherVehicles(timeDelta);
    this.hitDetection();
    this.renderer.render(this.scene, this.camera);
    this.lastTimeStamp = timestamp;
  }
  movePlayerCar(timeDelta) {
    this.baseSpeed = 17e-4;
    this.playerSpeed = this.getPlayerSpeed();
    this.playerAngleMoved -= this.playerSpeed * timeDelta;
    const totalPlayerAngle = this.playerAngleInitial + this.playerAngleMoved;
    const playerX = Math.cos(totalPlayerAngle) * trackRadius - arcCenterX;
    const playerY = Math.sin(totalPlayerAngle) * trackRadius;
    this.playerCar.position.x = playerX;
    this.playerCar.position.y = playerY;
    this.playerCar.rotation.z = totalPlayerAngle - Math.PI / 2;
  }
  getPlayerSpeed() {
    if (this.accelerate)
      return this.baseSpeed * 2;
    if (this.decelerate)
      return this.baseSpeed * 0.5;
    return this.baseSpeed;
  }
  addVehicle() {
    const mesh = Car();
    this.scene.add(mesh);
    const clockwise = Math.random() >= 0.5;
    const angle = clockwise ? Math.PI / 2 : -Math.PI / 2;
    let minSpeed = 1;
    let maxSpeed = 2;
    const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
    this.otherVehicles.push({ mesh, clockwise, angle, speed });
  }
  moveOtherVehicles(timeDelta) {
    const baseSpeed = 17e-4;
    this.otherVehicles.forEach((vehicle) => {
      if (vehicle.clockwise) {
        vehicle.angle -= baseSpeed * timeDelta * vehicle.speed;
      } else {
        vehicle.angle += baseSpeed * timeDelta * vehicle.speed;
      }
      const vehicleX = Math.cos(vehicle.angle) * trackRadius + arcCenterX;
      const vehicleY = Math.sin(vehicle.angle) * trackRadius;
      const rotation = vehicle.angle + (vehicle.clockwise ? -Math.PI / 2 : Math.PI / 2);
      vehicle.mesh.position.x = vehicleX;
      vehicle.mesh.position.y = vehicleY;
      vehicle.mesh.rotation.z = rotation;
    });
  }
  getHitZonePosition(center, angle, clockwise, distance) {
    const directionAngle = angle + clockwise ? -Math.PI / 2 : Math.PI / 2;
    return {
      x: center.x + Math.cos(directionAngle) * distance,
      y: center.y + Math.sin(directionAngle) * distance
    };
  }
  getDistance(a, b) {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
  }
  hitDetection() {
    const playerHitZone1 = this.getHitZonePosition(this.playerCar.position, this.playerAngleInitial + this.playerAngleMoved, true, 15);
    const playerHitZone2 = this.getHitZonePosition(this.playerCar.position, this.playerAngleInitial + this.playerAngleMoved, true, -15);
    const hit = this.otherVehicles.some((vehicle) => {
      const vehicleHitZone1 = this.getHitZonePosition(vehicle.mesh.position, vehicle.angle, vehicle.clockwise, 15);
      const vehicleHitZone2 = this.getHitZonePosition(vehicle.mesh.position, vehicle.angle, vehicle.clockwise, -15);
      if (this.getDistance(playerHitZone1, vehicleHitZone1) < 40)
        return true;
      if (this.getDistance(playerHitZone2, vehicleHitZone2) < 40)
        return true;
      if (this.getDistance(playerHitZone2, vehicleHitZone1) < 40)
        return true;
    });
    if (hit) {
      this.resetElement.style.display = "block";
      this.renderer.setAnimationLoop(null);
      window.removeEventListener("keydown");
    }
  }
  startGame() {
    if (this.ready) {
      this.ready = false;
      this.renderer.setAnimationLoop(this.animation.bind(this));
    }
  }
  reset() {
    window.addEventListener("keydown", (e) => {
      if (e.key == "ArrowUp") {
        this.startGame();
        this.accelerate = true;
        return;
      }
      if (e.key == "ArrowDown") {
        this.decelerate = true;
        return;
      }
      if (e.key == "R" || e.key == "r") {
        this.reset();
        this.resetElement.style.display = "none";
        return;
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key == "ArrowUp") {
        this.accelerate = false;
        return;
      }
      if (e.key == "ArrowDown") {
        this.decelerate = false;
        return;
      }
    });
    this.playerAngleMoved = 0;
    this.playerAngleInitial = Math.PI;
    this.playerSpeed = 17e-4;
    this.movePlayerCar(0);
    this.score = 0;
    this.scoreElement.innerText = this.score;
    this.lastTimeStamp = void 0;
    this.otherVehicles.forEach((vehicle) => {
      this.scene.remove(vehicle.mesh);
    });
    this.otherVehicles = [];
    this.renderer.render(this.scene, this.camera);
    this.ready = true;
  }
  renderMap(mapWidth, mapHeight) {
    const lineMarkingsTexture = getLineMarkings(mapWidth, mapHeight);
    const planeGeometry = new THREE.PlaneBufferGeometry(mapWidth, mapHeight);
    const planeMaterial = new THREE.MeshLambertMaterial({
      color: 5533328,
      map: lineMarkingsTexture
    });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    this.scene.add(plane);
    const islandLeft = getLeftIsland();
    const islandRight = getRightIsland();
    const islandMiddle = getMiddleIsland();
    const outerField = getOuterField(mapWidth, mapHeight);
    const fieldGeometry = new THREE.ExtrudeBufferGeometry([islandLeft, islandMiddle, islandRight, outerField], { depth: 6, bevelEnabled: false });
    const fieldMesh = new THREE.Mesh(fieldGeometry, [
      new THREE.MeshLambertMaterial({ color: 6799936 }),
      new THREE.MeshLambertMaterial({ color: 2306332 })
    ]);
    this.scene.add(fieldMesh);
  }
  initThree() {
    this.scene = new THREE.Scene();
    this.playerCar = Car();
    this.scene.add(this.playerCar);
    const ambientLight = new THREE.AmbientLight(16777215, 0.6);
    this.scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(16777215, 0.6);
    dirLight.position.set(0, 0, 200);
    this.scene.add(dirLight);
    const aspectRatio = window.innerWidth / window.innerHeight;
    const cameraWidth = 960;
    const cameraHeight = cameraWidth / aspectRatio;
    this.camera = new THREE.OrthographicCamera(cameraWidth / -2, cameraWidth / 2, cameraHeight / 2, cameraHeight / -2, 0, 1e3);
    this.camera.position.set(0, -210, 300);
    this.camera.lookAt(0, 0, 0);
    this.renderMap(cameraWidth, cameraHeight * 2);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.render(this.scene, this.camera);
    document.body.appendChild(this.renderer.domElement);
  }
};
var css$c = {
  code: '@import url("https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap");#score.svelte-1hh30x.svelte-1hh30x{font-family:"Dela Gothic One";color:white;position:absolute;top:45vh;left:27vw;font-size:5em}.controls.svelte-1hh30x.svelte-1hh30x{position:absolute;left:2em;bottom:2em}.reset.svelte-1hh30x.svelte-1hh30x{position:absolute;top:50vh;left:50vw;transform:translate(-50%, -50%);display:none}.container.svelte-1hh30x.svelte-1hh30x{color:white;background:#12121299;border-radius:1em;font-size:1.5em;padding:1em}.container.svelte-1hh30x .up.svelte-1hh30x,.container.svelte-1hh30x .down.svelte-1hh30x{display:flex;align-items:center}.container.svelte-1hh30x .up p.svelte-1hh30x,.container.svelte-1hh30x .down p.svelte-1hh30x{margin-left:1em}',
  map: `{"version":3,"file":"__error.svelte","sources":["__error.svelte"],"sourcesContent":["<script>\\r\\n\\timport { onMount } from 'svelte';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { arrowCircleUp, arrowCircleDown } from 'svelte-awesome/icons';\\r\\n\\timport App from '$lib/threejs/App.js';\\r\\n\\r\\n\\tonMount(() => {\\r\\n\\t\\twindow.focus();\\r\\n\\t\\tconst app = new App();\\r\\n\\t\\twindow.app = app;\\r\\n\\t});\\r\\n\\r\\n<\/script>\\r\\n\\r\\n<div id=\\"score\\">0</div>\\r\\n\\r\\n<div class=\\"container controls\\">\\r\\n\\t<div class=\\"up\\">\\r\\n\\t\\t<Icon data={arrowCircleUp} scale=\\"4\\" />\\r\\n\\t\\t<p>Accelerate</p>\\r\\n\\t</div>\\r\\n\\t<div class=\\"down\\">\\r\\n\\t\\t<Icon data={arrowCircleDown} scale=\\"4\\" />\\r\\n\\t\\t<p>Decelerate</p>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<div id=\\"reset\\" class=\\"container reset\\">\\r\\n\\t<p>Press 'R' to reset game</p>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">@import url(\\"https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap\\");\\n#score {\\n  font-family: \\"Dela Gothic One\\";\\n  color: white;\\n  position: absolute;\\n  top: 45vh;\\n  left: 27vw;\\n  font-size: 5em;\\n}\\n\\n.controls {\\n  position: absolute;\\n  left: 2em;\\n  bottom: 2em;\\n}\\n\\n.reset {\\n  position: absolute;\\n  top: 50vh;\\n  left: 50vw;\\n  transform: translate(-50%, -50%);\\n  display: none;\\n}\\n\\n.container {\\n  color: white;\\n  background: #12121299;\\n  border-radius: 1em;\\n  font-size: 1.5em;\\n  padding: 1em;\\n}\\n.container .up,\\n.container .down {\\n  display: flex;\\n  align-items: center;\\n}\\n.container .up p,\\n.container .down p {\\n  margin-left: 1em;\\n}</style>\\r\\n"],"names":[],"mappings":"AA+BmB,QAAQ,IAAI,uEAAuE,CAAC,CAAC,AACxG,MAAM,4BAAC,CAAC,AACN,WAAW,CAAE,iBAAiB,CAC9B,KAAK,CAAE,KAAK,CACZ,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,SAAS,CAAE,GAAG,AAChB,CAAC,AAED,SAAS,4BAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,GAAG,CACT,MAAM,CAAE,GAAG,AACb,CAAC,AAED,MAAM,4BAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,OAAO,CAAE,IAAI,AACf,CAAC,AAED,UAAU,4BAAC,CAAC,AACV,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,GAAG,CAClB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,GAAG,AACd,CAAC,AACD,wBAAU,CAAC,iBAAG,CACd,wBAAU,CAAC,KAAK,cAAC,CAAC,AAChB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,AACrB,CAAC,AACD,wBAAU,CAAC,GAAG,CAAC,eAAC,CAChB,wBAAU,CAAC,KAAK,CAAC,CAAC,cAAC,CAAC,AAClB,WAAW,CAAE,GAAG,AAClB,CAAC"}`
};
var _error = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  onMount(() => {
    window.focus();
    const app = new App$1();
    window.app = app;
  });
  $$result.css.add(css$c);
  return `<div id="${"score"}" class="${"svelte-1hh30x"}">0</div>

<div class="${"container controls svelte-1hh30x"}"><div class="${"up svelte-1hh30x"}">${validate_component(Icon, "Icon").$$render($$result, { data: arrowCircleUp, scale: "4" }, {}, {})}
		<p class="${"svelte-1hh30x"}">Accelerate</p></div>
	<div class="${"down svelte-1hh30x"}">${validate_component(Icon, "Icon").$$render($$result, { data: arrowCircleDown, scale: "4" }, {}, {})}
		<p class="${"svelte-1hh30x"}">Decelerate</p></div></div>

<div id="${"reset"}" class="${"container reset svelte-1hh30x"}"><p class="${"svelte-1hh30x"}">Press &#39;R&#39; to reset game</p>
</div>`;
});
var __error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _error
});
var state = writable2("home");
var css$b = {
  code: '.timeline.svelte-u962qs.svelte-u962qs{position:relative;height:fit-content;font-size:24px}.timeline.svelte-u962qs .timeline-item.svelte-u962qs{margin-bottom:1em;position:relative;font-weight:500}.timeline.svelte-u962qs .timeline-item.svelte-u962qs::before{content:"";width:0.5em;height:0.5em;position:absolute;top:0.3em;left:-1.2em;background:#7a88d8;border-radius:100%}.timeline.svelte-u962qs .timeline-item h1.svelte-u962qs{font-weight:600;font-size:1em}.timeline.svelte-u962qs .timeline-item h1 span.svelte-u962qs{font-weight:500;font-size:0.75em}.timeline.svelte-u962qs .timeline-item h2.svelte-u962qs{font-size:1em;font-weight:400;opacity:0.8}.timeline.svelte-u962qs .timeline-item h3.svelte-u962qs{font-size:1em;font-weight:400;color:#c362f6}.timeline.svelte-u962qs.svelte-u962qs::before{top:0;left:-1em;content:"";position:absolute;width:2px;height:100%;background:#7a88d8}@media only screen and (max-width: 1366px){.timeline.svelte-u962qs.svelte-u962qs{font-size:18px}}@media only screen and (max-width: 512px){.timeline.svelte-u962qs.svelte-u962qs{font-size:18px}.timeline.svelte-u962qs.svelte-u962qs::before{left:-0.5em}.timeline.svelte-u962qs .timeline-item.svelte-u962qs::before{left:-0.65em}}',
  map: `{"version":3,"file":"education.svelte","sources":["education.svelte"],"sourcesContent":["<script>\\r\\n\\timport { fly } from 'svelte/transition';\\r\\n\\tlet education = [\\r\\n\\t\\t{\\r\\n\\t\\t\\tinstituteName: 'NIT Hamirpur',\\r\\n\\t\\t\\tdegree: 'BTech',\\r\\n\\t\\t\\ttime: '2018-Present',\\r\\n\\t\\t\\tresult: 'CGPA 9.46'\\r\\n\\t\\t},\\r\\n\\t\\t{\\r\\n\\t\\t\\tinstituteName: 'DAV Public School (Sec 14, GGN)',\\r\\n\\t\\t\\tdegree: 'Class 12',\\r\\n\\t\\t\\ttime: '2018',\\r\\n\\t\\t\\tresult: '95.6%'\\r\\n\\t\\t}\\r\\n\\t];\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"timeline\\">\\r\\n\\t{#each education as item}\\r\\n\\t\\t<div class=\\"timeline-item\\">\\r\\n\\t\\t\\t<h3>{item.time}</h3>\\r\\n\\t\\t\\t<h1>{item.instituteName} - <span>({item.degree})</span></h1>\\r\\n\\t\\t\\t<h2>{item.result}</h2>\\r\\n\\t\\t</div>\\r\\n\\t{/each}\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.timeline {\\n  position: relative;\\n  height: fit-content;\\n  font-size: 24px;\\n}\\n.timeline .timeline-item {\\n  margin-bottom: 1em;\\n  position: relative;\\n  font-weight: 500;\\n}\\n.timeline .timeline-item::before {\\n  content: \\"\\";\\n  width: 0.5em;\\n  height: 0.5em;\\n  position: absolute;\\n  top: 0.3em;\\n  left: -1.2em;\\n  background: #7a88d8;\\n  border-radius: 100%;\\n}\\n.timeline .timeline-item h1 {\\n  font-weight: 600;\\n  font-size: 1em;\\n}\\n.timeline .timeline-item h1 span {\\n  font-weight: 500;\\n  font-size: 0.75em;\\n}\\n.timeline .timeline-item h2 {\\n  font-size: 1em;\\n  font-weight: 400;\\n  opacity: 0.8;\\n}\\n.timeline .timeline-item h3 {\\n  font-size: 1em;\\n  font-weight: 400;\\n  color: #c362f6;\\n}\\n.timeline::before {\\n  top: 0;\\n  left: -1em;\\n  content: \\"\\";\\n  position: absolute;\\n  width: 2px;\\n  height: 100%;\\n  background: #7a88d8;\\n}\\n\\n@media only screen and (max-width: 1366px) {\\n  .timeline {\\n    font-size: 18px;\\n  }\\n}\\n@media only screen and (max-width: 512px) {\\n  .timeline {\\n    font-size: 18px;\\n  }\\n  .timeline::before {\\n    left: -0.5em;\\n  }\\n  .timeline .timeline-item::before {\\n    left: -0.65em;\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AA4BmB,SAAS,4BAAC,CAAC,AAC5B,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,WAAW,CACnB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,uBAAS,CAAC,cAAc,cAAC,CAAC,AACxB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,QAAQ,CAClB,WAAW,CAAE,GAAG,AAClB,CAAC,AACD,uBAAS,CAAC,4BAAc,QAAQ,AAAC,CAAC,AAChC,OAAO,CAAE,EAAE,CACX,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,IAAI,CAAE,MAAM,CACZ,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,IAAI,AACrB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,GAAG,AAChB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,CAAC,IAAI,cAAC,CAAC,AAChC,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,MAAM,AACnB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,OAAO,CAAE,GAAG,AACd,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,qCAAS,QAAQ,AAAC,CAAC,AACjB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,OAAO,AACrB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,SAAS,4BAAC,CAAC,AACT,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC,AACD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,SAAS,4BAAC,CAAC,AACT,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,qCAAS,QAAQ,AAAC,CAAC,AACjB,IAAI,CAAE,MAAM,AACd,CAAC,AACD,uBAAS,CAAC,4BAAc,QAAQ,AAAC,CAAC,AAChC,IAAI,CAAE,OAAO,AACf,CAAC,AACH,CAAC"}`
};
var Education = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let education = [
    {
      instituteName: "NIT Hamirpur",
      degree: "BTech",
      time: "2018-Present",
      result: "CGPA 9.46"
    },
    {
      instituteName: "DAV Public School (Sec 14, GGN)",
      degree: "Class 12",
      time: "2018",
      result: "95.6%"
    }
  ];
  $$result.css.add(css$b);
  return `<div class="${"timeline svelte-u962qs"}">${each(education, (item) => `<div class="${"timeline-item svelte-u962qs"}"><h3 class="${"svelte-u962qs"}">${escape3(item.time)}</h3>
			<h1 class="${"svelte-u962qs"}">${escape3(item.instituteName)} - <span class="${"svelte-u962qs"}">(${escape3(item.degree)})</span></h1>
			<h2 class="${"svelte-u962qs"}">${escape3(item.result)}</h2>
		</div>`)}
</div>`;
});
var css$a = {
  code: '.timeline.svelte-9sdatt.svelte-9sdatt{position:relative;height:fit-content;font-size:24px}.timeline.svelte-9sdatt .timeline-item.svelte-9sdatt{margin-bottom:1em;position:relative;font-weight:500}.timeline.svelte-9sdatt .timeline-item.svelte-9sdatt::before{content:"";width:0.5em;height:0.5em;position:absolute;top:0.4em;left:-1.2em;background:#7a88d8;border-radius:100%}.timeline.svelte-9sdatt .timeline-item h3.svelte-9sdatt{font-size:1em;font-weight:400;color:#c362f6}.timeline.svelte-9sdatt .timeline-item h1.svelte-9sdatt{font-weight:600;font-size:1em}.timeline.svelte-9sdatt .timeline-item h1 span.svelte-9sdatt{font-weight:500;font-size:0.75em}.timeline.svelte-9sdatt .timeline-item h2.svelte-9sdatt{font-size:1em;font-weight:400;opacity:0.8}.timeline.svelte-9sdatt.svelte-9sdatt::before{top:0;left:-1em;content:"";position:absolute;width:2px;height:100%;background:#7a88d8}@media only screen and (max-width: 1366px){.timeline.svelte-9sdatt.svelte-9sdatt{font-size:18px}}@media only screen and (max-width: 512px){.timeline.svelte-9sdatt.svelte-9sdatt{font-size:18px}.timeline.svelte-9sdatt.svelte-9sdatt::before{left:-0.5em}.timeline.svelte-9sdatt .timeline-item.svelte-9sdatt::before{left:-0.65em}}',
  map: `{"version":3,"file":"experience.svelte","sources":["experience.svelte"],"sourcesContent":["<script>\\r\\n    import {  fly } from 'svelte/transition'\\r\\n\\tlet experience = [\\r\\n        {\\r\\n            title: 'GSoC 2021 Mentor',\\r\\n\\t\\t\\tposition: 'Catrobat',\\r\\n\\t\\t\\ttime: 'Jun 2021 - Present',\\r\\n\\t\\t\\tdescription: 'To guide a student for the project Awesome Demo Game Project by Catrobat'\\r\\n        },\\r\\n\\t\\t{\\r\\n\\t\\t\\ttitle: 'Ajna Lens',\\r\\n\\t\\t\\tposition: 'Intern',\\r\\n\\t\\t\\ttime: 'Jan 2021 - Mar 2021',\\r\\n\\t\\t\\tdescription: 'Creating XR experiences for AjnaLens headset. Unity3D Development. AR/VR Development.'\\r\\n\\t\\t},\\r\\n        {\\r\\n            title: 'GSoC 2020 Student',\\r\\n\\t\\t\\tposition: 'Catrobat',\\r\\n\\t\\t\\ttime: 'Jun 2020 - September 2020',\\r\\n\\t\\t\\tdescription: 'Creating a 2D showcase game for Pocket Code app by Catrobat. Game developed Batroid.'\\r\\n        }\\r\\n\\t];\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"timeline\\">\\r\\n\\t{#each experience as item}\\r\\n\\t\\t<div class=\\"timeline-item\\">\\r\\n\\t\\t\\t<h3>{item.title}</h3>\\r\\n\\t\\t\\t<h1>{item.position} - <span>({item.time})</span></h1>\\r\\n\\t\\t\\t<h2>{item.description}</h2>\\r\\n\\t\\t</div>\\r\\n\\t{/each}\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.timeline {\\n  position: relative;\\n  height: fit-content;\\n  font-size: 24px;\\n}\\n.timeline .timeline-item {\\n  margin-bottom: 1em;\\n  position: relative;\\n  font-weight: 500;\\n}\\n.timeline .timeline-item::before {\\n  content: \\"\\";\\n  width: 0.5em;\\n  height: 0.5em;\\n  position: absolute;\\n  top: 0.4em;\\n  left: -1.2em;\\n  background: #7a88d8;\\n  border-radius: 100%;\\n}\\n.timeline .timeline-item h3 {\\n  font-size: 1em;\\n  font-weight: 400;\\n  color: #c362f6;\\n}\\n.timeline .timeline-item h1 {\\n  font-weight: 600;\\n  font-size: 1em;\\n}\\n.timeline .timeline-item h1 span {\\n  font-weight: 500;\\n  font-size: 0.75em;\\n}\\n.timeline .timeline-item h2 {\\n  font-size: 1em;\\n  font-weight: 400;\\n  opacity: 0.8;\\n}\\n.timeline::before {\\n  top: 0;\\n  left: -1em;\\n  content: \\"\\";\\n  position: absolute;\\n  width: 2px;\\n  height: 100%;\\n  background: #7a88d8;\\n}\\n\\n@media only screen and (max-width: 1366px) {\\n  .timeline {\\n    font-size: 18px;\\n  }\\n}\\n@media only screen and (max-width: 512px) {\\n  .timeline {\\n    font-size: 18px;\\n  }\\n  .timeline::before {\\n    left: -0.5em;\\n  }\\n  .timeline .timeline-item::before {\\n    left: -0.65em;\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAkCmB,SAAS,4BAAC,CAAC,AAC5B,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,WAAW,CACnB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,uBAAS,CAAC,cAAc,cAAC,CAAC,AACxB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,QAAQ,CAClB,WAAW,CAAE,GAAG,AAClB,CAAC,AACD,uBAAS,CAAC,4BAAc,QAAQ,AAAC,CAAC,AAChC,OAAO,CAAE,EAAE,CACX,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,IAAI,CAAE,MAAM,CACZ,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,IAAI,AACrB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,GAAG,AAChB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,CAAC,IAAI,cAAC,CAAC,AAChC,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,MAAM,AACnB,CAAC,AACD,uBAAS,CAAC,cAAc,CAAC,EAAE,cAAC,CAAC,AAC3B,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,OAAO,CAAE,GAAG,AACd,CAAC,AACD,qCAAS,QAAQ,AAAC,CAAC,AACjB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,OAAO,AACrB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,SAAS,4BAAC,CAAC,AACT,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC,AACD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,SAAS,4BAAC,CAAC,AACT,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,qCAAS,QAAQ,AAAC,CAAC,AACjB,IAAI,CAAE,MAAM,AACd,CAAC,AACD,uBAAS,CAAC,4BAAc,QAAQ,AAAC,CAAC,AAChC,IAAI,CAAE,OAAO,AACf,CAAC,AACH,CAAC"}`
};
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let experience = [
    {
      title: "GSoC 2021 Mentor",
      position: "Catrobat",
      time: "Jun 2021 - Present",
      description: "To guide a student for the project Awesome Demo Game Project by Catrobat"
    },
    {
      title: "Ajna Lens",
      position: "Intern",
      time: "Jan 2021 - Mar 2021",
      description: "Creating XR experiences for AjnaLens headset. Unity3D Development. AR/VR Development."
    },
    {
      title: "GSoC 2020 Student",
      position: "Catrobat",
      time: "Jun 2020 - September 2020",
      description: "Creating a 2D showcase game for Pocket Code app by Catrobat. Game developed Batroid."
    }
  ];
  $$result.css.add(css$a);
  return `<div class="${"timeline svelte-9sdatt"}">${each(experience, (item) => `<div class="${"timeline-item svelte-9sdatt"}"><h3 class="${"svelte-9sdatt"}">${escape3(item.title)}</h3>
			<h1 class="${"svelte-9sdatt"}">${escape3(item.position)} - <span class="${"svelte-9sdatt"}">(${escape3(item.time)})</span></h1>
			<h2 class="${"svelte-9sdatt"}">${escape3(item.description)}</h2>
		</div>`)}
</div>`;
});
var css$9 = {
  code: '.more-container.svelte-1lo098a.svelte-1lo098a{width:60vw;border-radius:2rem;display:grid;gap:1em;grid-template-columns:1fr 2fr;font-size:24px}.more-container.svelte-1lo098a img.svelte-1lo098a{width:20rem;height:30rem;object-fit:cover;border-radius:2rem;border:0.2rem solid #1ee8b788;margin:4em auto}.more-container.svelte-1lo098a .content.svelte-1lo098a{height:fit-content}.more-container.svelte-1lo098a .content h1.svelte-1lo098a{font-family:"Montserrat"}.more-container.svelte-1lo098a .content p.svelte-1lo098a{font-weight:300;margin-top:3rem;text-align:justify;font-size:0.9em}.more-container.svelte-1lo098a .content h3.svelte-1lo098a{margin:2em 0 1em 0}.more-container.svelte-1lo098a .content .skills.svelte-1lo098a{display:flex;flex-wrap:wrap}.more-container.svelte-1lo098a .content .skills .skill-item.svelte-1lo098a{width:fit-content;margin:0.3em;background:#1ee8b788;border-radius:1em;font-size:0.8em;padding:0.2em 0.5em}.more-container.svelte-1lo098a .content .tabButtons.svelte-1lo098a{display:flex}.more-container.svelte-1lo098a .content .tabButtons .educationButton.svelte-1lo098a,.more-container.svelte-1lo098a .content .tabButtons .experienceButton.svelte-1lo098a{position:relative;margin:1em 1em;cursor:pointer;transition:all 0.3s}.more-container.svelte-1lo098a .content .tabButtons .educationButton.svelte-1lo098a:hover,.more-container.svelte-1lo098a .content .tabButtons .experienceButton.svelte-1lo098a:hover{color:#c362f6}.more-container.svelte-1lo098a .content .buttons.svelte-1lo098a{margin-top:2em}.more-container.svelte-1lo098a .content .buttons a.svelte-1lo098a{width:20rem;font-size:0.8em;text-decoration:none;color:white;background:#1ee8b722;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);width:fit-content;padding:0.5rem 1rem;border-radius:2rem;transition:ease-out 0.3s}.more-container.svelte-1lo098a .content .buttons a.svelte-1lo098a:hover{background:#1ee8b7;color:black}.selected.svelte-1lo098a.svelte-1lo098a{color:#c362f6}@media only screen and (max-width: 1366px){.more-container.svelte-1lo098a.svelte-1lo098a{font-size:18px}.more-container.svelte-1lo098a img.svelte-1lo098a{width:15rem;height:20rem;object-fit:cover}}@media only screen and (max-width: 512px){.more-container.svelte-1lo098a.svelte-1lo098a{width:70vw;font-size:14px;display:flex;flex-direction:column}}',
  map: `{"version":3,"file":"about.svelte","sources":["about.svelte"],"sourcesContent":["<script>\\r\\n\\timport Education from '$lib/components/education.svelte';\\r\\n\\timport Experience from '$lib/components/experience.svelte';\\r\\n\\tconst profileUrl = 'Profile3.jpg';\\r\\n\\timport { fade } from 'svelte/transition';\\r\\n\\r\\n\\tconst skillList = [\\r\\n\\t\\t'C#',\\r\\n\\t\\t'Unity3D',\\r\\n\\t\\t'WebXR',\\r\\n\\t\\t'ARFoundation',\\r\\n\\t\\t'AR Core',\\r\\n\\t\\t'Web Dev',\\r\\n\\t\\t'C++',\\r\\n\\t\\t'Python',\\r\\n\\t\\t'Blender',\\r\\n\\t\\t'Photoshop'\\r\\n\\t];\\r\\n\\r\\n\\tlet tab = 'education';\\r\\n\\tlet educationTab;\\r\\n\\tlet experienceTab;\\r\\n\\r\\n\\tconst toggleTab = (tabName) => {\\r\\n\\t\\tconsole.log(tab);\\r\\n\\t\\ttab = tabName;\\r\\n\\t\\tif (tab == 'experience') {\\r\\n\\t\\t\\teducationTab.classList.remove('selected');\\r\\n\\t\\t\\texperienceTab.classList.add('selected');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\teducationTab.classList.add('selected');\\r\\n\\t\\t\\texperienceTab.classList.remove('selected');\\r\\n\\t\\t}\\r\\n\\t};\\r\\n<\/script>\\r\\n\\r\\n<div in:fade class=\\"more-container\\">\\r\\n\\t<img src={profileUrl} alt=\\"profile=pic\\" />\\r\\n\\t<div class=\\"content\\">\\r\\n\\t\\t<h1>About Me</h1>\\r\\n\\t\\t<p>\\r\\n\\t\\t\\tA Game Dev enthusiast specializing in Augmented Reality and Virtual Reality for the next gen\\r\\n\\t\\t\\tgames and apps. Also fluent in various web technologies and I fiddle with WebXR to showcase XR\\r\\n\\t\\t\\tto everyone! I also play Ukulele and Piano sometimes :D\\r\\n\\t\\t</p>\\r\\n\\t\\t<h3>Skills</h3>\\r\\n\\t\\t<div class=\\"skills\\">\\r\\n\\t\\t\\t{#each skillList as skill}\\r\\n\\t\\t\\t\\t<div class=\\"skill-item\\">{skill}</div>\\r\\n\\t\\t\\t{/each}\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"tabButtons\\">\\r\\n\\t\\t\\t<div\\r\\n\\t\\t\\t\\tbind:this={educationTab}\\r\\n\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\ttoggleTab('education');\\r\\n\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\tclass=\\"educationButton selected\\"\\r\\n\\t\\t\\t>\\r\\n\\t\\t\\t\\tEducation\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div\\r\\n\\t\\t\\t\\tbind:this={experienceTab}\\r\\n\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\ttoggleTab('experience');\\r\\n\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\tclass=\\"experienceButton\\"\\r\\n\\t\\t\\t>\\r\\n\\t\\t\\t\\tExperience\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t\\t{#key tab}\\r\\n\\t\\t\\t{#if tab == 'education'}\\r\\n\\t\\t\\t\\t<Education />\\r\\n\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t<Experience />\\r\\n\\t\\t\\t{/if}\\r\\n\\t\\t{/key}\\r\\n\\t\\t<div class=\\"buttons\\">\\r\\n\\t\\t\\t<a\\r\\n\\t\\t\\t\\ttarget=\\"_blank\\"\\r\\n\\t\\t\\t\\thref=\\"https://drive.google.com/file/d/1LqvEyZ4BSR01hWaAtpge8FQS25xny_1Z/view?usp=sharing\\"\\r\\n\\t\\t\\t\\tclass=\\"resumeButton\\">Download Resume</a\\r\\n\\t\\t\\t>\\r\\n\\t\\t\\t<a href=\\"/contact\\">Contact Me</a>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.more-container {\\n  width: 60vw;\\n  border-radius: 2rem;\\n  display: grid;\\n  gap: 1em;\\n  grid-template-columns: 1fr 2fr;\\n  font-size: 24px;\\n}\\n.more-container img {\\n  width: 20rem;\\n  height: 30rem;\\n  object-fit: cover;\\n  border-radius: 2rem;\\n  border: 0.2rem solid #1ee8b788;\\n  margin: 4em auto;\\n}\\n.more-container .content {\\n  height: fit-content;\\n}\\n.more-container .content h1 {\\n  font-family: \\"Montserrat\\";\\n}\\n.more-container .content p {\\n  font-weight: 300;\\n  margin-top: 3rem;\\n  text-align: justify;\\n  font-size: 0.9em;\\n}\\n.more-container .content h3 {\\n  margin: 2em 0 1em 0;\\n}\\n.more-container .content .skills {\\n  display: flex;\\n  flex-wrap: wrap;\\n}\\n.more-container .content .skills .skill-item {\\n  width: fit-content;\\n  margin: 0.3em;\\n  background: #1ee8b788;\\n  border-radius: 1em;\\n  font-size: 0.8em;\\n  padding: 0.2em 0.5em;\\n}\\n.more-container .content .tabButtons {\\n  display: flex;\\n}\\n.more-container .content .tabButtons .educationButton,\\n.more-container .content .tabButtons .experienceButton {\\n  position: relative;\\n  margin: 1em 1em;\\n  cursor: pointer;\\n  transition: all 0.3s;\\n}\\n.more-container .content .tabButtons .educationButton:hover,\\n.more-container .content .tabButtons .experienceButton:hover {\\n  color: #c362f6;\\n}\\n.more-container .content .buttons {\\n  margin-top: 2em;\\n}\\n.more-container .content .buttons a {\\n  width: 20rem;\\n  font-size: 0.8em;\\n  text-decoration: none;\\n  color: white;\\n  background: #1ee8b722;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n  width: fit-content;\\n  padding: 0.5rem 1rem;\\n  border-radius: 2rem;\\n  transition: ease-out 0.3s;\\n}\\n.more-container .content .buttons a:hover {\\n  background: #1ee8b7;\\n  color: black;\\n}\\n\\n.selected {\\n  color: #c362f6;\\n}\\n\\n@media only screen and (max-width: 1366px) {\\n  .more-container {\\n    font-size: 18px;\\n  }\\n  .more-container img {\\n    width: 15rem;\\n    height: 20rem;\\n    object-fit: cover;\\n  }\\n}\\n@media only screen and (max-width: 512px) {\\n  .more-container {\\n    width: 70vw;\\n    font-size: 14px;\\n    display: flex;\\n    flex-direction: column;\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAyFmB,eAAe,8BAAC,CAAC,AAClC,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,GAAG,CAAE,GAAG,CACR,qBAAqB,CAAE,GAAG,CAAC,GAAG,CAC9B,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,8BAAe,CAAC,GAAG,eAAC,CAAC,AACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAC9B,MAAM,CAAE,GAAG,CAAC,IAAI,AAClB,CAAC,AACD,8BAAe,CAAC,QAAQ,eAAC,CAAC,AACxB,MAAM,CAAE,WAAW,AACrB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,EAAE,eAAC,CAAC,AAC3B,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,CAAC,eAAC,CAAC,AAC1B,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,KAAK,AAClB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,EAAE,eAAC,CAAC,AAC3B,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,AACrB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,OAAO,eAAC,CAAC,AAChC,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,eAAC,CAAC,AAC5C,KAAK,CAAE,WAAW,CAClB,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,GAAG,CAClB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,KAAK,CAAC,KAAK,AACtB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,WAAW,eAAC,CAAC,AACpC,OAAO,CAAE,IAAI,AACf,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,+BAAgB,CACrD,8BAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,iBAAiB,eAAC,CAAC,AACtD,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,GAAG,CAAC,GAAG,CACf,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,IAAI,AACtB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,+BAAgB,MAAM,CAC3D,8BAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,gCAAiB,MAAM,AAAC,CAAC,AAC5D,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,QAAQ,eAAC,CAAC,AACjC,UAAU,CAAE,GAAG,AACjB,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,eAAC,CAAC,AACnC,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,CAChB,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpF,KAAK,CAAE,WAAW,CAClB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,QAAQ,CAAC,IAAI,AAC3B,CAAC,AACD,8BAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAC,MAAM,AAAC,CAAC,AACzC,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,SAAS,8BAAC,CAAC,AACT,KAAK,CAAE,OAAO,AAChB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,eAAe,8BAAC,CAAC,AACf,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,8BAAe,CAAC,GAAG,eAAC,CAAC,AACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,AACnB,CAAC,AACH,CAAC,AACD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,eAAe,8BAAC,CAAC,AACf,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,IAAI,CACf,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACxB,CAAC,AACH,CAAC"}`
};
var profileUrl$1 = "Profile3.jpg";
var About$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const skillList = [
    "C#",
    "Unity3D",
    "WebXR",
    "ARFoundation",
    "AR Core",
    "Web Dev",
    "C++",
    "Python",
    "Blender",
    "Photoshop"
  ];
  let educationTab;
  let experienceTab;
  $$result.css.add(css$9);
  return `<div class="${"more-container svelte-1lo098a"}"><img${add_attribute("src", profileUrl$1, 0)} alt="${"profile=pic"}" class="${"svelte-1lo098a"}">
	<div class="${"content svelte-1lo098a"}"><h1 class="${"svelte-1lo098a"}">About Me</h1>
		<p class="${"svelte-1lo098a"}">A Game Dev enthusiast specializing in Augmented Reality and Virtual Reality for the next gen
			games and apps. Also fluent in various web technologies and I fiddle with WebXR to showcase XR
			to everyone! I also play Ukulele and Piano sometimes :D
		</p>
		<h3 class="${"svelte-1lo098a"}">Skills</h3>
		<div class="${"skills svelte-1lo098a"}">${each(skillList, (skill) => `<div class="${"skill-item svelte-1lo098a"}">${escape3(skill)}</div>`)}</div>
		<div class="${"tabButtons svelte-1lo098a"}"><div class="${"educationButton selected svelte-1lo098a"}"${add_attribute("this", educationTab, 1)}>Education
			</div>
			<div class="${"experienceButton svelte-1lo098a"}"${add_attribute("this", experienceTab, 1)}>Experience
			</div></div>
		${`${validate_component(Education, "Education").$$render($$result, {}, {}, {})}`}
		<div class="${"buttons svelte-1lo098a"}"><a target="${"_blank"}" href="${"https://drive.google.com/file/d/1LqvEyZ4BSR01hWaAtpge8FQS25xny_1Z/view?usp=sharing"}" class="${"resumeButton svelte-1lo098a"}">Download Resume</a>
			<a href="${"/contact"}" class="${"svelte-1lo098a"}">Contact Me</a></div></div>
</div>`;
});
var css$8 = {
  code: ".home-container.svelte-9z07xd.svelte-9z07xd{display:flex;align-items:flex-start;flex-direction:column;font-size:24px}.home-container.svelte-9z07xd .highlight.svelte-9z07xd{color:#1ee8b7;text-decoration:none}.home-container.svelte-9z07xd p.svelte-9z07xd{font-weight:200}.home-container.svelte-9z07xd .svelte-9z07xd{margin:0.5em 0}.home-container.svelte-9z07xd .links.svelte-9z07xd{margin:2em 0}.home-container.svelte-9z07xd .links a.svelte-9z07xd{margin-right:1em;color:white}.home-container.svelte-9z07xd .links a.svelte-9z07xd:hover{color:#1ee8b7}.home-container.svelte-9z07xd .buttons.svelte-9z07xd{display:grid;grid-template-columns:1fr}.home-container.svelte-9z07xd .buttons a.svelte-9z07xd,.home-container.svelte-9z07xd .buttons div.svelte-9z07xd{cursor:pointer;width:20rem;font-size:0.8em;text-decoration:none;color:white;background:#1ee8b722;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);width:fit-content;padding:0.5rem 1rem;border-radius:2rem;transition:ease-out 0.3s}.home-container.svelte-9z07xd .buttons a.svelte-9z07xd:hover,.home-container.svelte-9z07xd .buttons div.svelte-9z07xd:hover{background:#1ee8b7;color:black}@media only screen and (max-width: 1366px){.home-container.svelte-9z07xd.svelte-9z07xd{font-size:18px}}@media only screen and (max-width: 512px){.home-container.svelte-9z07xd.svelte-9z07xd{font-size:14px}}",
  map: `{"version":3,"file":"home.svelte","sources":["home.svelte"],"sourcesContent":["<script>\\r\\n\\timport { state } from '$lib/stores/stateStores';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { twitter, linkedin, github } from 'svelte-awesome/icons';\\r\\n\\timport { fade } from 'svelte/transition';\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"home-container\\">\\r\\n\\t<p>Hello I'm</p>\\r\\n\\t<h1>Yash Punia</h1>\\r\\n\\t<p>I make <strong>AR apps</strong> and <strong>Video Games</strong></p>\\r\\n\\t<p><strong class=\\"highlight\\">GSoC 2020</strong> at Catrobat | President (Team ISTE)</p>\\r\\n\\t<p>Check out my games on <a href=\\"https://yashpunia.itch.io/\\"  class=\\"highlight\\"><strong>itch.io</strong></a></p>\\r\\n\\t<div class=\\"buttons\\">\\r\\n\\t\\t<div\\r\\n\\t\\t\\ton:click={() => {\\r\\n\\t\\t\\t\\tstate.set(\\"more\\")\\r\\n\\t\\t\\t}}\\r\\n\\t\\t>\\r\\n\\t\\t\\tMore About Me\\r\\n\\t\\t</div>\\r\\n        <a href=\\"/game\\" target=\\"__blank\\">\\r\\n            Play a Game?\\r\\n        </a>\\r\\n\\t</div>\\r\\n\\t<div class=\\"links\\">\\r\\n\\t\\t<a href=\\"https://twitter.com/zeldariomon\\" target=\\"__blank\\"\\r\\n\\t\\t\\t><Icon data={twitter} scale=\\"2\\" />\\r\\n\\t\\t</a>\\r\\n\\t\\t<a href=\\"https://www.linkedin.com/in/yash-punia/\\" target=\\"__blank\\"\\r\\n\\t\\t\\t><Icon data={linkedin} scale=\\"2\\" />\\r\\n\\t\\t</a>\\r\\n\\t\\t<a href=\\"https://github.com/Yash-Punia/\\" target=\\"__blank\\">\\r\\n\\t\\t\\t<Icon data={github} scale=\\"2\\" />\\r\\n\\t\\t</a>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.home-container {\\n  display: flex;\\n  align-items: flex-start;\\n  flex-direction: column;\\n  font-size: 24px;\\n}\\n.home-container .highlight {\\n  color: #1ee8b7;\\n  text-decoration: none;\\n}\\n.home-container p {\\n  font-weight: 200;\\n}\\n.home-container * {\\n  margin: 0.5em 0;\\n}\\n.home-container .links {\\n  margin: 2em 0;\\n}\\n.home-container .links a {\\n  margin-right: 1em;\\n  color: white;\\n}\\n.home-container .links a:hover {\\n  color: #1ee8b7;\\n}\\n.home-container .buttons {\\n  display: grid;\\n  grid-template-columns: 1fr;\\n}\\n.home-container .buttons a, .home-container .buttons div {\\n  cursor: pointer;\\n  width: 20rem;\\n  font-size: 0.8em;\\n  text-decoration: none;\\n  color: white;\\n  background: #1ee8b722;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n  width: fit-content;\\n  padding: 0.5rem 1rem;\\n  border-radius: 2rem;\\n  transition: ease-out 0.3s;\\n}\\n.home-container .buttons a:hover, .home-container .buttons div:hover {\\n  background: #1ee8b7;\\n  color: black;\\n}\\n\\n@media only screen and (max-width: 1366px) {\\n  .home-container {\\n    font-size: 18px;\\n  }\\n}\\n@media only screen and (max-width: 512px) {\\n  .home-container {\\n    font-size: 14px;\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAsCmB,eAAe,4BAAC,CAAC,AAClC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,UAAU,CACvB,cAAc,CAAE,MAAM,CACtB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,6BAAe,CAAC,UAAU,cAAC,CAAC,AAC1B,KAAK,CAAE,OAAO,CACd,eAAe,CAAE,IAAI,AACvB,CAAC,AACD,6BAAe,CAAC,CAAC,cAAC,CAAC,AACjB,WAAW,CAAE,GAAG,AAClB,CAAC,AACD,6BAAe,CAAC,cAAE,CAAC,AACjB,MAAM,CAAE,KAAK,CAAC,CAAC,AACjB,CAAC,AACD,6BAAe,CAAC,MAAM,cAAC,CAAC,AACtB,MAAM,CAAE,GAAG,CAAC,CAAC,AACf,CAAC,AACD,6BAAe,CAAC,MAAM,CAAC,CAAC,cAAC,CAAC,AACxB,YAAY,CAAE,GAAG,CACjB,KAAK,CAAE,KAAK,AACd,CAAC,AACD,6BAAe,CAAC,MAAM,CAAC,eAAC,MAAM,AAAC,CAAC,AAC9B,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,6BAAe,CAAC,QAAQ,cAAC,CAAC,AACxB,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,GAAG,AAC5B,CAAC,AACD,6BAAe,CAAC,QAAQ,CAAC,eAAC,CAAE,6BAAe,CAAC,QAAQ,CAAC,GAAG,cAAC,CAAC,AACxD,MAAM,CAAE,OAAO,CACf,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,CAChB,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpF,KAAK,CAAE,WAAW,CAClB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,QAAQ,CAAC,IAAI,AAC3B,CAAC,AACD,6BAAe,CAAC,QAAQ,CAAC,eAAC,MAAM,CAAE,6BAAe,CAAC,QAAQ,CAAC,iBAAG,MAAM,AAAC,CAAC,AACpE,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,eAAe,4BAAC,CAAC,AACf,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC,AACD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,eAAe,4BAAC,CAAC,AACf,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC"}`
};
var Home = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$8);
  return `<div class="${"home-container svelte-9z07xd"}"><p class="${"svelte-9z07xd"}">Hello I&#39;m</p>
	<h1 class="${"svelte-9z07xd"}">Yash Punia</h1>
	<p class="${"svelte-9z07xd"}">I make <strong class="${"svelte-9z07xd"}">AR apps</strong> and <strong class="${"svelte-9z07xd"}">Video Games</strong></p>
	<p class="${"svelte-9z07xd"}"><strong class="${"highlight svelte-9z07xd"}">GSoC 2020</strong> at Catrobat | President (Team ISTE)</p>
	<p class="${"svelte-9z07xd"}">Check out my games on <a href="${"https://yashpunia.itch.io/"}" class="${"highlight svelte-9z07xd"}"><strong class="${"svelte-9z07xd"}">itch.io</strong></a></p>
	<div class="${"buttons svelte-9z07xd"}"><div class="${"svelte-9z07xd"}">More About Me
		</div>
        <a href="${"/game"}" target="${"__blank"}" class="${"svelte-9z07xd"}">Play a Game?
        </a></div>
	<div class="${"links svelte-9z07xd"}"><a href="${"https://twitter.com/zeldariomon"}" target="${"__blank"}" class="${"svelte-9z07xd"}">${validate_component(Icon, "Icon").$$render($$result, { data: twitter, scale: "2" }, {}, {})}</a>
		<a href="${"https://www.linkedin.com/in/yash-punia/"}" target="${"__blank"}" class="${"svelte-9z07xd"}">${validate_component(Icon, "Icon").$$render($$result, { data: linkedin, scale: "2" }, {}, {})}</a>
		<a href="${"https://github.com/Yash-Punia/"}" target="${"__blank"}" class="${"svelte-9z07xd"}">${validate_component(Icon, "Icon").$$render($$result, { data: github, scale: "2" }, {}, {})}</a></div>
</div>`;
});
var css$7 = {
  code: ".homeTab.svelte-17jgy3n.svelte-17jgy3n{width:fit-content;cursor:pointer}.navbar.svelte-17jgy3n.svelte-17jgy3n{display:flex;font-size:20px;position:absolute;top:-2em;right:0}.navbar.svelte-17jgy3n .tab.svelte-17jgy3n{cursor:pointer;background:#1ee8b7;color:black;border-radius:1em;padding:1em;margin-left:1em;transition:all 0.3s;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1)}.navbar.svelte-17jgy3n .selected.svelte-17jgy3n{background:#121212;color:#fff;border:2px solid #1ee8b7}@media only screen and (max-width: 1366px){.navbar.svelte-17jgy3n.svelte-17jgy3n{top:-1.5em;font-size:18px}.navbar.svelte-17jgy3n .tab.svelte-17jgy3n{padding:0.8em 1em}}",
  map: `{"version":3,"file":"navbar.svelte","sources":["navbar.svelte"],"sourcesContent":["<script>\\r\\n    import { state } from '$lib/stores/stateStores';\\r\\n\\timport { arrowLeft } from 'svelte-awesome/icons';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\r\\n    let tabs = [];\\r\\n\\tconst handleClick = (tabName, tabDiv) => {\\r\\n        if(tabName == $state)\\r\\n            return;\\r\\n        state.set(tabName);\\r\\n        tabs.forEach(tab => {\\r\\n            tab.classList.remove(\\"selected\\");\\r\\n        })\\r\\n        tabDiv.classList.add(\\"selected\\");\\r\\n    };\\r\\n<\/script>\\r\\n\\r\\n<div on:click={e=>{handleClick(\\"home\\",e.target)}} bind:this={tabs[0]} class=\\"homeTab\\">\\r\\n\\t<Icon data={arrowLeft} scale=2/>\\r\\n</div>\\r\\n<div class=\\"navbar\\">\\r\\n\\t<div on:click={e=>{handleClick(\\"more\\",e.target)}} bind:this={tabs[1]} class=\\"tab selected\\">About</div>\\r\\n\\t<div on:click={e=>{handleClick(\\"projects\\",e.target)}} bind:this={tabs[2]} class=\\"tab\\">Projects</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.homeTab {\\n  width: fit-content;\\n  cursor: pointer;\\n}\\n\\n.navbar {\\n  display: flex;\\n  font-size: 20px;\\n  position: absolute;\\n  top: -2em;\\n  right: 0;\\n}\\n.navbar .tab {\\n  cursor: pointer;\\n  background: #1ee8b7;\\n  color: black;\\n  border-radius: 1em;\\n  padding: 1em;\\n  margin-left: 1em;\\n  transition: all 0.3s;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n}\\n.navbar .selected {\\n  background: #121212;\\n  color: #fff;\\n  border: 2px solid #1ee8b7;\\n}\\n\\n@media only screen and (max-width: 1366px) {\\n  .navbar {\\n    top: -1.5em;\\n    font-size: 18px;\\n  }\\n  .navbar .tab {\\n    padding: 0.8em 1em;\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAyBmB,QAAQ,8BAAC,CAAC,AAC3B,KAAK,CAAE,WAAW,CAClB,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,OAAO,8BAAC,CAAC,AACP,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,KAAK,CAAE,CAAC,AACV,CAAC,AACD,sBAAO,CAAC,IAAI,eAAC,CAAC,AACZ,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,CACZ,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,GAAG,CACZ,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,GAAG,CAAC,IAAI,CACpB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AACtF,CAAC,AACD,sBAAO,CAAC,SAAS,eAAC,CAAC,AACjB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,AAC3B,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC1C,OAAO,8BAAC,CAAC,AACP,GAAG,CAAE,MAAM,CACX,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,sBAAO,CAAC,IAAI,eAAC,CAAC,AACZ,OAAO,CAAE,KAAK,CAAC,GAAG,AACpB,CAAC,AACH,CAAC"}`
};
var Navbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_state;
  $$unsubscribe_state = subscribe(state, (value) => value);
  let tabs = [];
  $$result.css.add(css$7);
  $$unsubscribe_state();
  return `<div class="${"homeTab svelte-17jgy3n"}"${add_attribute("this", tabs[0], 1)}>${validate_component(Icon, "Icon").$$render($$result, { data: arrowLeft, scale: "2" }, {}, {})}</div>
<div class="${"navbar svelte-17jgy3n"}"><div class="${"tab selected svelte-17jgy3n"}"${add_attribute("this", tabs[1], 1)}>About</div>
	<div class="${"tab svelte-17jgy3n"}"${add_attribute("this", tabs[2], 1)}>Projects</div>
</div>`;
});
var css$6 = {
  code: '.container.svelte-1pi2bpn.svelte-1pi2bpn{width:100%;height:100%;align-self:center}.container.svelte-1pi2bpn .imageContainer.svelte-1pi2bpn{margin-bottom:1em;padding:0.5em;height:20em;border-radius:1em;background:#1ee8b788}.container.svelte-1pi2bpn .imageContainer img.svelte-1pi2bpn{width:100%;height:100%;border-radius:1em;object-fit:cover}.container.svelte-1pi2bpn .projectButton.svelte-1pi2bpn{cursor:pointer;margin-top:1em;width:20rem;font-size:1em;text-decoration:none;color:white;background:#1ee8b722;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);width:fit-content;padding:0.5rem 1rem;border-radius:2rem;transition:ease-out 0.3s}.container.svelte-1pi2bpn .projectButton.svelte-1pi2bpn:hover{background:#1ee8b7;color:black}.projectDetailsContainer.svelte-1pi2bpn.svelte-1pi2bpn{top:0;left:0;position:absolute;width:100%;height:100%;background:linear-gradient(to bottom right, #1ee8b766, #7a88d866);backdrop-filter:blur(10px);border-radius:2rem;text-decoration:none;padding:0.5rem;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1)}.projectDetailsContainer.svelte-1pi2bpn .projectDetails.svelte-1pi2bpn{position:relative;padding:2em 3em;color:white;width:100%;height:100%;background:#0e1117dd;border-radius:2rem;display:grid;place-items:center}.projectDetailsContainer.svelte-1pi2bpn .projectDetails img.svelte-1pi2bpn{width:60%;margin:0 auto;border-radius:1em}.projectDetailsContainer.svelte-1pi2bpn .projectDetails .closeButton.svelte-1pi2bpn{cursor:pointer;position:absolute;top:2em;right:2em}.projectDetailsContainer.svelte-1pi2bpn .projectDetails .projectContent.svelte-1pi2bpn{font-size:24px;width:80%}.projectDetailsContainer.svelte-1pi2bpn .projectDetails .projectContent h1.svelte-1pi2bpn{font-size:1.5em;margin-bottom:1em;font-family:"Montserrat"}.projectDetailsContainer.svelte-1pi2bpn .projectDetails .projectContent p.svelte-1pi2bpn{font-size:1em}',
  map: `{"version":3,"file":"projectCard.svelte","sources":["projectCard.svelte"],"sourcesContent":["<script>\\r\\n\\timport { scale } from 'svelte/transition';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { close, arrowLeft } from 'svelte-awesome/icons';\\r\\n\\texport let info;\\r\\n\\tlet showDetails = false;\\r\\n\\tconst showProjectDetails = () => {\\r\\n\\t\\tshowDetails = true;\\r\\n\\t};\\r\\n\\r\\n\\tconst hideProjectDetails = () => {\\r\\n\\t\\tshowDetails = false;\\r\\n\\t};\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"container\\">\\r\\n\\t<div class=\\"imageContainer\\">\\r\\n\\t\\t<img src={info.project_image.url} alt={info.project_name[0].text} />\\r\\n\\t</div>\\r\\n\\t<h2>{info.project_name[0].text}</h2>\\r\\n\\t<div on:click={showProjectDetails} class=\\"projectButton\\">View Project</div>\\r\\n</div>\\r\\n\\r\\n{#key showDetails}\\r\\n\\t{#if showDetails == true}\\r\\n\\t\\t<div transition:scale class=\\"projectDetailsContainer\\">\\r\\n\\t\\t\\t<div class=\\"projectDetails\\">\\r\\n\\t\\t\\t\\t<div on:click={hideProjectDetails} class=\\"closeButton\\">\\r\\n\\t\\t\\t\\t\\t<Icon data={close} scale=\\"3\\" style=\\"color: #1ee8b7\\" />\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t<img src={info.project_image.url} alt={info.project_name[0].text} />\\r\\n\\t\\t\\t\\t<div class=\\"projectContent\\">\\r\\n\\t\\t\\t\\t\\t<h1>{info.project_name[0].text}</h1>\\r\\n\\t\\t\\t\\t\\t{#each info.project_description as item}\\r\\n\\t\\t\\t\\t\\t\\t<p>{item.text}</p>\\r\\n\\t\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n{/key}\\r\\n\\r\\n<style lang=\\"scss\\">.container {\\n  width: 100%;\\n  height: 100%;\\n  align-self: center;\\n}\\n.container .imageContainer {\\n  margin-bottom: 1em;\\n  padding: 0.5em;\\n  height: 20em;\\n  border-radius: 1em;\\n  background: #1ee8b788;\\n}\\n.container .imageContainer img {\\n  width: 100%;\\n  height: 100%;\\n  border-radius: 1em;\\n  object-fit: cover;\\n}\\n.container .projectButton {\\n  cursor: pointer;\\n  margin-top: 1em;\\n  width: 20rem;\\n  font-size: 1em;\\n  text-decoration: none;\\n  color: white;\\n  background: #1ee8b722;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n  width: fit-content;\\n  padding: 0.5rem 1rem;\\n  border-radius: 2rem;\\n  transition: ease-out 0.3s;\\n}\\n.container .projectButton:hover {\\n  background: #1ee8b7;\\n  color: black;\\n}\\n\\n.projectDetailsContainer {\\n  top: 0;\\n  left: 0;\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  background: linear-gradient(to bottom right, #1ee8b766, #7a88d866);\\n  backdrop-filter: blur(10px);\\n  border-radius: 2rem;\\n  text-decoration: none;\\n  padding: 0.5rem;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n}\\n.projectDetailsContainer .projectDetails {\\n  position: relative;\\n  padding: 2em 3em;\\n  color: white;\\n  width: 100%;\\n  height: 100%;\\n  background: #0e1117dd;\\n  border-radius: 2rem;\\n  display: grid;\\n  place-items: center;\\n}\\n.projectDetailsContainer .projectDetails img {\\n  width: 60%;\\n  margin: 0 auto;\\n  border-radius: 1em;\\n}\\n.projectDetailsContainer .projectDetails .closeButton {\\n  cursor: pointer;\\n  position: absolute;\\n  top: 2em;\\n  right: 2em;\\n}\\n.projectDetailsContainer .projectDetails .projectContent {\\n  font-size: 24px;\\n  width: 80%;\\n}\\n.projectDetailsContainer .projectDetails .projectContent h1 {\\n  font-size: 1.5em;\\n  margin-bottom: 1em;\\n  font-family: \\"Montserrat\\";\\n}\\n.projectDetailsContainer .projectDetails .projectContent p {\\n  font-size: 1em;\\n}</style>\\r\\n"],"names":[],"mappings":"AA0CmB,UAAU,8BAAC,CAAC,AAC7B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,MAAM,AACpB,CAAC,AACD,yBAAU,CAAC,eAAe,eAAC,CAAC,AAC1B,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,SAAS,AACvB,CAAC,AACD,yBAAU,CAAC,eAAe,CAAC,GAAG,eAAC,CAAC,AAC9B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,KAAK,AACnB,CAAC,AACD,yBAAU,CAAC,cAAc,eAAC,CAAC,AACzB,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CACf,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,GAAG,CACd,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpF,KAAK,CAAE,WAAW,CAClB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,QAAQ,CAAC,IAAI,AAC3B,CAAC,AACD,yBAAU,CAAC,6BAAc,MAAM,AAAC,CAAC,AAC/B,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,wBAAwB,8BAAC,CAAC,AACxB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,gBAAgB,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,CAAC,SAAS,CAAC,CAClE,eAAe,CAAE,KAAK,IAAI,CAAC,CAC3B,aAAa,CAAE,IAAI,CACnB,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,MAAM,CACf,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AACtF,CAAC,AACD,uCAAwB,CAAC,eAAe,eAAC,CAAC,AACxC,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,KAAK,CAAE,KAAK,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,AACrB,CAAC,AACD,uCAAwB,CAAC,eAAe,CAAC,GAAG,eAAC,CAAC,AAC5C,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,aAAa,CAAE,GAAG,AACpB,CAAC,AACD,uCAAwB,CAAC,eAAe,CAAC,YAAY,eAAC,CAAC,AACrD,MAAM,CAAE,OAAO,CACf,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,uCAAwB,CAAC,eAAe,CAAC,eAAe,eAAC,CAAC,AACxD,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,uCAAwB,CAAC,eAAe,CAAC,eAAe,CAAC,EAAE,eAAC,CAAC,AAC3D,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,GAAG,CAClB,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,uCAAwB,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC,eAAC,CAAC,AAC1D,SAAS,CAAE,GAAG,AAChB,CAAC"}`
};
var ProjectCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { info } = $$props;
  if ($$props.info === void 0 && $$bindings.info && info !== void 0)
    $$bindings.info(info);
  $$result.css.add(css$6);
  return `<div class="${"container svelte-1pi2bpn"}"><div class="${"imageContainer svelte-1pi2bpn"}"><img${add_attribute("src", info.project_image.url, 0)}${add_attribute("alt", info.project_name[0].text, 0)} class="${"svelte-1pi2bpn"}"></div>
	<h2>${escape3(info.project_name[0].text)}</h2>
	<div class="${"projectButton svelte-1pi2bpn"}">View Project</div></div>

${``}`;
});
var projects = writable2([]);
var fetchProjects = async () => {
  const refUrl = "https://yashpunia.cdn.prismic.io/api/v2";
  const refResponse = await fetch(refUrl);
  const refResponseJson = await refResponse.json();
  const masterRef = refResponseJson.refs[0].ref;
  const docUrl = "https://yashpunia.cdn.prismic.io/api/v2/documents/search?ref=" + masterRef;
  const docResponse = await fetch(docUrl);
  const docResponseJson = await docResponse.json();
  let projectsFetched = [];
  docResponseJson.results.map((element, index2) => {
    if (element.type === "projects")
      projectsFetched.push(element);
  });
  projects.set(projectsFetched);
};
fetchProjects();
var css$5 = {
  code: '.project-container.svelte-1y6g321.svelte-1y6g321{width:70vw}.project-container.svelte-1y6g321 h1.svelte-1y6g321{color:white;text-align:center;font-family:"Montserrat"}.project-container.svelte-1y6g321 .project-grid.svelte-1y6g321{display:grid;margin-top:5em;place-items:center;grid-template-columns:repeat(auto-fit, minmax(20em, 1fr));gap:5em}@media only screen and (max-width: 512px){.project-container.svelte-1y6g321 .project-grid.svelte-1y6g321{grid-template-columns:repeat(auto-fit, minmax(15em, 1fr))}}',
  map: `{"version":3,"file":"projects.svelte","sources":["projects.svelte"],"sourcesContent":["<script>\\r\\n\\timport ProjectCard from '$lib/components/projectCard.svelte';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport {spinner} from 'svelte-awesome/icons';\\r\\n\\timport { projects } from '$lib/stores/projectStores';\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"project-container\\">\\r\\n\\t<h1>See my work</h1>\\r\\n\\t<div class=\\"project-grid\\">\\r\\n\\t\\t{#each $projects as project}\\r\\n\\t\\t\\t<ProjectCard info={project.data} />\\r\\n\\t\\t{:else}\\r\\n\\t\\t\\t<Icon data={spinner} pulse/>\\r\\n\\t\\t{/each}\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.project-container {\\n  width: 70vw;\\n}\\n.project-container h1 {\\n  color: white;\\n  text-align: center;\\n  font-family: \\"Montserrat\\";\\n}\\n.project-container .project-grid {\\n  display: grid;\\n  margin-top: 5em;\\n  place-items: center;\\n  grid-template-columns: repeat(auto-fit, minmax(20em, 1fr));\\n  gap: 5em;\\n}\\n\\n@media only screen and (max-width: 512px) {\\n  .project-container .project-grid {\\n    grid-template-columns: repeat(auto-fit, minmax(15em, 1fr));\\n  }\\n}</style>\\r\\n"],"names":[],"mappings":"AAkBmB,kBAAkB,8BAAC,CAAC,AACrC,KAAK,CAAE,IAAI,AACb,CAAC,AACD,iCAAkB,CAAC,EAAE,eAAC,CAAC,AACrB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,iCAAkB,CAAC,aAAa,eAAC,CAAC,AAChC,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,MAAM,CACnB,qBAAqB,CAAE,OAAO,QAAQ,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAC1D,GAAG,CAAE,GAAG,AACV,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,iCAAkB,CAAC,aAAa,eAAC,CAAC,AAChC,qBAAqB,CAAE,OAAO,QAAQ,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,AAC5D,CAAC,AACH,CAAC"}`
};
var Projects = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $projects, $$unsubscribe_projects;
  $$unsubscribe_projects = subscribe(projects, (value) => $projects = value);
  $$result.css.add(css$5);
  $$unsubscribe_projects();
  return `<div class="${"project-container svelte-1y6g321"}"><h1 class="${"svelte-1y6g321"}">See my work</h1>
	<div class="${"project-grid svelte-1y6g321"}">${$projects.length ? each($projects, (project) => `${validate_component(ProjectCard, "ProjectCard").$$render($$result, { info: project.data }, {}, {})}`) : `${validate_component(Icon, "Icon").$$render($$result, { data: spinner, pulse: true }, {}, {})}`}</div>
</div>`;
});
var css$4 = {
  code: ".container.svelte-b3qm9o{position:relative;transition:all 0.3s;padding:2rem 3rem;color:#fff;background:#0e1117dd;width:100%;height:100%;border-radius:2rem}@media only screen and (max-width: 512px){.container.svelte-b3qm9o{padding:1rem}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n\\timport { state } from '$lib/stores/stateStores';\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\n\\timport About from '$lib/components/about.svelte';\\n\\timport Home from '$lib/components/home.svelte';\\n\\timport Navbar from '$lib/components/navbar.svelte';\\n\\timport Projects from '$lib/components/projects.svelte';\\n\\n<\/script>\\n\\n<svelte:head>\\n\\t<title>Yash Punia</title>\\n</svelte:head>\\n\\n<div class=\\"grid\\">\\n\\t<div class=\\"glass-element\\">\\n\\t\\t<div class=\\"container\\">\\n\\t\\t\\t\\t{#if $state != 'home'}\\n\\t\\t\\t\\t\\t<Navbar />\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t{#if $state == 'home'}\\n\\t\\t\\t\\t\\t<Home />\\n\\t\\t\\t\\t{:else if $state == 'more'}\\n\\t\\t\\t\\t\\t<About />\\n\\t\\t\\t\\t{:else if $state == 'projects'}\\n\\t\\t\\t\\t\\t<Projects />\\n\\t\\t\\t\\t{/if}\\n\\t\\t</div>\\n\\t</div>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  position: relative;\\n  transition: all 0.3s;\\n  padding: 2rem 3rem;\\n  color: #fff;\\n  background: #0e1117dd;\\n  width: 100%;\\n  height: 100%;\\n  border-radius: 2rem;\\n}\\n\\n@media only screen and (max-width: 512px) {\\n  .container {\\n    padding: 1rem;\\n  }\\n}</style>\\n"],"names":[],"mappings":"AA+BmB,UAAU,cAAC,CAAC,AAC7B,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,GAAG,CAAC,IAAI,CACpB,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,SAAS,CACrB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzC,UAAU,cAAC,CAAC,AACV,OAAO,CAAE,IAAI,AACf,CAAC,AACH,CAAC"}`
};
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $state, $$unsubscribe_state;
  $$unsubscribe_state = subscribe(state, (value) => $state = value);
  $$result.css.add(css$4);
  $$unsubscribe_state();
  return `${$$result.head += `${$$result.title = `<title>Yash Punia</title>`, ""}`, ""}

<div class="${"grid"}"><div class="${"glass-element"}"><div class="${"container svelte-b3qm9o"}">${$state != "home" ? `${validate_component(Navbar, "Navbar").$$render($$result, {}, {}, {})}` : ``}
				${$state == "home" ? `${validate_component(Home, "Home").$$render($$result, {}, {}, {})}` : `${$state == "more" ? `${validate_component(About$1, "About").$$render($$result, {}, {}, {})}` : `${$state == "projects" ? `${validate_component(Projects, "Projects").$$render($$result, {}, {}, {})}` : ``}`}`}</div></div>
</div>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var css$3 = {
  code: '.container.svelte-1fwpo8f.svelte-1fwpo8f{padding:2rem 3rem;color:#fff;background:#0e1117dd;width:80vw;height:100%;border-radius:2rem;display:grid;gap:1em;grid-template-columns:1fr 2fr;font-size:24px}.container.svelte-1fwpo8f img.svelte-1fwpo8f{width:20rem;height:30rem;object-fit:cover;border-radius:2rem;border:0.2rem solid #1ee8b788;margin:4em auto}.container.svelte-1fwpo8f .content.svelte-1fwpo8f{height:fit-content}.container.svelte-1fwpo8f .content h1.svelte-1fwpo8f{font-family:"Montserrat"}.container.svelte-1fwpo8f .content p.svelte-1fwpo8f{font-weight:300;margin-top:3rem;text-align:justify;font-size:0.8em}.container.svelte-1fwpo8f .content h3.svelte-1fwpo8f{margin:2em 0 1em 0}.container.svelte-1fwpo8f .content .skills.svelte-1fwpo8f{display:flex;flex-wrap:wrap}.container.svelte-1fwpo8f .content .skills .skill-item.svelte-1fwpo8f{width:fit-content;margin:0.3em;background:#1ee8b788;border-radius:1em;font-size:0.8em;padding:0.2em 0.5em}.container.svelte-1fwpo8f .content .tabButtons.svelte-1fwpo8f{display:flex}.container.svelte-1fwpo8f .content .tabButtons .educationButton.svelte-1fwpo8f,.container.svelte-1fwpo8f .content .tabButtons .experienceButton.svelte-1fwpo8f{position:relative;margin:1em 1em;cursor:pointer;transition:all 0.3s}.container.svelte-1fwpo8f .content .tabButtons .educationButton.svelte-1fwpo8f:hover,.container.svelte-1fwpo8f .content .tabButtons .experienceButton.svelte-1fwpo8f:hover{color:#c362f6}.container.svelte-1fwpo8f .content .buttons.svelte-1fwpo8f{margin-top:2em}.container.svelte-1fwpo8f .content .buttons a.svelte-1fwpo8f{width:20rem;font-size:0.8em;text-decoration:none;color:white;background:#1ee8b722;box-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);width:fit-content;padding:0.5rem 1rem;border-radius:2rem;transition:ease-out 0.3s}.container.svelte-1fwpo8f .content .buttons a.svelte-1fwpo8f:hover{background:#1ee8b7;color:black}.selected.svelte-1fwpo8f.svelte-1fwpo8f{color:#c362f6}',
  map: `{"version":3,"file":"about.svelte","sources":["about.svelte"],"sourcesContent":["<script>\\r\\n\\timport Education from '$lib/components/education.svelte';\\r\\n\\timport Experience from '$lib/components/experience.svelte';\\r\\n\\tconst profileUrl = 'Profile3.jpg';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport {arrowLeft} from 'svelte-awesome/icons';\\r\\n\\r\\n\\tconst skillList = [\\r\\n\\t\\t'C#',\\r\\n\\t\\t'Unity3D',\\r\\n\\t\\t'WebXR',\\r\\n\\t\\t'ARFoundation',\\r\\n\\t\\t'AR Core',\\r\\n\\t\\t'Web Dev',\\r\\n\\t\\t'C++',\\r\\n\\t\\t'Python',\\r\\n\\t\\t'Blender',\\r\\n\\t\\t'Photoshop'\\r\\n\\t];\\r\\n\\r\\n\\tlet tab = 'education';\\r\\n\\tlet educationTab;\\r\\n\\tlet experienceTab;\\r\\n\\r\\n\\tconst toggleTab = (tabName) => {\\r\\n\\t\\tconsole.log(tab);\\r\\n\\t\\ttab = tabName;\\r\\n\\t\\tif (tab == 'experience') {\\r\\n\\t\\t\\teducationTab.classList.remove('selected');\\r\\n\\t\\t\\texperienceTab.classList.add('selected');\\r\\n\\t\\t} else {\\r\\n\\t\\t\\teducationTab.classList.add('selected');\\r\\n\\t\\t\\texperienceTab.classList.remove('selected');\\r\\n\\t\\t}\\r\\n\\t};\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"grid\\">\\r\\n\\t<div class=\\"glass-element\\">\\r\\n\\t\\t<div class=\\"container\\">\\r\\n\\t\\t\\t<a href=\\"/\\" style=\\"position: absolute; top: 2em; left: 2em; color: #1ee8b7\\">\\r\\n\\t\\t\\t\\t<Icon\\r\\n\\t\\t\\t\\t\\tdata={arrowLeft}\\r\\n\\t\\t\\t\\t\\tscale=\\"3\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t</a>\\r\\n\\t\\t\\t<img src={profileUrl} alt=\\"profile=pic\\" />\\r\\n\\t\\t\\t<div class=\\"content\\">\\r\\n\\t\\t\\t\\t<h1>About Me</h1>\\r\\n\\t\\t\\t\\t<p>\\r\\n\\t\\t\\t\\t\\tA Game Dev enthusiast specializing in Augmented Reality and Virtual Reality for the next\\r\\n\\t\\t\\t\\t\\tgen games and apps. Also fluent in various web technologies and I fiddle with WebXR to\\r\\n\\t\\t\\t\\t\\tshowcase XR to everyone! I also play Ukulele and Piano sometimes :D\\r\\n\\t\\t\\t\\t</p>\\r\\n\\t\\t\\t\\t<h3>Skills</h3>\\r\\n\\t\\t\\t\\t<div class=\\"skills\\">\\r\\n\\t\\t\\t\\t\\t{#each skillList as skill}\\r\\n\\t\\t\\t\\t\\t\\t<div class=\\"skill-item\\">{skill}</div>\\r\\n\\t\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t<div class=\\"tabButtons\\">\\r\\n\\t\\t\\t\\t\\t<div\\r\\n\\t\\t\\t\\t\\t\\tbind:this={educationTab}\\r\\n\\t\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\t\\ttoggleTab('education');\\r\\n\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"educationButton selected\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\tEducation\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t<div\\r\\n\\t\\t\\t\\t\\t\\tbind:this={experienceTab}\\r\\n\\t\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\t\\ttoggleTab('experience');\\r\\n\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"experienceButton\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\tExperience\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t{#key tab}\\r\\n\\t\\t\\t\\t\\t{#if tab == 'education'}\\r\\n\\t\\t\\t\\t\\t\\t<Education />\\r\\n\\t\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t\\t<Experience />\\r\\n\\t\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t\\t{/key}\\r\\n\\t\\t\\t\\t<div class=\\"buttons\\">\\r\\n\\t\\t\\t\\t\\t<a\\r\\n\\t\\t\\t\\t\\t\\ttarget=\\"_blank\\"\\r\\n\\t\\t\\t\\t\\t\\thref=\\"https://drive.google.com/file/d/1ForiKFcQ-2Dk3WuZjlXMNERoGYFo5eLG/view?usp=sharing\\"\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"resumeButton\\">Download Resume</a\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<a href=\\"/contact\\">Contact Me</a>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.container {\\n  padding: 2rem 3rem;\\n  color: #fff;\\n  background: #0e1117dd;\\n  width: 80vw;\\n  height: 100%;\\n  border-radius: 2rem;\\n  display: grid;\\n  gap: 1em;\\n  grid-template-columns: 1fr 2fr;\\n  font-size: 24px;\\n}\\n.container img {\\n  width: 20rem;\\n  height: 30rem;\\n  object-fit: cover;\\n  border-radius: 2rem;\\n  border: 0.2rem solid #1ee8b788;\\n  margin: 4em auto;\\n}\\n.container .content {\\n  height: fit-content;\\n}\\n.container .content h1 {\\n  font-family: \\"Montserrat\\";\\n}\\n.container .content p {\\n  font-weight: 300;\\n  margin-top: 3rem;\\n  text-align: justify;\\n  font-size: 0.8em;\\n}\\n.container .content h3 {\\n  margin: 2em 0 1em 0;\\n}\\n.container .content .skills {\\n  display: flex;\\n  flex-wrap: wrap;\\n}\\n.container .content .skills .skill-item {\\n  width: fit-content;\\n  margin: 0.3em;\\n  background: #1ee8b788;\\n  border-radius: 1em;\\n  font-size: 0.8em;\\n  padding: 0.2em 0.5em;\\n}\\n.container .content .tabButtons {\\n  display: flex;\\n}\\n.container .content .tabButtons .educationButton,\\n.container .content .tabButtons .experienceButton {\\n  position: relative;\\n  margin: 1em 1em;\\n  cursor: pointer;\\n  transition: all 0.3s;\\n}\\n.container .content .tabButtons .educationButton:hover,\\n.container .content .tabButtons .experienceButton:hover {\\n  color: #c362f6;\\n}\\n.container .content .buttons {\\n  margin-top: 2em;\\n}\\n.container .content .buttons a {\\n  width: 20rem;\\n  font-size: 0.8em;\\n  text-decoration: none;\\n  color: white;\\n  background: #1ee8b722;\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);\\n  width: fit-content;\\n  padding: 0.5rem 1rem;\\n  border-radius: 2rem;\\n  transition: ease-out 0.3s;\\n}\\n.container .content .buttons a:hover {\\n  background: #1ee8b7;\\n  color: black;\\n}\\n\\n.selected {\\n  color: #c362f6;\\n}</style>\\r\\n"],"names":[],"mappings":"AAoGmB,UAAU,8BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,SAAS,CACrB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,GAAG,CAAE,GAAG,CACR,qBAAqB,CAAE,GAAG,CAAC,GAAG,CAC9B,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,yBAAU,CAAC,GAAG,eAAC,CAAC,AACd,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAC9B,MAAM,CAAE,GAAG,CAAC,IAAI,AAClB,CAAC,AACD,yBAAU,CAAC,QAAQ,eAAC,CAAC,AACnB,MAAM,CAAE,WAAW,AACrB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,EAAE,eAAC,CAAC,AACtB,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,CAAC,eAAC,CAAC,AACrB,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,KAAK,AAClB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,EAAE,eAAC,CAAC,AACtB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,AACrB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,OAAO,eAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,eAAC,CAAC,AACvC,KAAK,CAAE,WAAW,CAClB,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,GAAG,CAClB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,KAAK,CAAC,KAAK,AACtB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,WAAW,eAAC,CAAC,AAC/B,OAAO,CAAE,IAAI,AACf,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,+BAAgB,CAChD,yBAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,iBAAiB,eAAC,CAAC,AACjD,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,GAAG,CAAC,GAAG,CACf,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,IAAI,AACtB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,+BAAgB,MAAM,CACtD,yBAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,gCAAiB,MAAM,AAAC,CAAC,AACvD,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,QAAQ,eAAC,CAAC,AAC5B,UAAU,CAAE,GAAG,AACjB,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,eAAC,CAAC,AAC9B,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,CAChB,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,UAAU,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpF,KAAK,CAAE,WAAW,CAClB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,QAAQ,CAAC,IAAI,AAC3B,CAAC,AACD,yBAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAC,MAAM,AAAC,CAAC,AACpC,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,SAAS,8BAAC,CAAC,AACT,KAAK,CAAE,OAAO,AAChB,CAAC"}`
};
var profileUrl = "Profile3.jpg";
var About = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const skillList = [
    "C#",
    "Unity3D",
    "WebXR",
    "ARFoundation",
    "AR Core",
    "Web Dev",
    "C++",
    "Python",
    "Blender",
    "Photoshop"
  ];
  let educationTab;
  let experienceTab;
  $$result.css.add(css$3);
  return `<div class="${"grid"}"><div class="${"glass-element"}"><div class="${"container svelte-1fwpo8f"}"><a href="${"/"}" style="${"position: absolute; top: 2em; left: 2em; color: #1ee8b7"}" class="${"svelte-1fwpo8f"}">${validate_component(Icon, "Icon").$$render($$result, { data: arrowLeft, scale: "3" }, {}, {})}</a>
			<img${add_attribute("src", profileUrl, 0)} alt="${"profile=pic"}" class="${"svelte-1fwpo8f"}">
			<div class="${"content svelte-1fwpo8f"}"><h1 class="${"svelte-1fwpo8f"}">About Me</h1>
				<p class="${"svelte-1fwpo8f"}">A Game Dev enthusiast specializing in Augmented Reality and Virtual Reality for the next
					gen games and apps. Also fluent in various web technologies and I fiddle with WebXR to
					showcase XR to everyone! I also play Ukulele and Piano sometimes :D
				</p>
				<h3 class="${"svelte-1fwpo8f"}">Skills</h3>
				<div class="${"skills svelte-1fwpo8f"}">${each(skillList, (skill) => `<div class="${"skill-item svelte-1fwpo8f"}">${escape3(skill)}</div>`)}</div>
				<div class="${"tabButtons svelte-1fwpo8f"}"><div class="${"educationButton selected svelte-1fwpo8f"}"${add_attribute("this", educationTab, 1)}>Education
					</div>
					<div class="${"experienceButton svelte-1fwpo8f"}"${add_attribute("this", experienceTab, 1)}>Experience
					</div></div>
				${`${validate_component(Education, "Education").$$render($$result, {}, {}, {})}`}
				<div class="${"buttons svelte-1fwpo8f"}"><a target="${"_blank"}" href="${"https://drive.google.com/file/d/1ForiKFcQ-2Dk3WuZjlXMNERoGYFo5eLG/view?usp=sharing"}" class="${"resumeButton svelte-1fwpo8f"}">Download Resume</a>
					<a href="${"/contact"}" class="${"svelte-1fwpo8f"}">Contact Me</a></div></div></div></div>
</div>`;
});
var about = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": About
});
var css$2 = {
  code: '.container.svelte-1jnlsb5.svelte-1jnlsb5{height:100%;padding:2em 3em;color:white;background:#0e1117dd;border-radius:2rem}.container.svelte-1jnlsb5 h1.svelte-1jnlsb5{color:white;text-align:center;font-family:"Montserrat"}.container.svelte-1jnlsb5 .blog-grid.svelte-1jnlsb5{display:grid;margin-top:5em;place-items:center;grid-template-columns:repeat(auto-fit, minmax(30em, 1fr))}.container.svelte-1jnlsb5 .blog-grid a.svelte-1jnlsb5{margin:1em 0;color:white;text-decoration:none}.container.svelte-1jnlsb5 .blog-grid a h1.svelte-1jnlsb5{text-align:left;font-size:1.5em}.container.svelte-1jnlsb5 .blog-grid a .blogInfo.svelte-1jnlsb5{display:flex;align-items:center}.container.svelte-1jnlsb5 .blog-grid a .blogInfo .dateBlog.svelte-1jnlsb5{display:flex;align-items:center;margin:1em}.container.svelte-1jnlsb5 .blog-grid a .blogInfo .dateBlog span.svelte-1jnlsb5{margin-left:1em}',
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\r\\n\\texport async function load() {\\r\\n\\t\\t//get latest master ref\\r\\n\\t\\tconst refUrl = 'https://yashpunia.cdn.prismic.io/api/v2';\\r\\n\\t\\tconst refResponse = await fetch(refUrl);\\r\\n\\t\\tconst refResponseJson = await refResponse.json();\\r\\n\\t\\tconst masterRef = refResponseJson.refs[0].ref;\\r\\n\\r\\n\\t\\t//get the blogs\\r\\n\\t\\tconst docUrl = 'https://yashpunia.cdn.prismic.io/api/v2/documents/search?ref=' + masterRef;\\r\\n\\t\\tconst docResponse = await fetch(docUrl);\\r\\n\\t\\tconst docResponseJson = await docResponse.json();\\r\\n\\r\\n\\t\\tconst blogList = [];\\r\\n\\r\\n\\t\\tdocResponseJson.results.map((element, index) => {\\r\\n\\t\\t\\tif (element.type === 'blog_posts') blogList.push(element);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\treturn { props: { blogList } };\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<script>\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { calendar, arrowLeft } from 'svelte-awesome/icons';\\r\\n\\r\\n\\texport let blogList;\\r\\n\\r\\n\\tconst getDate = datetime => {\\r\\n\\t\\tconst date = datetime.split('T')[0];\\r\\n\\t\\tconst year = date.split('-')[0];\\r\\n\\t\\tconst day = date.split('-')[2];\\r\\n\\t\\tconst month = date.split('-')[1];\\r\\n\\t\\treturn (day + '/' + month + '/' + year);\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<svelte:head>\\r\\n\\t<title>Yash Punia</title>\\r\\n</svelte:head>\\r\\n\\r\\n<div class=\\"grid\\">\\r\\n\\t<div class=\\"glass-element\\">\\r\\n\\t\\t<div class=\\"container\\">\\r\\n\\t\\t\\t<a href=\\"/\\" style=\\"position: absolute; top: 2em; left: 2em; color: #1ee8b7\\">\\r\\n\\t\\t\\t\\t<Icon\\r\\n\\t\\t\\t\\t\\tdata={arrowLeft}\\r\\n\\t\\t\\t\\t\\tscale=\\"3\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t</a>\\r\\n\\t\\t\\t<h1>My Blogs</h1>\\r\\n\\t\\t\\t<div class=\\"blog-grid\\">\\r\\n\\t\\t\\t\\t{#each blogList as blog}\\r\\n\\t\\t\\t\\t\\t<a href={\`/blogs/\${blog.id}\`} >\\r\\n\\t\\t\\t\\t\\t\\t<h1>{blog.data.title[0].text}</h1>\\r\\n\\t\\t\\t\\t\\t\\t<div class='blogInfo'>\\r\\n\\t\\t\\t\\t\\t\\t\\t<div class='dateBlog'>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<Icon data={calendar} scale=2 style=\\"color: grey\\"/>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<span>{getDate(blog.last_publication_date)}</span>\\r\\n\\t\\t\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t\\t</div>\\t\\r\\n\\t\\t\\t\\t\\t</a>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.container {\\n  height: 100%;\\n  padding: 2em 3em;\\n  color: white;\\n  background: #0e1117dd;\\n  border-radius: 2rem;\\n}\\n.container h1 {\\n  color: white;\\n  text-align: center;\\n  font-family: \\"Montserrat\\";\\n}\\n.container .blog-grid {\\n  display: grid;\\n  margin-top: 5em;\\n  place-items: center;\\n  grid-template-columns: repeat(auto-fit, minmax(30em, 1fr));\\n}\\n.container .blog-grid a {\\n  margin: 1em 0;\\n  color: white;\\n  text-decoration: none;\\n}\\n.container .blog-grid a h1 {\\n  text-align: left;\\n  font-size: 1.5em;\\n}\\n.container .blog-grid a .blogInfo {\\n  display: flex;\\n  align-items: center;\\n}\\n.container .blog-grid a .blogInfo .dateBlog {\\n  display: flex;\\n  align-items: center;\\n  margin: 1em;\\n}\\n.container .blog-grid a .blogInfo .dateBlog span {\\n  margin-left: 1em;\\n}</style>\\r\\n"],"names":[],"mappings":"AAqEmB,UAAU,8BAAC,CAAC,AAC7B,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,IAAI,AACrB,CAAC,AACD,yBAAU,CAAC,EAAE,eAAC,CAAC,AACb,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,yBAAU,CAAC,UAAU,eAAC,CAAC,AACrB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,MAAM,CACnB,qBAAqB,CAAE,OAAO,QAAQ,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,AAC5D,CAAC,AACD,yBAAU,CAAC,UAAU,CAAC,CAAC,eAAC,CAAC,AACvB,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,KAAK,CAAE,KAAK,CACZ,eAAe,CAAE,IAAI,AACvB,CAAC,AACD,yBAAU,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,eAAC,CAAC,AAC1B,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,KAAK,AAClB,CAAC,AACD,yBAAU,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,eAAC,CAAC,AACjC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,AACrB,CAAC,AACD,yBAAU,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,eAAC,CAAC,AAC3C,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,GAAG,AACb,CAAC,AACD,yBAAU,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,eAAC,CAAC,AAChD,WAAW,CAAE,GAAG,AAClB,CAAC"}`
};
async function load$1() {
  const refUrl = "https://yashpunia.cdn.prismic.io/api/v2";
  const refResponse = await fetch(refUrl);
  const refResponseJson = await refResponse.json();
  const masterRef = refResponseJson.refs[0].ref;
  const docUrl = "https://yashpunia.cdn.prismic.io/api/v2/documents/search?ref=" + masterRef;
  const docResponse = await fetch(docUrl);
  const docResponseJson = await docResponse.json();
  const blogList = [];
  docResponseJson.results.map((element, index2) => {
    if (element.type === "blog_posts")
      blogList.push(element);
  });
  return { props: { blogList } };
}
var Blogs = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { blogList } = $$props;
  const getDate = (datetime) => {
    const date = datetime.split("T")[0];
    const year = date.split("-")[0];
    const day = date.split("-")[2];
    const month = date.split("-")[1];
    return day + "/" + month + "/" + year;
  };
  if ($$props.blogList === void 0 && $$bindings.blogList && blogList !== void 0)
    $$bindings.blogList(blogList);
  $$result.css.add(css$2);
  return `${$$result.head += `${$$result.title = `<title>Yash Punia</title>`, ""}`, ""}

<div class="${"grid"}"><div class="${"glass-element"}"><div class="${"container svelte-1jnlsb5"}"><a href="${"/"}" style="${"position: absolute; top: 2em; left: 2em; color: #1ee8b7"}" class="${"svelte-1jnlsb5"}">${validate_component(Icon, "Icon").$$render($$result, { data: arrowLeft, scale: "3" }, {}, {})}</a>
			<h1 class="${"svelte-1jnlsb5"}">My Blogs</h1>
			<div class="${"blog-grid svelte-1jnlsb5"}">${each(blogList, (blog) => `<a${add_attribute("href", `/blogs/${blog.id}`, 0)} class="${"svelte-1jnlsb5"}"><h1 class="${"svelte-1jnlsb5"}">${escape3(blog.data.title[0].text)}</h1>
						<div class="${"blogInfo svelte-1jnlsb5"}"><div class="${"dateBlog svelte-1jnlsb5"}">${validate_component(Icon, "Icon").$$render($$result, {
    data: calendar,
    scale: "2",
    style: "color: grey"
  }, {}, {})}
								<span class="${"svelte-1jnlsb5"}">${escape3(getDate(blog.last_publication_date))}</span>
							</div></div>	
					</a>`)}</div></div></div>
</div>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Blogs,
  load: load$1
});
var css$1 = {
  code: '.container.svelte-1re4wk7.svelte-1re4wk7{width:80vw;height:100%;padding:2em 3em;color:white;background:#0e1117dd;border-radius:2rem;display:flex;flex-direction:column;align-items:center}.container.svelte-1re4wk7 h1.svelte-1re4wk7{color:white;text-align:center;font-family:"Montserrat"}.container.svelte-1re4wk7 img.svelte-1re4wk7{margin:2em 0;width:10em;height:10em}.container.svelte-1re4wk7 p.svelte-1re4wk7{font-size:1.2em;margin:0.5em 0}.container.svelte-1re4wk7 h3.svelte-1re4wk7{font-size:1.5em;margin:1em 0}',
  map: `{"version":3,"file":"[id].svelte","sources":["[id].svelte"],"sourcesContent":["<script context=\\"module\\">\\r\\n\\texport async function load({ page }) {\\r\\n\\t\\tconsole.log(page.params.id);\\r\\n\\t\\t//get latest master ref\\r\\n\\t\\tconst refUrl = 'https://yashpunia.cdn.prismic.io/api/v2';\\r\\n\\t\\tconst refResponse = await fetch(refUrl);\\r\\n\\t\\tconst refResponseJson = await refResponse.json();\\r\\n\\t\\tconst masterRef = refResponseJson.refs[0].ref;\\r\\n\\r\\n\\t\\t//get the blogs\\r\\n\\t\\tconst docUrl = \`https://yashpunia.cdn.prismic.io/api/v2/documents/search?ref=\${masterRef}&q=[[at(document.id,\\"\${page.params.id}\\")]]\`;\\r\\n\\t\\tconst docResponse = await fetch(docUrl);\\r\\n\\t\\tconst docResponseJson = await docResponse.json();\\r\\n\\r\\n\\t\\tconst blog = docResponseJson.results[0];\\r\\n\\r\\n\\t\\treturn { props: { blog } };\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<script>\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { arrowLeft } from 'svelte-awesome/icons';\\r\\n\\r\\n\\texport let blog;\\r\\n\\tconsole.log(blog);\\r\\n\\r\\n\\tconst getDate = (datetime) => {\\r\\n\\t\\tconst date = datetime.split('T')[0];\\r\\n\\t\\tconst year = date.split('-')[0];\\r\\n\\t\\tconst day = date.split('-')[2];\\r\\n\\t\\tconst month = date.split('-')[1];\\r\\n\\t\\treturn day + '/' + month + '/' + year;\\r\\n\\t};\\r\\n<\/script>\\r\\n\\r\\n<svelte:head>\\r\\n\\t<title>Yash Punia</title>\\r\\n</svelte:head>\\r\\n\\r\\n<div class=\\"grid\\">\\r\\n\\t<div class=\\"glass-element\\">\\r\\n\\t\\t<div class=\\"container\\">\\r\\n\\t\\t\\t<a href=\\"/blogs\\" style=\\"position: absolute; top: 2em; left: 2em; color: #1ee8b7\\">\\r\\n\\t\\t\\t\\t<Icon\\r\\n\\t\\t\\t\\t\\tdata={arrowLeft}\\r\\n\\t\\t\\t\\t\\tscale=\\"3\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t</a>\\r\\n\\t\\t\\t<h1>{blog.data.title[0].text}</h1>\\r\\n\\t\\t\\t<img src={blog.data.image.url} alt=\\"blog-post\\" />\\r\\n\\t\\t\\t<div class='blogBody'>\\r\\n\\t\\t\\t\\t{#each blog.data.body as item}\\r\\n\\t\\t\\t\\t\\t{#if item.type == 'paragraph'}\\r\\n\\t\\t\\t\\t\\t\\t<p>{item.text}</p>\\r\\n\\t\\t\\t\\t\\t{:else if item.type == 'heading3'}\\r\\n\\t\\t\\t\\t\\t\\t<h3>{item.text}</h3>\\r\\n\\t\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.container {\\n  width: 80vw;\\n  height: 100%;\\n  padding: 2em 3em;\\n  color: white;\\n  background: #0e1117dd;\\n  border-radius: 2rem;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n}\\n.container h1 {\\n  color: white;\\n  text-align: center;\\n  font-family: \\"Montserrat\\";\\n}\\n.container img {\\n  margin: 2em 0;\\n  width: 10em;\\n  height: 10em;\\n}\\n.container p {\\n  font-size: 1.2em;\\n  margin: 0.5em 0;\\n}\\n.container h3 {\\n  font-size: 1.5em;\\n  margin: 1em 0;\\n}</style>\\r\\n"],"names":[],"mappings":"AAgEmB,UAAU,8BAAC,CAAC,AAC7B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,SAAS,CACrB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,AACrB,CAAC,AACD,yBAAU,CAAC,EAAE,eAAC,CAAC,AACb,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,YAAY,AAC3B,CAAC,AACD,yBAAU,CAAC,GAAG,eAAC,CAAC,AACd,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACd,CAAC,AACD,yBAAU,CAAC,CAAC,eAAC,CAAC,AACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,KAAK,CAAC,CAAC,AACjB,CAAC,AACD,yBAAU,CAAC,EAAE,eAAC,CAAC,AACb,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,GAAG,CAAC,CAAC,AACf,CAAC"}`
};
async function load({ page }) {
  console.log(page.params.id);
  const refUrl = "https://yashpunia.cdn.prismic.io/api/v2";
  const refResponse = await fetch(refUrl);
  const refResponseJson = await refResponse.json();
  const masterRef = refResponseJson.refs[0].ref;
  const docUrl = `https://yashpunia.cdn.prismic.io/api/v2/documents/search?ref=${masterRef}&q=[[at(document.id,"${page.params.id}")]]`;
  const docResponse = await fetch(docUrl);
  const docResponseJson = await docResponse.json();
  const blog = docResponseJson.results[0];
  return { props: { blog } };
}
var U5Bidu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { blog } = $$props;
  console.log(blog);
  if ($$props.blog === void 0 && $$bindings.blog && blog !== void 0)
    $$bindings.blog(blog);
  $$result.css.add(css$1);
  return `${$$result.head += `${$$result.title = `<title>Yash Punia</title>`, ""}`, ""}

<div class="${"grid"}"><div class="${"glass-element"}"><div class="${"container svelte-1re4wk7"}"><a href="${"/blogs"}" style="${"position: absolute; top: 2em; left: 2em; color: #1ee8b7"}">${validate_component(Icon, "Icon").$$render($$result, { data: arrowLeft, scale: "3" }, {}, {})}</a>
			<h1 class="${"svelte-1re4wk7"}">${escape3(blog.data.title[0].text)}</h1>
			<img${add_attribute("src", blog.data.image.url, 0)} alt="${"blog-post"}" class="${"svelte-1re4wk7"}">
			<div class="${"blogBody"}">${each(blog.data.body, (item) => `${item.type == "paragraph" ? `<p class="${"svelte-1re4wk7"}">${escape3(item.text)}</p>` : `${item.type == "heading3" ? `<h3 class="${"svelte-1re4wk7"}">${escape3(item.text)}</h3>` : ``}`}`)}</div></div></div>
</div>`;
});
var _id_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bidu5D,
  load
});
var App = class {
  constructor() {
    this.init();
    this.generateBalls();
    this.setupXR();
    window.addEventListener("resize", this.onWindowResize.bind(this), false);
  }
  startAR() {
    navigator.xr.requestSession("immersive-ar").then(this.onSessionStarted.bind(this));
    document.body.appendChild(this.renderer.domElement);
  }
  generateBalls() {
    z;
    const gradientTexture = new THREE.TextureLoader().load("gradient.png");
    for (let i = 0; i < 10; i++) {
      const ball = new THREE.Mesh(new THREE.SphereBufferGeometry(Math.random() * 0.2, 20, 20), new THREE.MeshBasicMaterial({ map: gradientTexture }));
      const x = Math.random() * 4 - 2;
      const y = Math.random() + 0.5;
      const z2 = -(Math.random() * 4) - 1;
      ball.position.set(x, y, z2);
      this.scene.add(ball);
    }
  }
  async onSessionStarted(session) {
    this.renderer.xr.setReferenceSpaceType("local");
    await this.renderer.xr.setSession(session);
    this.currentSession = session;
  }
  setupXR() {
    this.currentSession = null;
    this.renderer.xr.enabled = true;
    const controller = this.renderer.xr.getController(0);
    controller.addEventListener("select", () => {
      alert("tapped!");
    });
    this.scene.add(controller);
    this.controller = controller;
  }
  init() {
    this.scene = new THREE.Scene();
    const ambientLight = new THREE.AmbientLight(16777215, 0.6);
    this.scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(16777215, 0.6);
    dirLight.position.set(0, 0, 200);
    this.scene.add(dirLight);
    const aspectRatio = window.innerWidth / window.innerHeight;
    this.camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 1e3);
    this.camera.position.set(0, 0, 0);
    this.camera.lookAt(0, 0, 0);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setAnimationLoop(this.animate.bind(this));
  }
  animate() {
    this.renderer.render(this.scene, this.camera);
  }
  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  createText(message, height) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    let metrics = null;
    const textHeight = 100;
    context.font = "normal " + textHeight + "px Arial";
    metrics = context.measureText(message);
    const textWidth = metrics.width;
    canvas.width = textWidth;
    canvas.height = textHeight;
    context.font = "normal " + textHeight + "px Arial";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillStyle = "#ffffff";
    context.fillText(message, textWidth / 2, textHeight / 2);
    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    const material = new THREE.MeshBasicMaterial({
      color: 16777215,
      side: THREE.DoubleSide,
      map: texture,
      transparent: true
    });
    const geometry = new THREE.PlaneGeometry(height * textWidth / textHeight, height);
    const plane = new THREE.Mesh(geometry, material);
    return plane;
  }
};
var css = {
  code: ".container.svelte-1t730xc.svelte-1t730xc{display:grid;place-items:center;height:100vh}.container.svelte-1t730xc h1.svelte-1t730xc{color:white;margin:0 auto}.container.svelte-1t730xc .xrButton.svelte-1t730xc{cursor:pointer;background:#1ee8b7;padding:1em;font-size:1.5em;border-radius:1em}",
  map: `{"version":3,"file":"ar.svelte","sources":["ar.svelte"],"sourcesContent":["<script>\\r\\n\\timport { onMount } from 'svelte';\\r\\n\\timport Icon from 'svelte-awesome/components/Icon.svelte';\\r\\n\\timport { refresh } from 'svelte-awesome/icons';\\r\\n\\timport App from '$lib/threejs/arPortfolio.js';\\r\\n\\r\\n\\tlet xrSupported = null;\\r\\n\\tlet app;\\r\\n\\r\\n\\tonMount(() => {\\r\\n\\t\\tif ('xr' in navigator) {\\r\\n\\t\\t\\tnavigator.xr.isSessionSupported('immersive-ar').then((supported) => {\\r\\n\\t\\t\\t\\txrSupported = supported;\\r\\n\\t\\t\\t\\tif (xrSupported) {\\r\\n\\t\\t\\t\\t\\twindow.focus();\\r\\n\\t\\t\\t\\t\\tapp = new App();\\r\\n\\t\\t\\t\\t\\twindow.app = app;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\t});\\r\\n<\/script>\\r\\n\\r\\n<div class=\\"container\\">\\r\\n\\t{#if xrSupported == null}\\r\\n\\t\\t<Icon data={refresh} spin />\\r\\n\\t{:else if xrSupported == true}\\r\\n\\t\\t<div class=\\"xrButton\\" on:click={app.startAR()}> \\r\\n\\t\\t\\tSee AR Portfolio\\t\\r\\n\\t\\t</div>\\r\\n\\t{:else}\\r\\n\\t\\t<div>\\r\\n\\t\\t\\t<h1>XR is not available on this device. Kindly switch to Chrome for AR experience</h1>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n</div>\\r\\n\\r\\n<style lang=\\"scss\\">.container {\\n  display: grid;\\n  place-items: center;\\n  height: 100vh;\\n}\\n.container h1 {\\n  color: white;\\n  margin: 0 auto;\\n}\\n.container .xrButton {\\n  cursor: pointer;\\n  background: #1ee8b7;\\n  padding: 1em;\\n  font-size: 1.5em;\\n  border-radius: 1em;\\n}</style>\\r\\n"],"names":[],"mappings":"AAqCmB,UAAU,8BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,KAAK,AACf,CAAC,AACD,yBAAU,CAAC,EAAE,eAAC,CAAC,AACb,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC,AACD,yBAAU,CAAC,SAAS,eAAC,CAAC,AACpB,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,OAAO,CACnB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,GAAG,AACpB,CAAC"}`
};
var Ar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let xrSupported = null;
  let app;
  onMount(() => {
    if ("xr" in navigator) {
      navigator.xr.isSessionSupported("immersive-ar").then((supported) => {
        xrSupported = supported;
        if (xrSupported) {
          window.focus();
          app = new App();
          window.app = app;
        }
      });
    }
  });
  $$result.css.add(css);
  return `<div class="${"container svelte-1t730xc"}">${xrSupported == null ? `${validate_component(Icon, "Icon").$$render($$result, { data: refresh, spin: true }, {}, {})}` : `${xrSupported == true ? `<div class="${"xrButton svelte-1t730xc"}">See AR Portfolio	
		</div>` : `<div><h1 class="${"svelte-1t730xc"}">XR is not available on this device. Kindly switch to Chrome for AR experience</h1></div>`}`}
</div>`;
});
var ar = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Ar
});

// .svelte-kit/netlify/entry.js
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const rawBody = headers["content-type"] === "application/octet-stream" ? new TextEncoder("base64").encode(body) : isBase64Encoded ? Buffer.from(body, "base64").toString() : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      headers: rendered.headers,
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
